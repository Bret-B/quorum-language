package Libraries.Interface.Controls

use Libraries.Interface.Item2D
use Libraries.Interface.Views.ControlView
use Libraries.Interface.Behaviors.Behavior
use Libraries.Interface.Events.BehaviorEvent
use Libraries.Interface.Events.ControlActivationEvent
use Libraries.Interface.Events.ControlActivationListener
use Libraries.Interface.Events.SelectionEvent
use Libraries.Interface.Events.SelectionListener
use Libraries.Interface.Layouts.Layout
use Libraries.Interface.Layouts.LayoutProperties
use Libraries.Containers.Array
use Libraries.Game.GameStateManager
use Libraries.Game.Graphics.Font
use Libraries.Game.Graphics.Color
use Libraries.Game.Graphics.ColorGroup
use Libraries.System.File
use Libraries.Game.InputTable
use Libraries.Game.Game
use Libraries.Game.Graphics.TextureRegion

class Control is Item2D

    // The following constants are used for SetHorizontalLayoutMode() and
    // SetVerticalLayoutMode().
    /*
    The STANDARD layout style calculates the dimensions and positions of the
    Control using percentages of the Control's dimensions combined with static
    pixel values. Because this is dependent on the container's size to calculate
    the percentages, this is incompatible with container layouts that use the
    children to determine its own size, such as FIT_CONTENTS.
    */
    public integer STANDARD = 0

    /*
    The FILL layout style will attempt to fill the remaining width or height of
    the container with this Control. Note that this is only effective if the
    container's dimensions are already known independently of this element's
    size -- for example, a FILL layout can't be effectively used if the
    container's layout style is FIT_CONTENTS.
    */
    public integer FILL = 1

    /*
    The FIT_CONTENTS layout style will calculate this Control's dimensions as
    the combined total dimensions of its children elements. Because children
    elements often need to have some concrete information about the parent's
    dimensions, it's recommended to only use this in one of the two directions
    (horizontally or vertically) for the Control. For example, FlowLayouts work
    well with elements with a predetermined STANDARD horizontal layout style and
    using FIT_CONTENTS for the vertical layout style.
    */
    public integer FIT_CONTENTS = 2
    /*
    The FIT_FONT layout style is used to ensure a Control's height can fit the
    Font used in this LayoutProperties, plus padding from the children elements.
    FIT_FONT is only effective for the vertical layout style, and requires that
    a Font is present in this LayoutProperties.
    */
    public integer FIT_FONT = 3

    /*
    The MAINTAIN_ASPECT_RATIO layout style is used to calculate one of the
    dimensions of the Control relative to the other dimension. For example, it
    can be used to ensure that the width of a Control is always 120% of the
    height. This style can only be used to calculate one of the two dimensions
    (width or height) at a time. For example, if the horizontal layout style is
    MAINTAIN_ASPECT_RATIO, the vertical layout style must be different, such as
    using the STANDARD style.
    */
    public integer MAINTAIN_ASPECT_RATIO = 4

    Array<ControlActivationListener> listeners

    /*
    LayoutProperties describe how this Item are laid out by Layouts. If the
    Item has multiple LayoutProperties objects, the most appropriate one will
    be chosen based on the container's size.
    */
    Array<LayoutProperties> layoutProperties
    
    /*
    The default LayoutProperties, used by many controls to set their base visual
    information and provide default values.
    */
    LayoutProperties defaultProperties

    /*
    The LayoutProperties that were last used to define the properties of this
    Control. Used to indicate when graphics should be reloaded due to Layout
    changes.
    */
    LayoutProperties currentProperties = undefined

    /*
    A layout which is used to arrange the children of this object.
    */
    Layout layout = undefined

    /*
    Whether or not this Control should automatically be laid out during the
    next Update loop.
    */
    boolean needsLayout = false

    PopupMenu contextMenu = undefined

    // SelectionListeners which are registered with this Control. They'll be
    // informed of selection changes in this Control, if the Control has an
    // associated selection.
    Array<SelectionListener> selectionListeners

    /*
        This action obtains the Input Table from this control, copies it, 
        assigns it a group name, sets the control to use the new input table,
        and then adds it to the global input table hash table. 

        Attribute: Parameter name the name of the group for the new input table.
        Attribute: Returns the input table copy

        Attribute: Example
        use Libraries.Game.Game
        use Libraries.Interface.Controls.TextBox
        use Libraries.Game.InputTable

        class Main is Game
            action Main
                StartGame()
            end

            action CreateGame
                TextBox box
                InputTable copy = box:CopyAndActivateInputTable("New Group")
            end

            action Update(number seconds)
            end
        end
    */
    action CopyAndActivateInputTable(text name) returns InputTable
        InputTable inputTable = GetInputTable():Copy()
        inputTable:SetIdentifier(name)
        SetInputGroup(name)

        GameStateManager manager
        manager:GetGame():AddInputTable(inputTable)
        return inputTable
    end

    action ClickedMouse
        if GetView2D() is ControlView
            ControlView content = cast(ControlView, GetView2D())
            content:ClickedMouse()
        end
    end

    action ReleasedMouse
        if GetView2D() is ControlView
            ControlView content = cast(ControlView, GetView2D())
            content:ReleasedMouse()
        end
    end

    action BeginMouseOver
        if GetView2D() is ControlView
            ControlView content = cast(ControlView, GetView2D())
            content:BeginMouseOver()
        end
    end

    action EndMouseOver
        if GetView2D() is ControlView
            ControlView content = cast(ControlView, GetView2D())
            content:EndMouseOver()
        end
    end

    action GainedSelection
        if GetView2D() is ControlView
            ControlView content = cast(ControlView, GetView2D())
            content:GainedSelection()
        end
    end

    action LostSelection
        if GetView2D() is ControlView
            ControlView content = cast(ControlView, GetView2D())
            content:LostSelection()
        end
    end

    /*
        This action returns a default behavior for this paricular control. Some
        controls do nothing by default, like a TextBox that responds to different kinds
        of input. Others, however, have default behaviors, like a Button or a MenuItem. 
        If there is no default behavior, this action returns undefined.
    */
    action GetActivationBehavior returns Behavior
        return undefined
    end

    action Activate
        BehaviorEvent event
        event:SetItem(me)
        Activate(event)
    end

    action Activate(BehaviorEvent event)
        if GetActivationBehavior() not= undefined
            if event:GetItem() = undefined or not event:GetItem():Equals(me)
                event = event:Copy()
                event:SetItem(me)
            end
            GetActivationBehavior():Run(event)

            ControlActivationEvent controlEvent
            controlEvent:Set(me, event)
            NotifyControlActivationListeners(controlEvent)
        end
    end

    /*  
    This action adds a different Item2D into this one. This makes a few things happen.
        1. The added item will get this item as its parent.
        2. The added item's x and y coordinates will become relative to this Item.
        3. Most actions on this Item will also affect the added Item.

    Attribute: Example

        use Libraries.Interface.Item2D

        Item2D parentItem
        Item2D child
        parentItem:Add(child)
        
    */
    action Add(Item2D newItem)
        parent:Item2D:Add(newItem)

        if newItem is Control
            Control c = cast(Control, newItem)
            c:SetInterfaceScale(GetInterfaceScale())
            c:RequestLayout()
        end
    end

    /*  
    This action adds a different Item2D into this one, storing the added Item2D
    at a specific index in the internal array.

    Attribute: Example

        use Libraries.Interface.Item2D

        Item2D parentItem
        Item2D child
        parentItem:Add(0, child)
        
    */
    action Add(integer index, Item2D newItem)
        parent:Item2D:Add(index, newItem)

        if newItem is Control
            Control c = cast(Control, newItem)
            c:SetInterfaceScale(GetInterfaceScale())
            c:RequestLayout()
        end
    end

    action Remove(Item2D item) returns boolean
        RequestLayout()
        return parent:Item2D:Remove(item)
    end

    action Remove(integer index) returns Item2D
        RequestLayout()
        return parent:Item2D:Remove(index)
    end

    action AddControlActivationListener(ControlActivationListener listener)
        listeners:Add(listener)
    end

    action RemoveControlActivationListener(ControlActivationListener listener)
        listeners:Remove(listener)
    end

    action NotifyControlActivationListeners(ControlActivationEvent event)
        integer counter = 0
        repeat while counter < listeners:GetSize()
            listeners:Get(counter):ControlActivated(event)
            counter = counter + 1
        end

        GameStateManager manager
        manager:GetInput():NotifyControlActivationListeners(event)
    end

    action SetLayout(Layout layout)
        me:layout = layout
    end

    action GetLayout returns Layout
        return layout
    end

    action AddLayoutProperties(LayoutProperties properties)
        layoutProperties:Add(properties)
        layoutProperties:Sort()
    end

    action RemoveLayoutProperties(LayoutProperties properties)
        layoutProperties:Remove(properties)
    end

    action GetLayoutProperties returns Array<LayoutProperties>
        return layoutProperties
    end

    /*
    This action returns the best suited LayoutProperties stored by the Control
    for use with the given container width and height. The Control will attempt
    to find the most restricted LayoutProperties that is still valid,
    prioritizing width over height in case of equal values.

    Attribute: Parameter containerWidth The width of the container the LayoutProperties must be legal for.
    Attribute: Parameter containerHeight The height of the container the LayoutProperties must be legal for.
    Attribute: Returns The LayoutProperties contained in the Control that is best suited to the requested container dimensions.
    */
    action GetLayoutProperties(number containerWidth, number containerHeight) returns LayoutProperties
        LayoutProperties properties = undefined
        Array<LayoutProperties> array = GetLayoutProperties()
        integer counter = array:GetSize()

        /*
        Layouts are sorted by minimum width, or minimum height if minimum
        widths are equal. When we find an invalid layout, it's assumed that
        all following layouts will also be invalid.
        */
        repeat while counter > 0
            counter = counter - 1
            LayoutProperties temp = array:Get(counter)
            if (temp:GetMaximumContainerWidth() >= containerWidth and temp:GetMaximumContainerHeight() >= containerHeight)
                properties = temp
            end
        end

        if properties = undefined
            properties = GetDefaultLayoutProperties()
        end

        return properties
    end

    /*
    This action returns the default LayoutProperties used for this Control.

    Attribute: Returns The default LayoutProperties of this Control.
    */
    action GetDefaultLayoutProperties returns LayoutProperties
        return defaultProperties
    end

    /*
    This action returns the LayoutProperties that were last used to define the
    Control, and thus describe its current state. Note that if the Control 
    hasn't been laid out yet, this will return undefined.

    Attribute: Returns The last LayoutProperties used to layout this Control, or undefined if it hasn't been laid out yet.
    */
    action GetCurrentLayoutProperties returns LayoutProperties
        return currentProperties
    end

    /*
    This action is used to load the graphical components of the Control. This is
    handled automatically by the Game engine as needed, and most users shouldn't
    need to use this action directly.
    */
    action LoadGraphics(LayoutProperties properties)
        if currentProperties not= undefined
            currentProperties:SetRenderingFlag(true)
        end

        currentProperties = properties

        if currentProperties not= undefined
            currentProperties:SetRenderingFlag(false)
        end
    end

    /*
    The SetHorizontalLayoutMode is used to determine how the width of a
    Control is calculated. It should be one of the following constants:
    STANDARD, which will calculate the width as a set number of pixels plus a
    percentage of the container's width.
    FILL, which will make the width fill the remaining width of the container.
    FIT_CONTENTS, which will calculate the width to fit the children contents.

    Attribute: Parameter mode A layout mode constant, one of STANDARD, FILL, or FILL_CONTENTS.
    */
    action SetHorizontalLayoutMode(integer mode)
        defaultProperties:SetHorizontalLayoutMode(mode)
    end

    action GetHorizontalLayoutMode returns integer
        return defaultProperties:GetHorizontalLayoutMode()
    end

    /*
    The GetVerticalLayoutMode is used to determine how the height of a
    Control is calculated. It should be one of the following constants:
    STANDARD, which will calculate the height as a set number of pixels plus a
    percentage of the container's height.
    FILL, which will make the height fill the remaining height of the container.
    FIT_CONTENTS, which will calculate the height to fit the children contents.
    FIT_FONT, which will fit the height of the Control to the line height of the
    Font set in this LayoutProperties.

    Attribute: Parameter mode A layout mode constant, one of STANDARD, FILL, FILL_CONTENTS, or FIT_FONT.
    */
    action SetVerticalLayoutMode(integer mode)
        defaultProperties:SetVerticalLayoutMode(mode)
    end

    action GetVerticalLayoutMode returns integer
        return defaultProperties:GetVerticalLayoutMode()
    end

    /*
    This action sets the x position of the Control relative to the size of its
    container, if the container's Layout supports it.

    Attribute: Parameter x The target x position as a percentage (as a value between 0.0 and 1.0) of the container's width.
    */
    action SetPercentageX(number x)
        defaultProperties:SetPercentageX(x)
    end

    /*
    This action returns the x position of the Control relative to the size of 
    its container, if the container's Layout supports it.

    Attribute: Returns The target x position as a percentage (as a value between 0.0 and 1.0) of the container's width.
    */
    action GetPercentageX returns number
        return defaultProperties:GetPercentageX()
    end

    /*
    This action sets the y position of the Control relative to the size of its
    container, if the container's Layout supports it.

    Attribute: Parameter y The target y position as a percentage (as a value between 0.0 and 1.0) of the container's width.
    */
    action SetPercentageY(number y)
        defaultProperties:SetPercentageY(y)
    end

    /*
    This action returns the y position of the Control relative to the size of 
    its container, if the container's Layout supports it.

    Attribute: Returns The target y position as a percentage (as a value between 0.0 and 1.0) of the container's height.
    */
    action GetPercentageY returns number
        return defaultProperties:GetPercentageY()
    end

    /*
    This action sets the x position of the Control in pixels, if the container's 
    Layout supports it. If the Control has also been set to use a percentage of
    the container's width to set the x position, then the two values will be
    added together.

    Attribute: Parameter x The target x position of this Control in pixels.
    */
    action SetPixelX(number x)
        defaultProperties:SetPixelX(x)
    end

    /*
    This action returns the target x position of the Control in pixels. Note
    that this may not be used by some layouts (such as FlowLayout).

    Attribute: Returns The target x position of this Control in pixels.
    */
    action GetPixelX returns number
        return defaultProperties:GetPixelX()
    end

    /*
    This action sets the y position of the Control in pixels, if the container's 
    Layout supports it. If the Control has also been set to use a percentage of
    the container's height to set the y position, then the two values will be
    added together.

    Attribute: Parameter y The target y position of this Control in pixels.
    */
    action SetPixelY(number y)
        defaultProperties:SetPixelY(y)
    end

    /*
    This action returns the target y position of the Control in pixels. Note
    that this may not be used by some layouts (such as FlowLayout).

    Attribute: Returns The target y position of this Control in pixels.
    */
    action GetPixelY returns number
        return defaultProperties:GetPixelY()
    end

    action SetPercentageWidth(number width)
        defaultProperties:SetPercentageWidth(width)
    end

    action GetPercentageWidth returns number
        return defaultProperties:GetPercentageWidth()
    end

    action SetPercentageHeight(number height)
        defaultProperties:SetPercentageHeight(height)
    end

    action GetPercentageHeight returns number
        return defaultProperties:GetPercentageHeight()
    end

    action SetPixelWidth(number width)
        defaultProperties:SetPixelWidth(width)
    end

    action GetPixelWidth returns number
        return defaultProperties:GetPixelWidth()
    end

    action SetPixelHeight(number height)
        defaultProperties:SetPixelHeight(height)
    end

    action GetPixelHeight returns number
        return defaultProperties:GetPixelHeight()
    end

    action SetLeftPadding(number padding)
        defaultProperties:SetLeftPadding(padding)
    end

    action SetRightPadding(number padding)
        defaultProperties:SetRightPadding(padding)
    end

    action SetBottomPadding(number padding)
        defaultProperties:SetBottomPadding(padding)
    end

    action SetTopPadding(number padding)
        defaultProperties:SetTopPadding(padding)
    end

    action GetLeftPadding returns number
        return defaultProperties:GetLeftPadding()
    end

    action GetRightPadding returns number
        return defaultProperties:GetRightPadding()
    end

    action GetBottomPadding returns number
        return defaultProperties:GetBottomPadding()
    end

    action GetTopPadding returns number
        return defaultProperties:GetTopPadding()
    end

    /*
    This action sets the text in this Control's label, if it has one.

    Attribute: Parameter labelText The text to use for this Control's label.
    */
    action SetLabelText(text labelText)
        defaultProperties:SetLabelText(labelText)
    end

    /*
    This action returns the text used for this Control's label, if it has one.

    Attribute: Returns The text of this Control's label.
    */
    action GetLabelText returns text
        return defaultProperties:GetLabelText()
    end

    /*
    This action sets the Icon used by this Control. Different Controls use this
    Icon differently, depending on their purpose.

    Attribute: Parameter icon The Icon to use for this Control.
    */
    action SetIcon(TextureRegion icon)
        defaultProperties:SetIcon(icon)
    end

    /*

    */
    action GetIcon returns TextureRegion
        return defaultProperties:GetIcon()
    end

    /*

    */
    action SetIconColor(ColorGroup color)
        defaultProperties:SetIconColor(color)
    end

    /*

    */
    action GetIconColor returns ColorGroup
        return defaultProperties:GetIconColor()
    end

    /*
    This action sets the Font to be used by this Control. How this Font is used
    varies between Controls, and in some cases the Control will ignore it 
    entirely (for example, ScrollPanes), but typically this sets the font that's
    used for the default label on many Controls, such as Buttons. If the Font
    is undefined, many Controls will omit their default label.

    Attribute: Parameter font The Font to use for this Control.
    */
    action SetFont(Font font)
        defaultProperties:SetFont(font)
    end

    /*
    This action returns the Font being used by this Control. How this Font is 
    used varies between Controls, and in some cases the Control will ignore it 
    entirely (for example, ScrollPanes), but typically this sets the font that's
    used for the default label on many Controls, such as Buttons. If the Font
    is undefined, many Controls will omit their default label.

    Attribute: Returns The Font being used for this Control.
    */
    action GetFont returns Font
        return defaultProperties:GetFont()
    end

    /*
    This action sets the base Font size to be used by this Control, if the
    Control uses a Font.
    */
    action SetFontSize(integer size)
        defaultProperties:SetFontSize(size)
    end

    /*
    This action returns the base Font size to be used by this Control, if the
    Control uses a Font.
    */
    action GetFontSize returns integer
        return defaultProperties:GetFontSize()
    end

    /*

    */
    action SetBackgroundColor(ColorGroup color)
        defaultProperties:SetBackgroundColor(color)
    end

    /*

    */
    action GetBackgroundColor returns ColorGroup
        return defaultProperties:GetBackgroundColor()
    end

    /*

    */
    action SetSelectionColor(ColorGroup color)
        defaultProperties:SetSelectionColor(color)
    end

    /*

    */
    action GetSelectionColor returns ColorGroup
        return defaultProperties:GetSelectionColor()
    end

    /*

    */
    action SetFontColor(Color color)
        defaultProperties:SetFontColor(color)
    end

    /*

    */
    action GetFontColor returns Color
        return defaultProperties:GetFontColor()
    end

    /*

    */
    action SetSelectionFontColor(Color color)
        defaultProperties:SetSelectionFontColor(color)
    end

    /*

    */
    action GetSelectionFontColor returns Color
        return defaultProperties:GetSelectionFontColor()
    end

    /*

    */
    action SetUnfocusedSelectionColor(ColorGroup color)
        defaultProperties:SetUnfocusedSelectionColor(color)
    end

    /*

    */
    action GetUnfocusedSelectionColor returns ColorGroup
        return defaultProperties:GetUnfocusedSelectionColor()
    end

    /*

    */
    action SetBorderColor(ColorGroup color)
        defaultProperties:SetBorderColor(color)
    end

    /*
    
    */
    action GetBorderColor returns ColorGroup
        return defaultProperties:GetBorderColor()
    end

    /*

    */
    action SetSelectionBorderColor(ColorGroup color)
        defaultProperties:SetSelectionBorderColor(color)
    end

    /*

    */
    action GetSelectionBorderColor returns ColorGroup
        return defaultProperties:GetSelectionBorderColor()
    end

    /*

    */
    action SetBorderThickness(integer thickness)
        defaultProperties:SetBorderThickness(thickness)
    end

    /*

    */
    action GetBorderThickness returns integer
        return defaultProperties:GetBorderThickness()
    end

    /*

    */
    action SetInterfaceScale(number scale)
        defaultProperties:SetInterfaceScale(scale)
        defaultProperties:SetRenderingFlag(true)

        Array<Item2D> children = GetChildren()
        integer counter = 0
        repeat while counter < children:GetSize()
            if children:Get(counter) is Control
                Control control = cast(Control, children:Get(counter))
                control:SetInterfaceScale(scale)
            end
            counter = counter + 1
        end
    end

    /*

    */
    action GetInterfaceScale returns number
        return defaultProperties:GetInterfaceScale()
    end
    
    /*
        This action defines what the default font is for this control. This allows
        individual controls to customize their default font properties on a per control
        basis.

        Attribute: Example

        use Libraries.Interface.Controls.TextBox

        TextBox box
        text name = box:GetDefaultFontName()
        output name
    */
    action GetDefaultFontName returns text
        text name = undefined
        Font font
        if font:IsFontAvailable("FiraCode-Retina")
            name = "FiraCode-Retina"
        elseif font:IsFontAvailable("FiraCode-Regular")
            name = "FiraCode-Regular"
        elseif font:IsFontAvailable("Courier")
            name = "Courier"
        elseif font:IsFontAvailable("Courier New")
            name = "Courier New"
        elseif font:IsFontAvailable("cour")
            name = "cour"
        elseif font:IsFontAvailable("Roboto-Black")
            name = "Roboto-Black"
        elseif font:IsFontAvailable("Arial")
            name = "Arial"
        else
            Array<File> availableFontFiles = font:GetAvailableFonts()
            if availableFontFiles:GetSize() > 0
                File file = availableFontFiles:Get(0)
                name = file:GetPath()
            end
        end
        return name
    end

    /*
        This action obtains the default font for this control. This allows
        individual controls to customize their default font properties on a per control
        basis. By default, the system asks for the default system font name on a 
        per control basis, then loads that font and returns it. Font loading is
        shared, so loading many fonts of the same type and size is not particularly
        expensive and can be done without much concern for memory requirements.

        Attribute: Example

        use Libraries.Interface.Controls.TextBox
        use Libraries.Game.Graphics.Font

        TextBox box
        text name = box:GetDefaultFont()
        output name
    */
    action GetDefaultFont returns Font
        Font font
        text defaultFontName = GetDefaultFontName()
        if defaultFontName not= undefined
            integer defaultFontSize = GetDefaultFontSize()
            font:SetSize(defaultFontSize)
            font:LoadFont(defaultFontName)
            return font
        end
        return undefined
    end

    /*
        This action defines what the default font size for this control. This allows
        individual controls to customize their default font properties on a per control
        basis.

        Attribute: Example

        use Libraries.Interface.Controls.TextBox

        TextBox box
        integer size = box:GetDefaultFontSize()
        output size
    */
    action GetDefaultFontSize returns integer
        return 14
    end

    /*
    This action requests that this Control should be laid out by its container
    (or the Layer2D if there is no containing Control) during the next Update.
    */
    action RequestLayout
        needsLayout = true

        // If the parent container fits its contents based on us, and we need to
        // be laid out again, then the parent needs to be laid out as well, as  
        // its size may change.
        Item2D parentItem = GetParent()
        if parentItem not= undefined and parentItem is Control
            Control container = cast(Control, parentItem)
            LayoutProperties properties = container:GetDefaultLayoutProperties()
            
            if properties:GetHorizontalLayoutMode() = properties:FIT_CONTENTS
                or properties:GetVerticalLayoutMode() = properties:FIT_CONTENTS
                container:RequestLayout()
            end
        end
    end

    /*
    This action is used to indicate that the Control no longer needs to be laid
    out. This is called internally by the system as needed, and shouldn't be
    necessary for most users.
    */
    action ResetLayoutFlag
        needsLayout = false
    end

    /*
    This action returns whether or not the Control is in need of laying out by
    its container (or the parent Layer2D, if no container Control exists).
    */
    action NeedsLayout returns boolean
        return needsLayout
    end

    /*

    */
    action UpdateAll(number seconds)
        Update(seconds)
        UpdateBehaviors(seconds)

        integer counter = 0
        boolean haveResized = false

        repeat GetItemCount() times
            Item item = GetChildAsItem(counter)
            if item is Control and haveResized = false
                Control control = cast(Control, item)
                if control:NeedsLayout()
                    Resize()
                    haveResized = true
                end
            end

            item:UpdateAll(seconds)
            counter = counter + 1
        end
    end

    /*
    The SetPopupMenu action attaches a PopupMenu to this Control, which can
    be opened by interacting with it (most commonly by right-clicking on the
    Control).
    */
    action SetPopupMenu(PopupMenu menu)
        contextMenu = menu
    end

    /*
    The GetContextMenu action returns this Control's context menu, if it has
    one. A context menu is a PopupMenu which appears when a user wants additonal
    context about this Control (most commonly by right-clicking on the Control).
    */
    action GetPopupMenu returns PopupMenu
        return contextMenu
    end

    /*

    */
    action AddSelectionListener(SelectionListener listener)
        selectionListeners:Add(listener)
    end

    /*

    */
    action RemoveSelectionListener(SelectionListener listener) returns boolean
        return selectionListeners:Remove(listener)
    end

    /*

    */
    action EmptySelectionListeners
        selectionListeners:Empty()
    end

    /*

    */
    action GetSelectionListeners returns Array<SelectionListener>
        return selectionListeners
    end

    /*
    This action will notify all SelectionListeners which have been added to the
    Control of the given SelectionEvent.

    Attribute: Parameter event The SelectionEvent to send to all SelectionListeners registered with the Control.
    */
    action NotifySelectionListeners(SelectionEvent event)
        integer counter = 0
        repeat while counter < selectionListeners:GetSize()
            selectionListeners:Get(counter):SelectionChanged(event)
            counter = counter + 1
        end
    end
end
