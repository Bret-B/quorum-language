package Libraries.Interface.Controls.Charts.Graphics

use Libraries.Interface.Controls.Charts.all
use Libraries.Game.Graphics.Drawable
use Libraries.Interface.Controls.Icon
use Libraries.Compute.Statistics.Tests.Regression
use Libraries.Compute.Vector
use Libraries.Compute.Math
use Libraries.Containers.Array
use Libraries.Game.Graphics.LinePath
use Libraries.Game.Graphics.Painter2D
use Libraries.Compute.Vector2

class RegressionLine is ChartDrawable, LinePath
    private Regression regression = undefined
    private Series series = undefined
    private Math math
    private Icon icon 
    private ChartLabel equation
    private ChartLabel rsquared
    private text equationText = ""
    private text rsquaredText = ""
    private integer lineDensity = 4     
    private text dependentVariable = ""
    private Array<text> independentVariables    // This would be used when we have multi-variate regression
    private boolean nameAfterSeries = false

    on create
        SetFocusable(true)
        SetAccessibilityCode(parent:Item:ITEM)

        // LinePath properties
        SetCurving(false)

        // Default LinePath points, to be overridden when setting the two endpoints with SetX1 etc.
        Add(0, 0)
        Add(0, 0)
        Add(0, 0)
    end

    action Draw(Painter2D painter)
        parent:LinePath:Draw(painter)
    end

    action GetRegression returns Regression
        return regression
    end

    action SetRegression(Regression regression)
        me:regression = regression
    end

    action SetRegressionIcon(Icon icon)
        me:icon = icon
    end

    action GetRegressionIcon returns Icon
        return icon
    end

    action SetIcon(TextureRegion region)
        if region is Icon
            icon = cast(Icon, region)
        end
        parent:Control:SetIcon(region)
    end

    action GetIcon returns TextureRegion
        return icon
    end

    action GetLabel() returns ChartLabel
        return equation
    end

    action GetEquationLabel() returns ChartLabel
        return equation
    end

    action GetRSquaredLabel() returns ChartLabel
        return rsquared
    end

    action GetSeries returns Series
        return series
    end

    action SetSeries(Series series)
        me:series = series
    end

    action SetLineDensity(integer lineDensity)
        me:lineDensity = lineDensity
    end

    action GetLineDensity returns integer
        return lineDensity
    end

    action SetVariableNames(text yAxisTitle, text xAxisTitle, boolean isHorizontal, boolean orientationChanged)
        if isHorizontal or (not isHorizontal and not orientationChanged)
            if xAxisTitle = ""
                SetIndependentVariable("x")
            else
                SetIndependentVariable(xAxisTitle)
            end
            if NamedAfterSeries() and yAxisTitle = ""
                SetDependentVariableWithSeries()
            else
                if yAxisTitle = ""
                    SetDependentVariable("y")
                else
                    SetDependentVariable(yAxisTitle)
                end
            end
        else
            if yAxisTitle = ""
                SetIndependentVariable("y")
            else
                SetIndependentVariable(yAxisTitle)
            end
            if NamedAfterSeries() and xAxisTitle = ""
                SetDependentVariableWithSeries()
            else
                if xAxisTitle = ""
                    SetDependentVariable("x")
                else
                    SetDependentVariable(xAxisTitle)
                end
            end
        end
        GenerateEquation()
    end

    action SetDependentVariable(text dependentVariable)
        me:dependentVariable = dependentVariable
    end

    action SetDependentVariableWithSeries()
        if series not= undefined
            me:dependentVariable = series:GetName()
        end
    end

    action NamedAfterSeries(boolean nameAfterSeries)
        me:nameAfterSeries = nameAfterSeries
    end

    action NamedAfterSeries returns boolean
        return nameAfterSeries
    end

    action SetIndependentVariable(text independentVariable)
        independentVariables:Empty()
        independentVariables:Add(independentVariable)
    end

    action SetIndependentVariables(Array<text> independentVariables)
        if independentVariables:GetSize() not= regression:GetCoefficients():GetSize()
            me:independentVariables:Empty()
            integer i = 0
            repeat while i < regression:GetCoefficients():GetSize()
                text var = "x"+(i+1)
                me:independentVariables:Add(var)
                i = i + 1
            end
        else
            me:independentVariables = independentVariables
        end
    end

    // Gives dependentVariable = (m*independentVariable) + b 
    action GenerateEquation()
        Math math
        Vector beta = regression:GetCoefficients()
        if beta:GetSize() > 1 and independentVariables:GetSize() > 0
            equationText = dependentVariable + " = " + math:Round(beta:Get(1),2) + "*" + independentVariables:Get(0)
            integer i = 2
            repeat while i < beta:GetSize() and (i-1) < independentVariables:GetSize()
                if math:Round(beta:Get(i),2) < 0
                    equationText = equationText + math:Round(beta:Get(i),2) + "*" + independentVariables:Get(i-1)
                else
                    equationText = equationText + "+ " + math:Round(beta:Get(i),2) + "*" + independentVariables:Get(i-1)
                end
                i = i + 1
            end
            if math:Round(beta:Get(0),2) < 0
                equationText = equationText + math:Round(beta:Get(0),2)
            else
                equationText = equationText + " + " + math:Round(beta:Get(0),2)
            end
        end
        rsquaredText = "R^2 = " + (math:Round(regression:GetEffectSize(),4))

        equation:SetText(equationText)
        equation:SetName(equationText)

        rsquared:SetText(rsquaredText)
        rsquared:SetName(rsquaredText)
    end 

    // Equation is (dependent(y)) = m * (independent(x)) + b
    action CalculateDependentValue(number independent) returns number
        number dependent = 0
        Vector beta = regression:GetCoefficients()
        if beta:GetSize() > 1
            dependent = beta:Get(1)*independent + beta:Get(0)
        end
        return dependent
    end

    // Equation is (dependent(y)) = m * (independent(x)) + b
    action CalculateIndependentValue(number dependent) returns number
        number independent = 0
        Vector beta = regression:GetCoefficients()
        if beta:GetSize() = 2 // This should only be used if there is a single dependent variable
            independent = (dependent - beta:Get(0))/(beta:Get(1))
        end
        return independent
    end

    private action RecalculateMidpoint
        SetPoint(1, (GetX1() + GetX2()) / 2.0, (GetY1() + GetY2()) / 2.0)
    end

    action SetPoint1(number x1, number y1)
        SetPoint(0, x1, y1)
        RecalculateMidpoint()
    end

    action SetPoint2(number x2, number y2)
        SetPoint(2, x2, y2)
        RecalculateMidpoint()
    end

    action SetX1(number x1)
        SetPoint(0, x1, GetY1())
        RecalculateMidpoint()
    end

    action SetY1(number y1)
        SetPoint(0, GetX1(), y1)
        RecalculateMidpoint()
    end

    action SetX2(number x2)
        SetPoint(2, x2, GetY2())
        RecalculateMidpoint()
    end

    action SetY2(number y2)
        SetPoint(2, GetX2(), y2)
        RecalculateMidpoint()
    end

    action GetX1 returns number
        return GetPointX(0)
    end

    action GetY1 returns number
        return GetPointY(0)
    end

    action GetX2 returns number
        return GetPointX(2)
    end

    action GetY2 returns number
        return GetPointY(2)
    end

    action GetPixelStartPosition returns Vector2
        Vector2 vector
        vector:Set(GetPoint(0))
        TranslateToMappedSpace(vector)
        return vector
    end

    action GetPixelEndPosition returns Vector2
        Vector2 vector
        vector:Set(GetPoint(2))
        TranslateToMappedSpace(vector)
        return vector
    end
end