package Libraries.Interface.Controls.Charts

use Libraries.Interface.Controls.Control
use Libraries.Interface.Selections.ChartSelection
use Libraries.Interface.Layouts.LayoutProperties
use Libraries.Interface.Views.ControlView
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Label
use Libraries.Interface.Controls.ControlLabel
use Libraries.Interface.Layouts.ManualLayout
use Libraries.Containers.Array
use Libraries.Interface.Controls.Charts.ChartOptions
use Libraries.Compute.Math
use Libraries.Game.Graphics.Color
use Libraries.Interface.Controls.Icon
use Libraries.Game.Graphics.ColorGroup
use Libraries.Game.Graphics.Font
use Libraries.Game.Graphics.TextureRegion
use Libraries.Interface.Views.View2D
use Libraries.Interface.Item
use Libraries.Interface.Controls.Charts.ChartDisplay
use Libraries.System.File
use Libraries.Interface.Views.LabelBoxView
use Libraries.System.DateTime

/*

    This class represents a generic chart on the system. By default, charts present visual 
    information to the user and also present themselves as accessible controls to the operating 
    system. This includes a selection, called ChartSelection, that can be queried for information 
    that is relevant to particular kinds of charts. For example, a bar chart might have labels, 
    axes, and bars. Each of these can be navigated up and down to go between parents, with the 
    top-most level being a summary and any ChartItems underneath being representations of the 
    underlying structure of the chart. 

    To put this in perspective, consider that a bar chart might allow one to navigate to a 
    level of a chart that contains the axes, bars, and labels. On the bars, if one presses the 
    down arrow, this now allows the user to navigate between the bars for information and this 
    changes the default selection, which informs the operating system of the change. The broad 
    purpose of this architecture is that it allows the chart to have an overall structure that 
    is different from the graphical structure, allowing the chart itself to set reasonable 
    defaults for how to navigate the control with the keyboard

    Attribute: Author Gabriel Contreras, Andreas Stefik, Hannah Williams

    Attribute: Example

    use Libraries.Interface.Controls.Charts
    use Libraries.Game.Game

    class Main is Games
        action Main
            StartGame()
        end

        action CreateGame
            BarChart chart
            Add(chart)
        end
    end
*/
class Chart is Control
    private Math math
    private Color color
    private ChartOptions options

    // Chart Accessibilty
    private boolean treeNeedsUpdate = true
    private ChartItem infoTreeRoot //The root chart item for all charts
    private ChartSelection selection
    private Color highlightColor = undefined
    private ColorGroup previousColorGroup = undefined
    private ColorGroup previousBackgroundColor = undefined
    private Color previousColor = undefined
    private number previousZ = 0

    // Chart Orientation
    private boolean horizontalOrientation = false
    private boolean verticalOrientation = false
    private boolean orientationChanged = false
    private boolean orientationCapable = true

    // Title Area Components
    private number titleAreaHeightPercent = 0.05
    private ControlLabel title = undefined
    private text titleText = "Chart Title"
    private boolean showTitle = true 
    private integer titlefontsize = 0
    private boolean titleFontSizeOverride = false
    private boolean allFontSizeOverride = false
//    private text titleLocation = "center" 

    // Subtitle Area Components - not implemented yet
    private number subtitleAreaHeightPercent = 0
    private ControlLabel subtitle = undefined
    private text subtitleText = "Subtitle"
    private boolean showSubtitle = false
    private integer subtitlefontsize = 0
    private boolean subtitleFontSizeOverride = false
//    private text subtitleLocation = "center"

    // Chart Area Components
    private Drawable background = undefined
    private ChartAreaPanel chartArea
    private Array<Icon> groupPanels
    private integer paddedChartOffset = 0
    private integer numberOfChartAreas = 1
    private integer regLineDensity = 0
    private boolean regressionCapable = false
    private boolean hasGroups = false
    private boolean defaultShowBrackets = false
    private boolean overrideDefaultShowBrackets = false

    // Chart Area Facetting
    private Array <ChartAreaPanel> subChartAreas
    private boolean separationCapable = false
    private boolean separateByFactor = false
    private boolean separateBySeries = false
    private boolean defaultSeparateBySeries = false
    private boolean defaultSeparateByFactor = false
    private boolean overrideDefaultSeparation = false
    private boolean showSubChartAreaBorders = true

    // X-Axis Components
    private HorizontalAxisPanel horizontalPanel
    private Array <HorizontalAxisPanel> subHorizontalPanels
    private boolean showXAxis = true   
    private boolean showMajorXGridLines = true
    private boolean showMinorXGridLines = false
    private boolean xLabelFontSizeOverride = false
    private boolean xTitleFontSizeOverride = false
    private boolean overrideXLabelsRotation = false
    private number horizontalPanelWidthPercent = 0.75
    private number horizontalPanelHeightPercent = 0.05
    private integer xLabelsRotation = 0
    private boolean xAxisIsIndependent = true

    // Y-Axis Components
    private VerticalAxisPanel verticalPanel
    private Array <VerticalAxisPanel> subVerticalPanels
    private boolean showYAxis = true
    private boolean showMajorYGridLines = true
    private boolean showMinorYGridLines = false   
    private boolean yLabelFontSizeOverride = false
    private boolean yTitleFontSizeOverride = false
    private number verticalPanelWidthPercent = 0.05
    private number verticalPanelHeightPercent = 0.75 
    private integer yLabelsRotation = 0

    // Legend Components
    private Legend legend
    private boolean showLegend = true
    private boolean legendLabelFontSizeOverride = false
    private boolean legendTitleFontSizeOverride = false
    private boolean showLinearRegression = false
    private number legendPanelWidthPercent = 0.05
    private number legendPanelHeightPercent = 0.05

    on create
        chartArea:SetName("Chart Area")
        Add(chartArea)
    end

    action IsAccessibleParent returns boolean
        return true
    end

    blueprint action GenerateSummary returns text
    private blueprint action GenerateInfoTree

    action LoadGraphics(LayoutProperties properties)
        DisposeDrawables()
        parent:Control:LoadGraphics(properties)   
        if properties = undefined
            return now
        end
        
        // Set default size if necessary
        if GetWidth() <= 0 or GetHeight() <= 0
            SetSize(1000,1000)
        end

        // Load background of display window
        if GetBackground() = undefined
            Drawable background
            background:LoadFilledRectangle(cast(integer, GetWidth()) ,cast(integer, GetHeight()), color:White())
            SetBackground(background)
            Add(background)
        end

        // Load background/border of chart area
        chartArea:LoadChartAreaView()
        
        if defaultSeparateBySeries and not overrideDefaultSeparation
            SeparateBySeries()
        elseif defaultSeparateByFactor and not overrideDefaultSeparation
            SeparateByFactor()
        end

        if defaultShowBrackets and HasGroups() and not overrideDefaultShowBrackets
            verticalPanel:ShowGroupBrackets(true)
            horizontalPanel:ShowGroupBrackets(true)
        end

        // Default highlight color is selection color (currently blue)
        if GetHighlightColor() = undefined
            SetHighlightColor(options:GetSelectionColor())
        end

        // Load sub chart areas and sub axis panels
        if numberOfChartAreas > 1
            Array<text> factorList = GetFactorList()
            if separateByFactor
                Array<text> newLabels
                integer size = GetSeriesList():GetSize()
                integer j = 0
                repeat while j < size
                    newLabels:Add(GetSeriesList():Get(j):GetName())
                    j = j + 1
                end
                if xAxisIsIndependent
                    horizontalPanel:SetTextLabels(newLabels)
                    horizontalPanel:SetTitleText(legend:GetTitleText())
                    horizontalPanel:NumericalOverrideLabels(false) //Set to false since new labels may not be numerical anymore
                else
                    verticalPanel:SetTextLabels(newLabels)
                    verticalPanel:SetTitleText(legend:GetTitleText())
                    verticalPanel:NumericalOverrideLabels(false) //Set to false since new labels may not be numerical anymore
                end      
            end
            integer i = 0
            repeat while i < numberOfChartAreas
                ChartAreaPanel subArea
                if separateByFactor
                    if i < factorList:GetSize()
                        subArea:SetName(factorList:Get(i))
                        ControlLabel newLabel
                        newLabel:SetText(subArea:GetName())
                        subArea:SetLabel(newLabel)
                        subArea:Add(newLabel)
                        chartArea:Add(subArea)
                    else
                        subArea:Hide()
                    end
                end
                if separateBySeries 
                    if i < GetSeriesList():GetSize()
                        subArea:SetName(GetSeriesList():Get(i):GetName())
                        ControlLabel newLabel
                        newLabel:SetText(subArea:GetName())
                        subArea:SetLabel(newLabel)
                        subArea:Add(newLabel)
                        chartArea:Add(subArea)
                    else
                        subArea:Hide()
                    end
                end

                subChartAreas:Add(subArea)
                if i < verticalPanel:GetNumberOfSections()
                    VerticalAxisPanel subYAxis
                    subYAxis:SetName("Sub y-axis")
                    subVerticalPanels:Add(subYAxis)
                end
                if i < horizontalPanel:GetNumberOfSections()
                    HorizontalAxisPanel subXAxis
                    subXAxis:SetName("Sub x-axis")
                    subHorizontalPanels:Add(subXAxis)
                end
                i = i + 1
            end
        end

        if IsShowingTitle()
            titleAreaHeightPercent = 0.10
            if GetTitleLabel() = undefined
                ControlLabel newLabel
                SetTitleLabel(newLabel)
                newLabel:SetText(titleText)
                Add(newLabel)
            end
        end

        if IsShowingSubtitle()
            subtitleAreaHeightPercent = 0.05
            if GetSubtitleLabel() = undefined
                ControlLabel newLabel
                SetSubtitleLabel(newLabel)
                newLabel:SetText(subtitleText)
                Add(newLabel)
            end
        end

        horizontalPanel:LoadAxis(me, properties)
        if IsShowingXAxis()
            horizontalPanel:SetAxisColor(color:Black())
            horizontalPanelHeightPercent = 0.15
            Add(horizontalPanel)
        end

        verticalPanel:LoadAxis(me, properties)
        if IsShowingYAxis()
            verticalPanel:SetAxisColor(color:Black())
            verticalPanelWidthPercent = 0.15
            Add(verticalPanel)
        end

        legend:ApplySeriesColor()
        legend:LoadLegend(me, properties)
        if IsShowingLegend()
            legendPanelWidthPercent = 0.10
            Add(legend)
        end

        Add(chartArea)
        if IsShowingLinearRegression()
            LoadRegressionLines()
        end
        SetNeedsUpdate(true)
        Resize()
        SetNextFocus(GetNextFocus())
        SetPreviousFocus(GetPreviousFocus())
    end

    /*
        This action will flip the axis min/max and any labels associated.  
        Then the un-used axis will be deactivated so it won't interfere with the
        accessibility navigation.
    */
    private action FlipAxisInfo()
        number temp = horizontalPanel:GetMaximum()
        horizontalPanel:SetMaximum(verticalPanel:GetMaximum())
        verticalPanel:SetMaximum(temp)

        temp = horizontalPanel:GetMinimum()
        horizontalPanel:SetMinimum(verticalPanel:GetMinimum())
        verticalPanel:SetMinimum(temp)

        temp = horizontalPanel:GetPaddingOffset()
        horizontalPanel:SetPaddingOffset(verticalPanel:GetPaddingOffset())
        verticalPanel:SetPaddingOffset(temp)

        DateTime tempdate = horizontalPanel:GetMaximumDate()
        horizontalPanel:SetMaximumDate(verticalPanel:GetMaximumDate())
        verticalPanel:SetMaximumDate(tempdate)

        tempdate = horizontalPanel:GetMinimumDate()
        horizontalPanel:SetMinimumDate(verticalPanel:GetMinimumDate())
        verticalPanel:SetMinimumDate(tempdate)

        Array <text> templabels = horizontalPanel:GetTextLabels()
        horizontalPanel:SetTextLabels(verticalPanel:GetTextLabels())
        verticalPanel:SetTextLabels(templabels)

        temp = horizontalPanel:GetTickInterval()
        horizontalPanel:SetTickInterval(verticalPanel:GetTickInterval())
        verticalPanel:SetTickInterval(temp)

        integer tempint = horizontalPanel:GetTickCount()
        horizontalPanel:SetTickCount(verticalPanel:GetTickCount())
        verticalPanel:SetTickCount(tempint)

        boolean tempflag = horizontalPanel:GetOverrideDefaultTickCount()
        horizontalPanel:OverrideDefaultTickCount(verticalPanel:GetOverrideDefaultTickCount())
        verticalPanel:OverrideDefaultTickCount(tempflag)

        tempflag = horizontalPanel:GetOverrideDefaultInterval()
        horizontalPanel:OverrideDefaultInterval(verticalPanel:GetOverrideDefaultInterval())
        verticalPanel:OverrideDefaultInterval(tempflag)

        tempflag = horizontalPanel:NumericalOverrideLabels()
        horizontalPanel:NumericalOverrideLabels(verticalPanel:NumericalOverrideLabels())
        verticalPanel:NumericalOverrideLabels(tempflag)

        tempflag = horizontalPanel:ShowGroupBrackets()
        horizontalPanel:ShowGroupBrackets(verticalPanel:ShowGroupBrackets())
        verticalPanel:ShowGroupBrackets(tempflag)

        tempflag = horizontalPanel:ShowTicks()
        horizontalPanel:ShowTicks(verticalPanel:ShowTicks())
        verticalPanel:ShowTicks(tempflag)

        tempflag = horizontalPanel:OverrideDefaultMin()
        horizontalPanel:OverrideDefaultMin(verticalPanel:OverrideDefaultMin())
        verticalPanel:OverrideDefaultMin(tempflag)

        tempflag = horizontalPanel:OverrideDefaultMax()
        horizontalPanel:OverrideDefaultMax(verticalPanel:OverrideDefaultMax())
        verticalPanel:OverrideDefaultMax(tempflag)

        text temptext = horizontalPanel:GetTitleText()
        horizontalPanel:SetTitleText(verticalPanel:GetTitleText())
        verticalPanel:SetTitleText(temptext)

        temptext = horizontalPanel:GetNumberFormat()
        horizontalPanel:SetNumberFormat(verticalPanel:GetNumberFormat())
        verticalPanel:SetNumberFormat(temptext)

        if xAxisIsIndependent
            xAxisIsIndependent = false
        end
    end

    private action DisposeDrawables()
        if title not= undefined
            title:Dispose()
            Remove(title)
            title = undefined
        end

        if background not= undefined
            background:Dispose()
            Remove(background)
            background = undefined
        end

        GetLegend():Empty()
        GetVerticalPanel():Empty()
        GetHorizontalPanel():Empty()
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetHorizontalPanel returns HorizontalAxisPanel
        return horizontalPanel
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetSubHorizontalPanels returns Array<HorizontalAxisPanel>
        return subHorizontalPanels
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetVerticalPanel returns VerticalAxisPanel
        return verticalPanel
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetSubVerticalPanels returns Array<VerticalAxisPanel>
        return subVerticalPanels
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetChartArea returns ChartAreaPanel
        return chartArea
    end

    action SetChartAreaBorderColor(ColorGroup color)
        chartArea:SetBorderColor(color)
    end

    action SetChartAreaBackgroundColor(ColorGroup color)
        chartArea:SetBackgroundColor(color)
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetSubChartAreas returns Array<ChartAreaPanel>
        return subChartAreas
    end

    /*
    This action allows user to show the borders around each sub chart area.
    By default this setting is set to true in most cases (with the exception of pie charts).
    */
    action ShowSubChartAreaBorders(boolean showSubChartAreaBorders)
        me:showSubChartAreaBorders = showSubChartAreaBorders
    end

    /*
    This action allows user to show the borders around each sub chart area.
    By default this setting is set to true.
    */
    action ShowSubChartAreaBorders returns boolean
        return showSubChartAreaBorders
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetNumberOfChartAreas returns integer
        return numberOfChartAreas
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    private action GetNumberOfVisibleChartAreas returns integer
        integer count = 0
        integer i = 0
        repeat while i < subChartAreas:GetSize()
            if subChartAreas:Get(i):IsShowing()
                count = count + 1
            end
            i = i + 1
        end
        return count
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetGroupPanels returns Array<Icon>
        return groupPanels
    end

    action GetChartAreaWidthPercent returns number
        return horizontalPanelWidthPercent
    end

    action GetChartAreaHeightPercent returns number
        return verticalPanelHeightPercent
    end

    private action SetChartAreaWidthPercent(number value)
        me:horizontalPanelWidthPercent = value
    end

    private action SetChartAreaHeightPercent(number value)
        me:verticalPanelHeightPercent = value
    end

    action GetHorizontalPanelHeightPercent returns number
        return horizontalPanelHeightPercent
    end

    private action SetHorizontalPanelHeightPercent (number value)
        horizontalPanelHeightPercent = value
    end

    action GetHorizontalPanelWidthPercent returns number
        return horizontalPanelWidthPercent
    end

    private action SetHorizontalPanelWidthtPercent (number value)
        horizontalPanelWidthPercent = value
    end

    action GetVerticalPanelHeightPercent returns number
        return verticalPanelHeightPercent
    end

    private action SetVerticalPanelHeightPercent (number num)
        verticalPanelHeightPercent = num
    end

    action GetVerticalPanelWidthPercent returns number
        return verticalPanelWidthPercent
    end

    private action SetVerticalPanelWidthtPercent (number num)
        verticalPanelWidthPercent = num
    end

    action ShowYTicks(boolean show)
        verticalPanel:ShowTicks(show)
    end

    action ShowXTicks(boolean show)
        horizontalPanel:ShowTicks(show)
    end    

    action ShowAllTicks
        verticalPanel:ShowTicks(true)
        horizontalPanel:ShowTicks(true)
    end
    action HideAllTicks
        verticalPanel:ShowTicks(false)
        horizontalPanel:ShowTicks(false)
    end

    action SetXTickCount(integer ticks)
        horizontalPanel:SetTickCount(ticks)
        horizontalPanel:OverrideDefaultTickCount(true)
    end

    action SetXTickInterval(number set)
        horizontalPanel:SetTickInterval(set)
        horizontalPanel:SetNumberFormat("number")
        horizontalPanel:OverrideDefaultInterval(true)
    end

    action SetXTickInterval(integer set)
        horizontalPanel:SetTickInterval(cast(number, set))
        horizontalPanel:OverrideDefaultInterval(true)
    end

    action SetYTickCount(integer ticks)
        verticalPanel:SetTickCount(ticks)
        verticalPanel:OverrideDefaultTickCount(true)
    end

    action SetYTickInterval(number set)
        verticalPanel:SetTickInterval(set)
        verticalPanel:SetNumberFormat("number")
        verticalPanel:OverrideDefaultInterval(true)
    end

    action SetYTickInterval(integer set)
        verticalPanel:SetTickInterval(cast(number, set))
        verticalPanel:OverrideDefaultInterval(true)
    end

    action GetXAxisMinimum returns number
        return horizontalPanel:GetMinimum()
    end

    action SetXAxisMinimum(number min)
        horizontalPanel:SetMinimum(min)
        horizontalPanel:OverrideDefaultMin(true)
    end

    action GetXAxisMaximum returns number
        return horizontalPanel:GetMaximum()
    end

    action SetXAxisMaximum(number max)
        horizontalPanel:SetMaximum(max)
        horizontalPanel:OverrideDefaultMax(true)
    end

    action GetYAxisMinimum returns number
        return verticalPanel:GetMinimum()
    end

    action SetYAxisMinimum(number min)
        verticalPanel:SetMinimum(min)
        verticalPanel:OverrideDefaultMin(true)
    end

    action GetYAxisMaximum returns number
        return verticalPanel:GetMaximum()
    end

    action SetYAxisMaximum(number max)
        verticalPanel:SetMaximum(max)
        verticalPanel:OverrideDefaultMax(true)
    end

    action SetXAxisNumberFormat(text format)
        text newFormat = format:ToLowerCase()
        if newFormat = "integer" or newFormat = "number"
            horizontalPanel:SetNumberFormat(format)
        end
    end

    action SetYAxisNumberFormat(text format)
        text newFormat = format:ToLowerCase()
        if newFormat = "integer" or newFormat = "number"
            verticalPanel:SetNumberFormat(format)
        end
    end

    action SetYAxisUsePercent(boolean bool)
        verticalPanel:UsePercent(bool)
    end

    action GetYAxisUsePercent returns boolean
        return verticalPanel:UsePercent()
    end

    action SetXAxisUsePercent(boolean bool)
        horizontalPanel:UsePercent(bool)
    end

    action GetXAxisUsePercent returns boolean
        return horizontalPanel:UsePercent()
    end

    /*
        These actions are used to offset the start of the tick placement
        if the chart has added white space on either side of the chart area.
    */
    action GetPaddedChartOffset returns integer
        return paddedChartOffset
    end

    action SetPaddedChartOffset(integer offset)
        paddedChartOffset = offset
    end

    action SetYAxisPaddedOffsetPercent(number percent)
        if percent >= 0  and percent <= 1
            verticalPanel:SetPaddingOffset(percent)
        else
            alert("Percent can be between 0 and 1")
        end
    end

    action SetXAxisPaddedOffsetPercent(number percent)
        if percent >= 0  and percent <= 1
            horizontalPanel:SetPaddingOffset(percent)
        else
            alert("Percent can be between 0 and 1")
        end
    end

    /*
    These actions are used to get and set the orientation. The default will
    be set on creation of each chart but can be changed afterwards manually
    or the user can call FlipOrientation().

    Attribute: Orientation controls
    */
    private action OrientationCapable(boolean orientationCapable)
        me:orientationCapable = orientationCapable
    end

    private action SetDefaultOrientationToHorizontal
        verticalOrientation = false
        horizontalOrientation = true
    end

    private action SetDefaultOrientationToVertical
        verticalOrientation = true
        horizontalOrientation = false
    end

    action SetOrientationToHorizontal
        if orientationCapable
            if not orientationChanged and not horizontalOrientation
                orientationChanged = true
                horizontalOrientation = true
                verticalOrientation = false
            end
        end
    end

    action SetOrientationToVertical
        if orientationCapable
            if not orientationChanged and not verticalOrientation
                orientationChanged = true
                horizontalOrientation = false
                verticalOrientation = true
            end
        end
    end

    /*
        If not already changed, this action will flip the axes at the current state.
        For example:
            chart:SetXAxisTitle("My X title")
            chart:SetYAxisTitle("My Y title")
            chart:FlipOrientation() // Flipping after setting titles
        Would result in the y-axis having the title "My X title" and the x-axis having the title "My Y title"

        Alternatively:
            chart:FlipOrientation() // Flipping before setting titles
            chart:SetXAxisTitle("My X title")
            chart:SetYAxisTitle("My Y title")
        Would result in the y-axis having the title "My Y title" and the x-axis having the title "My X title"
    */
    action FlipOrientation()
        if orientationCapable
            if not orientationChanged
                orientationChanged = true
                if verticalOrientation
                    verticalOrientation = false
                    horizontalOrientation = true
                else
                    verticalOrientation = true
                    horizontalOrientation = false
                end
                FlipAxisInfo()
            end
        end
    end

    action OrientationChanged returns boolean
        return orientationChanged
    end

    action GetHorizontalFlag returns boolean
        return horizontalOrientation
    end

    action GetVerticalFlag returns boolean
        return verticalOrientation
    end

    /*
        SeparateByFactor will attempt to create faceted sub chart area panels. 
        Each factor/group (independent variable) will get it's own panel.
        Each sub area will contain all elements associated with that factor.
    */
    action SeparateByFactor(boolean flag)
        defaultSeparateByFactor = flag
    end

    action SeparateByFactor()
        SeparateByFactor(1)
    end

    action SeparateByFactor(integer requestedColumns)
        if separationCapable and requestedColumns > 0
            integer numberOfFacets = GetFactorList():GetSize()
            boolean singleRow = false
            if numberOfFacets > 1
                if requestedColumns > 1
                    if requestedColumns > numberOfFacets
                        horizontalPanel:SplitIntoSections(numberOfFacets)
                        singleRow = true
                    else
                        horizontalPanel:SplitIntoSections(requestedColumns)
                    end
                end
                if not singleRow
                    verticalPanel:SplitIntoSections(cast(integer, math:Ceiling(cast(number, numberOfFacets)/requestedColumns)))
                end
            end
            numberOfChartAreas = verticalPanel:GetNumberOfSections()*horizontalPanel:GetNumberOfSections()
            if numberOfChartAreas > 1
                separateByFactor = true
            end
            overrideDefaultSeparation = true
        end
    end

    action IsSeparatedByFactor returns boolean
        return separateByFactor
    end

    /*
        SeparateBySeries will attempt to create faceted sub chart area panels 
        Each series entry in the legend will get it's own chart area.
        Each sub area will contain all elements associated with that series
    */
    action SeparateBySeries(boolean flag)
        defaultSeparateBySeries = flag
    end

    action SeparateBySeries()
        SeparateBySeries(1)
    end

    action SeparateBySeries(integer requestedColumns)
        if separationCapable and requestedColumns > 0
            integer numberOfFacets = GetSeriesList():GetSize()
            boolean singleRow = false
            if numberOfFacets > 1
                if requestedColumns > 1
                    if requestedColumns > numberOfFacets
                        horizontalPanel:SplitIntoSections(numberOfFacets)
                        singleRow = true
                    else
                        horizontalPanel:SplitIntoSections(requestedColumns)
                    end
                end
                if not singleRow
                    verticalPanel:SplitIntoSections(cast(integer, math:Ceiling(cast(number, numberOfFacets)/requestedColumns)))
                end
            end
            numberOfChartAreas = verticalPanel:GetNumberOfSections()*horizontalPanel:GetNumberOfSections()
            if numberOfChartAreas > 1
                separateBySeries = true
            end
            overrideDefaultSeparation = true
        end
    end

    action IsSeparatedBySeries returns boolean
        return separateBySeries
    end

    action IsSeparated returns boolean
        return (separateBySeries or separateByFactor)
    end

    private action SeparateSeriesByDefault(boolean flag)
        defaultSeparateBySeries = flag
    end

    private action SeparateFactorByDefault(boolean flag)
        defaultSeparateByFactor = flag
    end

    private action SeparationCapable(boolean separationCapable)
        me:separationCapable = separationCapable
    end

    private action XAxisIsIndependent returns boolean
        return xAxisIsIndependent
    end
    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action OverrideXLabelsWithText(Array<text> labels)
        horizontalPanel:SetTextLabels(labels)
    end

    action OverrideYLabelsWithText(Array<text> labels)
        verticalPanel:SetTextLabels(labels)
    end

    action GetYLabels returns Array<ControlLabel>
        return verticalPanel:GetLabels()
    end

    action SetYLabels(Array<ControlLabel> newLabels)
        verticalPanel:SetLabels(newLabels)
    end

    action GetXLabels returns Array<ControlLabel>
        return horizontalPanel:GetLabels()
    end

    action SetXLabels(Array<ControlLabel> newLabels)
        horizontalPanel:SetLabels(newLabels)
    end

    action RotateXLabels(integer degrees) // "360 -" because it rotates opposite of how you'd imagine.
        xLabelsRotation = 360 - degrees
        SetRotationOverride(true)
    end

    action GetXLabelsRotation() returns integer
        return xLabelsRotation
    end

    action GetRotationOverride() returns boolean
        return overrideXLabelsRotation
    end

    action SetRotationOverride(boolean flag)
        overrideXLabelsRotation = flag
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */

    /* 
        Label for the chart title
    */
    action GetTitleLabel returns ControlLabel
        return title
    end

    private action SetTitleLabel(ControlLabel label)
        me:title = label
    end

    /*
        Sets the title of the chart
    */
    action SetTitle(text name)
        titleText = name
    end
    /*
        Attribute: Returns the title of the chart
    */
    action GetTitle returns text
        return titleText
    end
    /*
        When true the chart title will be visible
    */
    action ShowTitle(boolean show)
        showTitle = show
    end
    /*
        Attribute: Returns true if the chart title is showing
    */
    action IsShowingTitle() returns boolean
        return showTitle
    end
    /*
        Attribute: Returns percent of screen height alloted for the title
        This is handled automatically so users don't need to use this
        action directly.
    */
    action GetTitleAreaHeightPercent returns number
        return titleAreaHeightPercent
    end
    
    /* 
        Label for the chart subtitle
    */
    action GetSubtitleLabel returns ControlLabel
        return subtitle
    end

    private action SetSubtitleLabel(ControlLabel label)
        me:subtitle = label
    end

    /*
        Sets the title of the chart
    */
    action SetSubtitle(text name)
        subtitleText = name
        if name not= ""
            showSubtitle = true
        end
    end
    /*
        Attribute: Returns the title of the chart
    */
    action GetSubtitle returns text
        return subtitleText
    end
    /*
        When true the chart title will be visible
    */
    action ShowSubtitle(boolean show)
        showSubtitle = show
    end
    /*
        Attribute: Returns true if the chart title is showing
    */
    action IsShowingSubtitle() returns boolean
        return showSubtitle
    end
    /*
        Attribute: Returns percent of screen height alloted for the title
        This is handled automatically so users don't need to use this
        action directly.
    */
    action GetSubtitleAreaHeightPercent returns number
        return subtitleAreaHeightPercent
    end

    /*
        Set the title for the X-Axis of the Chart.
    */
    action SetXAxisTitle(text name)
        horizontalPanel:SetTitleText(name)
    end

    /*
        Returns the title for the X-Axis of the Chart.
    */
    action GetXAxisTitle returns text
        return horizontalPanel:GetTitleText()
    end

    /*
        Set the title for the Y-Axis of the Chart
    */
    action SetYAxisTitle(text name)
        verticalPanel:SetTitleText(name)
    end

    /*
        Returns the title for the Y-Axis of the Chart.
    */
    action GetYAxisTitle returns text
        return verticalPanel:GetTitleText()
    end

    /*
        These action states to turn on the axes. 
        Attribute: True if the axes should be shown.
    */
    action ShowXAxis(boolean show)
        showXAxis = show
    end

    action IsShowingXAxis() returns boolean
        return showXAxis
    end

    action ShowYAxis(boolean show)
        showYAxis = show
    end

    action IsShowingYAxis() returns boolean
        return showYAxis
    end

    action IsShowingLinearRegression returns boolean
        return showLinearRegression
    end

    action ShowLinearRegression(boolean show)
        if regressionCapable
            showLinearRegression = show
            GetLegend():ShowRegression(show)
        else
            showLinearRegression = false
            output "This type of chart cannot support linear regression lines."
        end
    end

    private action RegressionCapable(boolean regressionCapable)
        me:regressionCapable = regressionCapable
    end

    private action LoadRegressionLines()
        integer i = 0
        repeat while i < GetSeriesList():GetSize()
            RegressionLine line = GetSeriesList():Get(i):GetRegressionLine()
            if line not= undefined
                line:SetColor(GetSeriesList():Get(i):GetColor())
                if IsSeparatedBySeries()
                    integer k = 0
                    repeat while k < GetNumberOfChartAreas()
                        if GetSeriesList():Get(i):GetName() = GetSubChartAreas():Get(k):GetName()
                            GetSubChartAreas():Get(k):Add(line)
                            GetSubChartAreas():Get(k):AddChartAreaItem(line)
                        end
                        k = k + 1
                    end
                    if regLineDensity > 0
                        line:SetLineDensity(regLineDensity)
                    else
                        if GetSubChartAreas():GetSize() > 0
                            regLineDensity = cast(integer, GetSubChartAreas():Get(0):GetWidth() * 0.0025)
                            if regLineDensity < 2
                                regLineDensity = 2
                            end
                            line:SetLineDensity(regLineDensity)
                        end
                    end
                else
                    GetChartArea():Add(line)
                    if regLineDensity > 0
                        line:SetLineDensity(regLineDensity)
                    else
                        regLineDensity = cast(integer, GetChartArea():GetWidth() * 0.0025)
                        if regLineDensity < 2
                            regLineDensity = 2
                        end
                        line:SetLineDensity(regLineDensity)
                    end
                end
            end
            i = i + 1
        end
    end

    /*
        Set and get the line density.
    */
    action SetRegressionLineDensity(integer density)
        regLineDensity = density
    end

    action GetRegressionLineDensity() returns integer
        return regLineDensity
    end

    action ShowGroupBrackets(boolean flag)
        verticalPanel:ShowGroupBrackets(flag)
        horizontalPanel:ShowGroupBrackets(flag)
        overrideDefaultShowBrackets = true
    end

    private action SetDefaultShowBrackets(boolean flag)
        defaultShowBrackets = flag
    end

    private action HasGroups(boolean hasGroups)
        me:hasGroups = hasGroups
    end

    action HasGroups returns boolean
        return hasGroups
    end

    /*
        GRIDLINE CONTROLS
        These actions are used to customize which gridlines are visible
        Major gridlines are drawn to match the number and location of axis ticks.
        Minor gridlines default to 5 intervals between major gridlines.
        The minor gridline interval count can be manually changed.
        No option to customize density or color at this time.

        Attribute: True if the gridlines should be shown.
    */
    action SetMinorYGridlineCount(integer count)
        verticalPanel:SetMinorGridlineCount(count)
    end

    action SetMinorXGridlineCount(integer count)
        horizontalPanel:SetMinorGridlineCount(count)
    end

    action ShowAllGridLines()
        showMajorYGridLines = true
        showMajorXGridLines = true
        showMinorYGridLines = true
        showMinorXGridLines = true
    end
    action HideAllGridLines()
        showMajorYGridLines = false
        showMajorXGridLines = false
        showMinorYGridLines = false
        showMinorXGridLines = false
    end

    action ShowAllXGridLines()
        showMajorXGridLines = true
        showMinorXGridLines = true
    end
    action HideAllXGridLines()
        showMajorXGridLines = false
        showMinorXGridLines = false
    end

    action ShowAllYGridLines()
        showMajorYGridLines = true
        showMinorYGridLines = true
    end
    action HideAllYGridLines()
        showMajorYGridLines = false
        showMinorYGridLines = false
    end

    action ShowMajorGridLines()
        showMajorYGridLines = true
        showMajorXGridLines = true
    end
    action HideMajorGridLines()
        showMajorYGridLines = false
        showMajorXGridLines = false
    end

    action ShowMinorGridLines()
        showMinorYGridLines = true
        showMinorXGridLines = true
    end
    action HideMinorGridLines()
        showMinorYGridLines = false
        showMinorXGridLines = false
    end

    action ShowMinorYGridLines()
        showMinorYGridLines = true
    end
    action HideMinorYGridLines()
        showMinorYGridLines = false
    end

    action ShowMinorXGridLines()
        showMinorXGridLines = true
    end
    action HideMinorXGridLines()
        showMinorXGridLines = false
    end

    action ShowMajorYGridLines()
        showMajorYGridLines = true
    end
    action HideMajorYGridLines()
        showMajorYGridLines = false
    end

    action ShowMajorXGridLines()
        showMajorXGridLines = true
    end
    action HideMajorXGridLines()
        showMajorXGridLines = false
    end

    action IsShowingMajorXGridLines returns boolean
        return showMajorXGridLines
    end

    action IsShowingMajorYGridLines returns boolean
        return showMajorYGridLines
    end

    action IsShowingMinorXGridLines returns boolean
        return showMinorXGridLines
    end

    action IsShowingMinorYGridLines returns boolean
        return showMinorYGridLines
    end

    /*
        This action sets the Legend object
        Attribute: Parameter legend the legend to set
    */
    action SetLegend(Legend legend)
        me:legend = legend
    end
    /*
        This action returns the current legend, if one exists
        Attribute: Returns true if the legend is shown.
    */
    action GetLegend returns Legend
        return legend
    end
    /*
        This action states to turn on the legend. 
        Attribute: Parameter true if the legend should be shown.
    */
    action ShowLegend(boolean show)
        showLegend = show
    end
    /*
        This action states to turn on the legend. 
        Attribute: Returns true if the legend is shown.
    */
    action IsShowingLegend returns boolean
        return showLegend
    end

    /*
        Set the title for the legend of the Chart
    */
    action SetLegendTitle(text name)
        legend:SetTitleText(name)
    end

    /*
        Returns the title for the legend of the Chart.
    */
    action GetLegendTitle returns text
        return legend:GetTitleText()
    end

    /*
        Returns the title for the legend of the Chart.
    */
    action SetLegendLocation(text location)
        if IsShowingLegend()
            text newlocation = location:ToLowerCase()
            legend:SetLocation(newlocation)
        end
    end

    /*
        Returns an array of all the series sets 
    */
    action GetSeriesList returns Array<Series>
        return legend:GetSeriesList()
    end

    /*
        Returns an array of all the factor/group labels 
    */
    action GetFactorList returns Array<text>
        Array<text> list
        if xAxisIsIndependent
            if horizontalPanel:GetTextLabels() not= undefined
                list = horizontalPanel:GetTextLabels()
            end
        else
            if verticalPanel:GetTextLabels() not= undefined
                list = verticalPanel:GetTextLabels()
            end
        end
        return list
    end

    action AddSeries(Series series)
        legend:GetSeriesList():Add(series)
    end

    action SetSeriesList(Array <Series> series)
        legend:SetSeriesList(series)
    end

    action SetColorPaletteToCalm()
        options:SetPalette(options:CALM)
    end 

    action SetColorPaletteToExciting()
        options:SetPalette(options:EXCITING)
    end 

    action SetColorPaletteToPositive()
        options:SetPalette(options:POSITIVE)
    end 

    action SetColorPaletteToNegative()
        options:SetPalette(options:NEGATIVE)
    end 

    action SetColorPaletteToSerious()
        options:SetPalette(options:SERIOUS)
    end 

    action SetColorPaletteToPlayful()
        options:SetPalette(options:PLAYFUL)
    end 

    action SetColorPaletteToTrustworthy()
        options:SetPalette(options:TRUSTWORTHY)
    end 

    action SetColorPaletteToDisturbing()
        options:SetPalette(options:DISTURBING)
    end 

    action SetColorPaletteToColorgorical()
        options:SetPalette(options:COLORGORICAL)
    end 

    /*
        Created by Stefan van der Walt (https://github.com/stefanv) and Nathaniel Smith (https://github.com/njsmith)
        https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html
    */
    action SetColorPaletteToCoolScale() //Viridis
        Color colorA
        colorA:SetColor(252.0/255, 230.0/255, 30.0/255 ,1)
        Color colorB
        colorB:SetColor(31.0/255, 127.0/255, 122.0/255, 1)
        Color colorC
        colorC:SetColor(52.0/255, 0/255, 67.0/255, 1)
        options:SetPalette(colorA, colorB, colorC, legend:GetSeriesList():GetSize())
    end 

    action SetColorPaletteToWarmScale() //Inferno
        Color colorA
        colorA:SetColor(253.0/255, 255/255, 147.0/255, 1)
        Color colorB
        colorB:SetColor(168.0/255, 33.0/255, 68.0/255, 1)
        Color colorC
        colorC:SetColor(0/255, 0/255, 4.0/255 ,1)
        options:SetPalette(colorA, colorB, colorC, legend:GetSeriesList():GetSize())
    end 

    action SetColorPaletteToMagma() //Think of a name for this?
        Color colorA
        colorA:SetColor(252.0/255, 251.0/255, 173.0/255, 1)
        Color colorB
        colorB:SetColor(164.0/255, 31.0/255, 103.0/255, 1)
        Color colorC
        colorC:SetColor(0/255, 0/255, 4.0/255 ,1)
        options:SetPalette(colorA, colorB, colorC, legend:GetSeriesList():GetSize())
    end 

    action SetColorPalette(Array <Color> palette)
        options:SetPalette(palette)
    end

    action SetColorPalette(Color color)
        Color darkColor
        darkColor:SetColor(0,0,0,1)
        darkColor:LinearInterpolation(color, 0.15) // Not quite black
        Color lightColor
        lightColor:SetColor(1,1,1,1)
        lightColor:LinearInterpolation(color, 0.15) // Not quite white
        options:SetPalette(darkColor, color, lightColor, legend:GetSeriesList():GetSize())
    end

    action SetColorPalette(Color colorA, Color colorB)
        options:SetPalette(colorA, colorB, legend:GetSeriesList():GetSize())
    end

    action SetColorPalette(Color colorA, Color colorB, Color colorC)
        options:SetPalette(colorA, colorB, colorC, legend:GetSeriesList():GetSize())
    end

    action SetCurrentPaletteToGrayScale()
        options:SetPaletteToGrayScale()
    end

    /*
        Gets the default selection color (highlighting) the chart items
    */
    action GetHighlightColor() returns Color
        return highlightColor
    end

    /*
        Sets the default selection color (highlighting) the chart items
    */
    action SetHighlightColor(Color color)
        highlightColor = color
        options:SetSelectionColor(color)
    end

    action Resize
        if GetBackground() not= undefined
            GetBackground():SetSize(GetWidth(), GetHeight())
        end

        // Create default tick sizes. 
        // Having a min of 12 for the long side, ensures 4 for short side, 
        // which ensures 2 for the major gridlines and 1 for the minor gridline, all will be visible.
        // If minor gridlines aren't showing, then the min can go to 6.
        integer xTickHeight = cast(integer, GetHeight()*0.01)
        if me:IsShowingMinorXGridLines()
            if xTickHeight < 12
                xTickHeight = 12
            end
        else
            if xTickHeight < 6
                xTickHeight = 6
            end
        end
        horizontalPanel:SetTickWidth(cast(integer, xTickHeight/3))  
        horizontalPanel:SetTickHeight(xTickHeight)

        integer yTickWidth = cast(integer, GetWidth()*0.01)
        if me:IsShowingMinorYGridLines()
            if yTickWidth < 12
                yTickWidth = 12
            end
        else
            if yTickWidth < 6
                yTickWidth = 6
            end
        end
        verticalPanel:SetTickWidth(yTickWidth)  
        verticalPanel:SetTickHeight(cast(integer, yTickWidth/3))
 
        // If the title font size is manually set then we can try to accomodate the title area percent
        // This has to be done before the axis panels because they use titleAreaHeightPercent in their calculations.
        if IsShowingTitle()
            if GetTitleLabel() not= undefined
                if titleFontSizeOverride
                    integer fontsize = titlefontsize
                    if fontsize = 0
                        fontsize = cast(integer, GetFontSize())
                    end
                    GetTitleLabel():SetFontSize(fontsize)
                    number newTitleAreaHeightPercent = GetTitleLabel():GetHeight()/GetHeight()
                    if newTitleAreaHeightPercent > titleAreaHeightPercent
                        titleAreaHeightPercent = newTitleAreaHeightPercent
                    end
                end
            end
        end

        // If the sub title font size is manually set then we can try to accomodate the title area percent
        // This has to be done before the axis panels because they use subtitleAreaHeightPercent in their calculations.
        if IsShowingSubtitle()
            if GetSubtitleLabel() not= undefined
                if subtitleFontSizeOverride
                    integer fontsize = subtitlefontsize
                    if fontsize = 0
                        fontsize = cast(integer, GetFontSize()*0.75)
                    end
                    GetSubtitleLabel():SetFontSize(fontsize)
                    number newTitleAreaHeightPercent = GetSubtitleLabel():GetHeight()/GetHeight()
                    if newTitleAreaHeightPercent > subtitleAreaHeightPercent
                        subtitleAreaHeightPercent = newTitleAreaHeightPercent
                    end
                end
            end
        end

        //This is where all the font sizes and axis padding will be set
        AdjustForXAxis()
        AdjustForYAxis()
        AdjustForLegend()

        // If any default font sizing ended up being too large; try to adjust.
        // If the title font size is default the title area percent will be 10% of the height
        if IsShowingTitle() and GetTitleLabel() not= undefined
            if not titleFontSizeOverride
                integer fontsize = cast(integer, GetHeight()*(titleAreaHeightPercent/2))
                GetTitleLabel():SetFontSize(fontsize)
                if GetTitleLabel():GetWidth() > GetWidth()*horizontalPanelWidthPercent // default size is too long
                    fontsize = cast(integer, GetTitleLabel():GetFontSize()*((GetWidth()*horizontalPanelWidthPercent)/GetTitleLabel():GetWidth()))
                    GetTitleLabel():SetFontSize(fontsize)
                end
            end
        end

        // If any default font sizing ended up being too large; try to adjust.
        // If the title font size is default the title area percent will be 10% of the height
        if IsShowingSubtitle() and GetSubtitleLabel() not= undefined
            if not subtitleFontSizeOverride
                integer fontsize = cast(integer, GetHeight()*(subtitleAreaHeightPercent/2))
                GetSubtitleLabel():SetFontSize(fontsize)
                if GetSubtitleLabel():GetWidth() > GetWidth()*horizontalPanelWidthPercent // default size is too long
                    fontsize = cast(integer, GetSubtitleLabel():GetFontSize()*((GetWidth()*horizontalPanelWidthPercent)/GetSubtitleLabel():GetWidth()))
                    GetSubtitleLabel():SetFontSize(fontsize)
                end
            end
        end

        // If the x axis title font size is default but it ended up too large for the x-axis panel
        if IsShowingXAxis() and horizontalPanel:GetTitleLabel() not= undefined
            if not xTitleFontSizeOverride
                if horizontalPanel:GetTitleLabel():GetWidth() > GetWidth()*horizontalPanelWidthPercent // default size is too long
                    integer fontsize = horizontalPanel:GetTitleLabel():GetFontSize()
                    fontsize = cast(integer, fontsize*((GetWidth()*horizontalPanelWidthPercent)/horizontalPanel:GetTitleLabel():GetWidth()))
                    horizontalPanel:GetTitleLabel():SetFontSize(fontsize)
                end
            end
        end

        // If the y axis title font size is default but it ended up too large for the y-axis panel
        if IsShowingYAxis() and verticalPanel:GetTitleLabel() not= undefined
            if not yTitleFontSizeOverride
                if verticalPanel:GetTitleLabel():GetWidth() > GetHeight()*verticalPanelHeightPercent // default size is too long
                    integer fontsize = verticalPanel:GetTitleLabel():GetFontSize()
                    fontsize = cast(integer, fontsize*((GetHeight()*verticalPanelHeightPercent)/verticalPanel:GetTitleLabel():GetWidth()))
                    verticalPanel:GetTitleLabel():SetFontSize(fontsize)
                end
            end
        end

        chartArea:SetSize(GetWidth()*horizontalPanelWidthPercent, GetHeight()*verticalPanelHeightPercent)
        parent:Control:Resize()
    end

    action AdjustForXAxis()
        if IsShowingXAxis()
            horizontalPanel:SetSize(GetWidth()*horizontalPanelWidthPercent, GetHeight()*horizontalPanelHeightPercent)

            integer minimumSpace = 0
            integer tickWidth = horizontalPanel:GetTickWidth()
            integer tickHeight = horizontalPanel:GetTickHeight()

            integer titleautofontsize = cast(integer, ((GetHeight()+GetWidth())/2)*(0.05/2))

            if horizontalPanel:GetTitleLabel() not= undefined
                if not xTitleFontSizeOverride // This is the auto-sized X-Axis Label
                    if allFontSizeOverride
                        titleautofontsize = cast(integer, GetFontSize()*horizontalPanelWidthPercent)
                    end
                    horizontalPanel:GetTitleLabel():SetFontSize(titleautofontsize)
                else
                    integer fontsize = horizontalPanel:GetTitleFontSize()
                    if fontsize = 0
                        fontsize = cast(integer, GetFontSize()*horizontalPanelWidthPercent)
                    end
                    horizontalPanel:GetTitleLabel():SetFontSize(fontsize)
                end

                number tickSpace = 3*tickHeight
                if horizontalPanel:ShowGroupBrackets()
                    tickSpace = 4*tickHeight + tickWidth
                end
                minimumSpace = minimumSpace + cast(integer, horizontalPanel:GetTitleLabel():GetHeight() + tickSpace)
            end

            if horizontalPanel:GetLabelCount() > 0
                integer labelautofontsize = cast(integer, (GetWidth()*horizontalPanelWidthPercent)/horizontalPanel:GetLabelCount())
                if labelautofontsize > cast(integer, titleautofontsize*0.75)
                    labelautofontsize = cast(integer, titleautofontsize*0.75)
                end

                if not xLabelFontSizeOverride
                    if allFontSizeOverride
                        labelautofontsize = cast(integer, GetFontSize()*horizontalPanelWidthPercent*0.75)
                    end
                    horizontalPanel:SetLabelFontSize(labelautofontsize)
                else
                    integer fontsize = horizontalPanel:GetLabelFontSize()
                    if fontsize = 0
                        fontsize = cast(integer, GetFontSize()*horizontalPanelWidthPercent*0.75)
                    end
                    horizontalPanel:SetLabelFontSize(fontsize)
                end
                number widthBefore = horizontalPanel:GetLongestLabel():GetWidth()
                horizontalPanel:GetLongestLabel():SetFontSize(horizontalPanel:GetLabelFontSize())
                number widthAfter = horizontalPanel:GetLongestLabel():GetWidth()
                number percentIncrease = (widthAfter/widthBefore)
                horizontalPanel:SetSumOfLabelWidths(horizontalPanel:GetSumOfLabelWidths()*percentIncrease)

                if xLabelsRotation not= 0
                    minimumSpace = minimumSpace + cast(integer, horizontalPanel:GetLongestLabel():GetWidth() + 1.5*tickWidth)
                else
                    if (horizontalPanel:GetSumOfLabelWidths() + horizontalPanel:GetLabelCount()*5) > horizontalPanel:GetWidth()
                        minimumSpace = minimumSpace + cast(integer, horizontalPanel:GetLongestLabel():GetWidth() + 1.5*tickWidth)
                        xLabelsRotation = 270
                    else
                        minimumSpace = minimumSpace + cast(integer, horizontalPanel:GetLongestLabel():GetHeight() + 1.5*tickWidth)
                    end
                end
            end
            horizontalPanelHeightPercent = minimumSpace / GetHeight()
        else
            horizontalPanelHeightPercent = 0.05
        end
        horizontalPanel:SetSize(GetWidth()*horizontalPanelWidthPercent, GetHeight()*horizontalPanelHeightPercent)
        verticalPanelHeightPercent = 1-horizontalPanelHeightPercent-(titleAreaHeightPercent+subtitleAreaHeightPercent)
        legendPanelHeightPercent = verticalPanelHeightPercent
    end

    action AdjustForYAxis()
        if IsShowingYAxis()
            verticalPanel:SetSize(GetWidth()*verticalPanelWidthPercent, GetHeight()*verticalPanelHeightPercent)

            integer minimumSpace = 0
            integer tickWidth = verticalPanel:GetTickWidth()
            integer tickHeight = verticalPanel:GetTickHeight()

            integer titleautofontsize = cast(integer, ((GetHeight()+GetWidth())/2)*(0.05/2))

            if verticalPanel:GetTitleLabel() not= undefined
                if not yTitleFontSizeOverride // This is the auto-sized Y-Axis Label
                    if allFontSizeOverride
                        titleautofontsize = cast(integer, GetFontSize()*verticalPanelHeightPercent)
                    end
                    verticalPanel:GetTitleLabel():SetFontSize(titleautofontsize)
                else
                    integer fontsize = verticalPanel:GetTitleFontSize()
                    if fontsize = 0
                        fontsize = cast(integer, GetFontSize()*verticalPanelHeightPercent)
                    end
                    verticalPanel:GetTitleLabel():SetFontSize(fontsize)
                end

                number tickSpace = 3*tickWidth
                if verticalPanel:ShowGroupBrackets()
                    tickSpace = 4*tickWidth + tickHeight
                end
                minimumSpace = minimumSpace + cast(integer, verticalPanel:GetTitleLabel():GetHeight() + tickSpace)
            end

            if verticalPanel:GetLabelCount() > 0
                integer labelautofontsize = cast(integer, (GetHeight()*(1-horizontalPanelHeightPercent-(titleAreaHeightPercent+subtitleAreaHeightPercent)))/verticalPanel:GetLabelCount())
                if labelautofontsize > cast(integer, titleautofontsize*0.75)
                    labelautofontsize = cast(integer, titleautofontsize*0.75)
                end

                if not yLabelFontSizeOverride
                    if allFontSizeOverride
                        labelautofontsize = cast(integer, GetFontSize()*verticalPanelHeightPercent*0.75)
                    end
                    verticalPanel:SetLabelFontSize(labelautofontsize)
                else
                    integer fontsize = verticalPanel:GetLabelFontSize()
                    if fontsize = 0
                        fontsize = cast(integer, GetFontSize()*verticalPanelHeightPercent)
                    end
                    verticalPanel:SetLabelFontSize(fontsize)
                end
                verticalPanel:GetLongestLabel():SetFontSize(verticalPanel:GetLabelFontSize())
                verticalPanel:SetSumOfLabelHeights((verticalPanel:GetLongestLabel():GetHeight()*verticalPanel:GetLabelCount()))

                minimumSpace = minimumSpace + cast(integer, verticalPanel:GetLongestLabel():GetWidth() + 1.5*tickWidth)
            end

            verticalPanelWidthPercent = minimumSpace / GetWidth()
        else
            verticalPanelWidthPercent = 0.05
        end
        verticalPanel:SetSize(GetWidth()*verticalPanelWidthPercent, GetHeight()*verticalPanelHeightPercent)
    end

    action AdjustForLegend()
        if IsShowingLegend()
            legend:SetSize(GetWidth()*legendPanelWidthPercent, GetHeight()*legendPanelHeightPercent)
            integer minimumSpace = 0
            integer minimumWidthSpace = 0
            integer minimumHeightSpace = 0
            number labelHeight = 0
            number labelWidth = 0

            if legend:DisplayOnLeft() or legend:DisplayOnRight()
                integer titleautofontsize = cast(integer, ((GetHeight()+GetWidth())/2)*(0.05/2))
                if legend:GetTitleLabel() not= undefined
                    if not legendTitleFontSizeOverride // This is the auto-sized legend title
                        if allFontSizeOverride
                            titleautofontsize = cast(integer, GetFontSize()*verticalPanelHeightPercent)
                        end
                        legend:SetTitleFontSize(titleautofontsize)
                    else
                        integer fontsize = legend:GetTitleFontSize()
                        if fontsize <= 0
                            fontsize = cast(integer, GetFontSize()*verticalPanelHeightPercent)
                        end
                        legend:SetTitleFontSize(fontsize)
                    end
                end
    
                number newWidthSum = 0.0
                number newHeightSum = 0.0
                if not legend:GetSeriesList():IsEmpty()
                    integer labelautofontsize = cast(integer, GetWidth()*0.025)
                    if labelautofontsize > cast(integer, titleautofontsize*0.75)
                        labelautofontsize = cast(integer, titleautofontsize*0.75)
                    end
                    if not legendLabelFontSizeOverride
                        if allFontSizeOverride
                            labelautofontsize = cast(integer, GetFontSize()*verticalPanelHeightPercent*0.75) //75% of legend title
                        end
                        legend:SetLabelFontSize(labelautofontsize)
                    else
                        integer fontsize = legend:GetLabelFontSize()
                        if fontsize <= 0
                            fontsize = cast(integer, GetFontSize()*verticalPanelHeightPercent*0.75)
                        end
                        legend:SetLabelFontSize(fontsize)
                    end
                    legend:CalculateMinimumSpace()
                    minimumWidthSpace = cast(integer, legend:GetMinimumWidth())
                    minimumHeightSpace = cast(integer, legend:GetMinimumHeight())

                    // Check and adjust default font size again if the minimum height exceeds the allowed space.
                    if not legendLabelFontSizeOverride and minimumHeightSpace > verticalPanelHeightPercent*GetHeight()
                        labelautofontsize = cast(integer, labelautofontsize*(verticalPanelHeightPercent*GetHeight()/minimumHeightSpace))
                        legend:SetLabelFontSize(labelautofontsize)
                        if not legendTitleFontSizeOverride
                            legend:SetTitleFontSize(cast(integer, labelautofontsize*1.25))
                        end
                        legend:CalculateMinimumSpace()
                        minimumWidthSpace = cast(integer, legend:GetMinimumWidth())
                        minimumHeightSpace = cast(integer, legend:GetMinimumHeight())
                    end
                end
    
                legendPanelWidthPercent = minimumWidthSpace / GetWidth()
                number remainingChartArea = math:Round(1 - legendPanelWidthPercent - verticalPanelWidthPercent - 0.025, 2) // 0.025 for margin padding
                SetChartAreaWidthPercent(remainingChartArea)
                horizontalPanel:SetWidth(remainingChartArea*GetWidth())

            else //legend:DisplayOnTop() or legend:DisplayOnBottom()
                integer titleautofontsize = cast(integer, ((GetHeight()+GetWidth())/2)*(0.05/2))
                if legend:GetTitleLabel() not= undefined
                    if not legendTitleFontSizeOverride // This is the auto-sized legend title
                        if allFontSizeOverride
                            titleautofontsize = cast(integer, GetFontSize()*horizontalPanelWidthPercent)
                        end
                        legend:SetTitleFontSize(cast(integer, titleautofontsize))
                    else
                        integer fontsize = legend:GetTitleFontSize()
                        if fontsize <= 0
                            fontsize = cast(integer, GetFontSize()*horizontalPanelWidthPercent)
                        end
                        legend:SetTitleFontSize(fontsize)
                    end
                end

                if not legend:GetSeriesList():IsEmpty()
                    integer labelautofontsize = cast(integer, GetHeight()*0.025)
                    if labelautofontsize > cast(integer, titleautofontsize*0.75)
                        labelautofontsize = cast(integer, titleautofontsize*0.75)
                    end

                    if not legendLabelFontSizeOverride
                        if allFontSizeOverride
                            labelautofontsize = cast(integer, GetFontSize()*horizontalPanelWidthPercent*0.75)
                        end
                        legend:SetLabelFontSize(labelautofontsize)
                    else
                        integer fontsize = legend:GetLabelFontSize()
                        if fontsize <= 0
                            fontsize = cast(integer, GetFontSize()*horizontalPanelWidthPercent*0.75)
                        end
                        legend:SetLabelFontSize(fontsize)
                    end
                    legend:CalculateMinimumSpace()
                    minimumWidthSpace = cast(integer, legend:GetMinimumWidth())
                    minimumHeightSpace = cast(integer, legend:GetMinimumHeight())

                    // Check and adjust default font size again if the minimum width exceeds the allowed space.
                    if not legendLabelFontSizeOverride and minimumWidthSpace > horizontalPanelWidthPercent*GetWidth()
                        labelautofontsize = cast(integer, labelautofontsize*(horizontalPanelWidthPercent*GetWidth()/minimumWidthSpace))
                        legend:SetLabelFontSize(labelautofontsize)
                        if not legendTitleFontSizeOverride
                            legend:SetTitleFontSize(cast(integer, labelautofontsize*1.25))
                        end
                        legend:CalculateMinimumSpace()
                        minimumWidthSpace = cast(integer, legend:GetMinimumWidth())
                        minimumHeightSpace = cast(integer, legend:GetMinimumHeight())
                    end
                end
    
                legendPanelHeightPercent = minimumHeightSpace / GetHeight()
                number remainingChartAreaHeight = math:Round(1 - legendPanelHeightPercent - horizontalPanelHeightPercent - (titleAreaHeightPercent+subtitleAreaHeightPercent), 2) // 0.10 for title padding
                SetChartAreaHeightPercent(remainingChartAreaHeight)
                verticalPanel:SetHeight(remainingChartAreaHeight*GetHeight())

                number remainingChartAreaWidth = math:Round(1 - verticalPanelWidthPercent - 0.05, 2) // 0.05 for margin padding
                SetChartAreaWidthPercent(remainingChartAreaWidth)
                horizontalPanel:SetWidth(remainingChartAreaWidth*GetWidth())
                legendPanelWidthPercent = horizontalPanelWidthPercent
            end
        else
            legendPanelWidthPercent = 0.05
            number remainingChartArea = math:Round(1 - legendPanelWidthPercent - verticalPanelWidthPercent, 2)
            SetChartAreaWidthPercent(remainingChartArea)
            horizontalPanel:SetWidth(remainingChartArea*GetWidth())
        end    
        legend:SetSize(GetWidth()*legendPanelWidthPercent, GetHeight()*legendPanelHeightPercent)    
    end

    action SetFontSize(integer size)
        allFontSizeOverride = true
        titleFontSizeOverride = true
        subtitleFontSizeOverride = true
        parent:Control:SetFontSize(size)
    end

    action SetTitleFontSize(integer size)
        titleFontSizeOverride = true
        titlefontsize = size
    end

    action SetSubtitleFontSize(integer size)
        subtitleFontSizeOverride = true
        subtitlefontsize = size
    end

    action SetXTitleFontSize(integer size)
        xTitleFontSizeOverride = true
        horizontalPanel:SetTitleFontSize(size)
    end

    action SetXLabelFontSize(integer size)
        xLabelFontSizeOverride = true
        horizontalPanel:SetLabelFontSize(size)
    end

    action SetYTitleFontSize(integer size)
        yTitleFontSizeOverride = true
        verticalPanel:SetTitleFontSize(size)
    end

    action SetYLabelFontSize(integer size)
        yLabelFontSizeOverride = true
        verticalPanel:SetLabelFontSize(size)
    end

    action SetLegendTitleFontSize(integer size)
        legendTitleFontSizeOverride = true
        legend:SetTitleFontSize(size)
    end

    action SetLegendLabelFontSize(integer size)
        legendLabelFontSizeOverride = true
        legend:SetLabelFontSize(size)
    end

    /* 
        Unlike many kinds of user interface controls, there is no universal way of interacting with a chart and, as such, this 
        may be defined by any chart to be custom. As such, charts must be able to take messages suggesting an item in the chart
        has either lost or gained the focus. Broadly speaking, this is done automatically and while charts need to implement
        this action, they do not need to call this action directly.
        This action will control the LostSelection for ChartItems shared amoung all charts.
        Any ChartItems specific to one type of chart (i.e. lines for LineCharts) will have 
        an addition LostSelection action defined in the inherited class.

        Attribute: Parameter item the ChartItem representing the structure for this particular kind of chart. 
    */
    action LostSelection(ChartItem item)
        if item = undefined
            return now
        end
        Item target = item:GetFocusTarget()
        if target not= undefined
            target:Focus()
            if target is Series
                Series temp = cast(Series, target)
                integer i = 0
                repeat while i < temp:GetSize()
                    Drawable element = temp:GetItemAt(i)
                    element:SetColor(previousColor)
                    element:SetZ(previousZ)
                    i = i + 1
                end
//                temp:GetLabel():LostSelection()
                temp:GetIcon():SetColor(previousColor)
                temp:GetEntryBox():SetColor(0,0,0,0)
            elseif target is RegressionLine
                RegressionLine temp = cast(RegressionLine, target)
                temp:SetZ(previousZ)
                temp:SetColor(previousColor)
                temp:GetLabel():LostSelection()
                temp:GetIcon():SetColor(previousColor)
            elseif target is Drawable
                Drawable temp = cast(Drawable, target)
                temp:SetZ(previousZ)
                temp:SetColor(previousColor)
            elseif target is ControlLabel
                ControlLabel temp = cast(ControlLabel, target)
                temp:LostSelection()
            elseif target is Control
                Control temp = cast(Control, target)
                LayoutProperties properties = temp:GetDefaultLayoutProperties()
                if properties not= undefined
                    LabelBoxView view
                    view:SetBorderThickness(cast(integer, properties:GetBorderThickness()))
                    view:Initialize(previousBackgroundColor, previousColorGroup)
                    temp:SetView2D(view)
                end
            end
        end
    end

    /* 
        Unlike many kinds of user interface controls, there is no universal way of interacting with a chart and, as such, this 
        may be defined by any chart to be custom. As such, charts must be able to take messages suggesting an item in the chart
        has either lost or gained the focus. Broadly speaking, this is done automatically and while charts need to implement
        this action, they do not need to call this action directly.
        This action will control the GainedSelection for ChartItems shared amoung all charts.
        Any ChartItems specific to one type of chart (i.e. lines for LineCharts) will have 
        an addition GainedSelection action defined in the inherited class.

        Attribute: Parameter item the ChartItem representing the structure for this particular kind of chart. 
    */
    action GainedSelection(ChartItem item)
        if item = undefined
            return now
        end
        Item target = item:GetFocusTarget()
        if target not= undefined
            target:Focus()
            if target is Series
                Series temp = cast(Series, target)
                previousColor = temp:GetColor()
                integer i = 0
                repeat while i < temp:GetSize()
                    Drawable element = temp:GetItemAt(i)
                    element:SetColor(GetHighlightColor())
                    element:SetZ(-1)
                    i = i + 1
                end
//                temp:GetLabel():GainedSelection()
                temp:GetIcon():SetColor(GetHighlightColor())
                temp:GetEntryBox():SetColor(GetHighlightColor())
            elseif target is RegressionLine
                RegressionLine temp = cast(RegressionLine, target)
                previousZ = temp:GetZ()
                previousColor = temp:GetColor()
                temp:SetZ(-5)
                temp:SetColor(GetHighlightColor())
                temp:GetLabel():GainedSelection()
                temp:GetIcon():SetColor(GetHighlightColor())
            elseif target is Drawable
                Drawable temp = cast(Drawable, target)
                previousZ = temp:GetZ()
                previousColor = temp:GetColor()
                temp:SetZ(-1)
                temp:SetColor(GetHighlightColor())
            elseif target is ControlLabel
                ControlLabel temp = cast(ControlLabel, target)
                temp:GainedSelection()
            elseif target is Control
                Control temp = cast(Control, target)
                LayoutProperties properties = temp:GetDefaultLayoutProperties()
                if properties not= undefined
                    previousColorGroup = properties:GetBorderColor()
                    previousBackgroundColor = properties:GetBackgroundColor()
                    LabelBoxView view
                    view:SetBorderThickness(cast(integer, properties:GetBorderThickness())+4)
                    view:Initialize(GetHighlightColor():White(), GetHighlightColor())
                    temp:SetView2D(view)
                end
            end
        end
    end

    /*
        This action gets the ChartSelection, which contains the ChartItem that is currently selected. 
        The reason why we use this indirection, instead of getting the items directly, is because this ensures
        the operating system is informed whenever selections are changed. The item can be obtained from this selection
        by calling GetChartItem on the selection. The selection is intended to never be undefined, even if nothing is selected.

        Attribute: Returns the current selection
    */
    action GetSelection returns ChartSelection
        return selection
    end

    /*
        This action sets the ChartItem that is currently selected. 
        This call has the same effect as calling GetSelection, then Set(ChartItem) on the selection.

        Attribute: Parameter item the current item to be selected
    */
    action Select(ChartItem item)
        selection:Set(item)
    end

    /*
        This action tells the chart to select the next item in its navigation path.
    */
    action SelectNext
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        ChartItem next
        if selected:IsOpen()
            next = selected:GetChildItem()
        else
            next = selected:GetNext()
        end
        if next = undefined
            ChartItem parentItem = selected:GetParentItem()
            repeat while parentItem:GetNext() = undefined
                if parentItem = infoTreeRoot
                    return now
                end
                parentItem = parentItem:GetParentItem()
            end
            next = parentItem:GetNext()
        end
        selection:Set(next)
    end
    
    /*
        This action tells the chart to select the previous item in its navigation path.
    */
    action SelectPrevious
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        ChartItem next = selected:GetPrevious()
        if next not= undefined
            repeat while next:IsOpen()
                next = next:GetLastChild()
                if next = undefined
                    return now
                end
            end
        end
        if next = undefined
            next = selected:GetParentItem()
            if next = undefined
                return now
            end
        end

        selection:Set(next)
    end

    /*
        This action tells the chart to select a child in its list, if it has one.
    */
    action SelectChild
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        ChartItem next = selected:GetChildItem()
        if next = undefined
            return now
        end

        selection:Set(next)
    end

    /*
        This action tells the chart to select the parent of the current item.
    */
    action SelectParent
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        ChartItem next = selected:GetParentItem()
        if next = undefined
            return now
        end

        selection:Set(next)
    end

    /*
        This action opens the chart item if it has children
        If it has children and is already open it moves to first child.
    */
    action OpenItem
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        if not selected:Open() and selected:IsOpenable()
            ChartItem next = selected:GetChildItem()
            if next = undefined
                return now
            end
    
            selection:Set(next)
        end
    end

    /*
        This action opens the chart item if it is open
        If it has children and is already open it moves to first child.
    */
    action CloseItem
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        if not selected:Close()
            ChartItem next = selected:GetParentItem()
            if next = undefined
                return now
            end
            selection:Set(next)
        end
    end

    /*
        Attribute: Returns the root chart item
    */
    action GetInfoTreeRoot returns ChartItem
        return infoTreeRoot
    end

    /*
        This action tells the system to update all of its graphics because its structure has changed. This might 
        be true if the charts are being used to update a live data source.

        Attribute: Parameter update whether or not an update is required
    */
    action SetNeedsUpdate(boolean update)
        me:treeNeedsUpdate = update
    end
    
    /*
        This action indicates whether the system needs its graphics updated.

        Attribute: Returns whether or not an update is required
    */
    action NeedsTreeUpdate returns boolean
        return treeNeedsUpdate
    end

    /*
        This action overrides the default Update action. If the tree needs to be updated, the tree is regenerated.

        Attribute: Parameter seconds the number of seconds since the last update.
    */
    action Update(number seconds)
        if treeNeedsUpdate
            GenerateInfoTree()
            treeNeedsUpdate = false
        end
    end

    action GetBackground returns Drawable
        return background
    end

    action SetBackground(Drawable background)
        me:background = background
    end

    /* 
        This action converts this chart to a text value that contains information 
        for a scalable vector graphics file. This is useful for saving charts to disk.
        Each sub-class of chart must implement this action separately.

        Attribute: Returns the Scalable Vector Graphics (SVG) text.
    */
    action ConvertToScalableVectorGraphics returns text
        return ""
    end

    /*
        This action saves this chart to disk at the position of the current file. To conduct the 
        conversion, the file extension is used. Only Scalable Vector Graphics (SVG) is currently 
        supported.

        Attribute: Parameter file the location of where to save the file.
    */
    action Save(File file)
        if file:GetFileExtension() = "svg"
            text value = ConvertToScalableVectorGraphics()
            file:Write(value)
        end
    end

    /*
        This is a helper action for saving that saves at the path relative to the current working directory.

        Attribute: Parameter path the path relative to the working directory.
    */
    action Save(text path)
        File file
        file:SetPath(path)
        Save(file)
    end

    /*  This action creates a default Game object for displaying charts and sets this chart
        as the sole display. It is useful for interacting with charts without creating
        a complex game setup.
    */
    action Display
        ChartDisplay game
        game:SetScreenSize(2000,1000) //Default size.
        game:SetChart(me)
        game:StartGame()
    end

    /*  This action creates a default Game object for displaying charts and sets this chart
        as the sole display. It is useful for interacting with charts without creating
        a complex game setup.
    */
    action Display(integer width, integer height)
        ChartDisplay game
        game:SetScreenSize(width,height)
        game:SetChart(me)
        game:StartGame()
    end

    /*  This action creates a default Game object for displaying charts and sets this chart
        as the sole display. It is useful for interacting with charts without creating
        a complex game setup. The exit flag tells the system, if true, to close the pre-built display
        right after completing layout, which can be useful for writing to disk.
    */
    action Display(boolean exit)
        ChartDisplay game
        game:SetExitOnStart(exit)
        game:SetScreenSize(1200,1000) //Default size.
        game:SetChart(me)
        game:StartGame()
    end

    /*  This action creates a default Game object for displaying charts and sets this chart
        as the sole display. It is useful for interacting with charts without creating
        a complex game setup. The exit flag tells the system, if true, to close the pre-built display
        right after completing layout, which can be useful for writing to disk.
    */
    action Display(integer width, integer height, boolean exit)
        ChartDisplay game
        game:SetExitOnStart(exit)
        game:SetScreenSize(width,height)
        game:SetChart(me)
        game:StartGame()
    end

end