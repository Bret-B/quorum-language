package Libraries.Interface.Controls.Charts

use Libraries.Interface.Controls.Control
use Libraries.Interface.Selections.ChartSelection
use Libraries.Interface.Layouts.LayoutProperties
use Libraries.Interface.Views.ControlView
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Label
use Libraries.Interface.Controls.ControlLabel
use Libraries.Interface.Layouts.ManualLayout
use Libraries.Containers.Array
use Libraries.Interface.Controls.Charts.ChartOptions
use Libraries.Compute.Math
use Libraries.Game.Graphics.Color
use Libraries.Interface.Controls.Icon
use Libraries.Game.Graphics.ColorGroup
use Libraries.Game.Graphics.Font
use Libraries.Game.Graphics.TextureRegion
use Libraries.Interface.Views.View2D
use Libraries.Interface.Item
use Libraries.Interface.Controls.Charts.ChartDisplay
use Libraries.System.File
use Libraries.Interface.Views.LabelBoxView

/*

    This class represents a generic chart on the system. By default, charts present visual 
    information to the user and also present themselves as accessible controls to the operating 
    system. This includes a selection, called ChartSelection, that can be queried for information 
    that is relevant to particular kinds of charts. For example, a bar chart might have labels, 
    axes, and bars. Each of these can be navigated up and down to go between parents, with the 
    top-most level being a summary and any ChartItems underneath being representations of the 
    underlying structure of the chart. 

    To put this in perspective, consider that a bar chart might allow one to navigate to a 
    level of a chart that contains the axes, bars, and labels. On the bars, if one presses the 
    down arrow, this now allows the user to navigate between the bars for information and this 
    changes the default selection, which informs the operating system of the change. The broad 
    purpose of this architecture is that it allows the chart to have an overall structure that 
    is different from the graphical structure, allowing the chart itself to set reasonable 
    defaults for how to navigate the control with the keyboard

    Attribute: Author Gabriel Contreras and Andreas Stefik

    Attribute: Example

    use Libraries.Interface.Controls.Charts
    use Libraries.Game.Game

    class Main is Game
        action Main
            StartGame()
        end

        action CreateGame
            BarChart chart
            Add(chart)
        end
    end
*/
class Chart is Control
    Legend legend
    boolean showLegend = false
    boolean showGrayscale = false
    boolean orientationFlag = false
    boolean treeNeedsUpdate = true
    ChartSelection selection
    Math math
    ChartOptions options
    Font font
    Color color

    integer tickLength = 15
    integer tickWidth = 3
    integer paddedChartOffset = 0
    
    // Chart Orientation
    text currentOrientation = undefined
    text defaultOrientation = undefined

    Array<Icon> groupPanels 

    // Chart Area Components
    Label title = undefined
    Control chartArea
    Drawable backgroundD = undefined

    // X-Axis Components
    Control horizontalPanel
    Drawable xAxis = undefined
    ControlLabel xLabel = undefined
    Array<ControlLabel> xLabels
    Array<Drawable> xTicks
    Array<Drawable> majorXGridlines
    Array<Drawable> minorXGridlines
    Array<text> xLabelsOverride = undefined
    text xAxisTitle = ""
    
    boolean showMajorXGridLines = false
    boolean showMinorXGridLines = false
    boolean xAxisActivated = true
    boolean xIntervalBasedOnTickCount = false
    boolean overrideXLabelsRotation = false
    boolean useIntegersOnXAxis = false

    number xAxisSizeOffset = 0.75
    number xAxisMinimum = 0
    number xAxisMaximum = 1
    number sumOfWidthsOfXLabels = 0
    integer xLabelsRotation = 0

    integer xTickCount = 0
    number xTickInterval = -1

    // Y-Axis Components
    Control verticalPanel
    Drawable yAxis = undefined
    ControlLabel yLabel = undefined
    Array<ControlLabel> yLabels
    Array<Drawable> yTicks
    Array<Drawable> majorYGridlines
    Array<Drawable> minorYGridlines
    Array<text> yLabelsOverride = undefined 
    text yAxisTitle = ""

    boolean showMajorYGridLines = false
    boolean showMinorYGridLines = false   
    boolean yAxisActivated = true
    boolean yIntervalBasedOnTickCount = false
    boolean useIntegersOnYAxis = false

    number yAxisSizeOffset = 0.75   
    number yAxisMinimum = 0
    number yAxisMaximum = 1
    integer yLabelsRotation = 0

    integer yTickCount = 0
    number yTickInterval = -1

    on create
        ManualLayout manualLayout
        chartArea:SetLayout(manualLayout)

        horizontalPanel:SetName("Horizontal")
        verticalPanel:SetName("Vertical")
        chartArea:SetName("Chart Area")

        Color color
        LayoutProperties properties = chartArea:GetDefaultLayoutProperties()
        properties:SetBackgroundColor(color:White())
        properties:SetBorderColor(color:White())
        properties:SetBorderThickness(4)

        horizontalPanel:SetFocusable(true)
        verticalPanel:SetFocusable(true)
        chartArea:SetFocusable(true)

        horizontalPanel:SetAccessibilityCode(parent:Item:CUSTOM)
        verticalPanel:SetAccessibilityCode(parent:Item:CUSTOM)
        chartArea:SetAccessibilityCode(parent:Item:CUSTOM)

        Add(horizontalPanel)
        Add(verticalPanel)
        Add(chartArea)
    end

    blueprint action GenerateSummary returns text
    private blueprint action GenerateInfoTree

    action GetChartAreaWidthPercent returns number
        return xAxisSizeOffset
    end

    action GetChartAreaHeightPercent returns number
        return yAxisSizeOffset
    end

    action SetChartAreaWidthPercent(number value)
        me:xAxisSizeOffset = value
    end

    action SetChartAreaHeightPercent(number value)
        me:yAxisSizeOffset = value
    end

    action IsAccessibleParent returns boolean
        return true
    end


    action OverrideXLabelsWithText(Array<text> labels)
        if labels not= undefined
            xTickCount = labels:GetSize()
        end
        xLabelsOverride = labels
    end

    action OverrideYLabelsWithText(Array<text> labels)
        if labels not= undefined
            yTickCount = labels:GetSize()
        end
        yLabelsOverride = labels
    end

    action OverrideXLabels() returns boolean
        if xLabelsOverride = undefined
            return false
        else
            return true
        end
    end

    action OverrideYLabels() returns boolean
        if yLabelsOverride = undefined
            return false
        else
            return true
        end
    end

    action SetXTickCount(integer ticks)
        if xLabelsOverride = undefined
            xTickCount = ticks
            xIntervalBasedOnTickCount = true
        end
    end

    action GetXTickCount returns integer
        return xTickCount
    end

    action SetYTickCount(integer ticks)
        if yLabelsOverride = undefined
            yTickCount = ticks
            yIntervalBasedOnTickCount = true
        end
    end

    action GetYTickCount returns integer
        return yTickCount
    end

    action SetXTickInterval(number set)
        if xLabelsOverride = undefined
            xTickInterval = set
        end
    end

    action SetYTickInterval(number set)
        if yLabelsOverride = undefined
            yTickInterval = set
        end
    end
    
    action SetXTickInterval(integer set)
        if xLabelsOverride = undefined
            xTickInterval = cast(number, set)
        end
    end

    action SetYTickInterval(integer set)
        if yLabelsOverride = undefined
            yTickInterval = cast(number, set)
        end
    end
    
    action GetXTickInterval() returns number
        return xTickInterval
    end

    action GetYTickInterval() returns number
        return yTickInterval
    end

    action GetXAxisMinimum returns number
        return xAxisMinimum
    end

    // This is the user and general unflipped orientation control of the axis min
    action SetXAxisMinimum(number xAxisMinimum)
        if orientationFlag
            me:yAxisMinimum = xAxisMinimum
        else
            me:xAxisMinimum = xAxisMinimum
        end
    end
    // This is used when the minimum needs to be changed prior to the flipping in any chart's LoadGraphics action
    action SetXAxisMinimum(number xAxisMinimum, boolean flag)
        if flag
            me:xAxisMinimum = xAxisMinimum
        end
    end

    action GetXAxisMaximum returns number
        return xAxisMaximum
    end
    // This is the user and general unflipped orientation control of the axis max
    action SetXAxisMaximum(number xAxisMaximum)
        if orientationFlag
            me:yAxisMaximum = xAxisMaximum
        else
            me:xAxisMaximum = xAxisMaximum
        end
    end
    // This is used when the minimum needs to be changed prior to the flipping in any chart's LoadGraphics action
    // See an example of its use in SharedBarChartParent:LoadGraphics() when stacking bars.
    action SetXAxisMaximum(number xAxisMaximum, boolean flag)
        if flag
            me:xAxisMaximum = xAxisMaximum
        end
    end

    action GetYAxisMinimum returns number
        return yAxisMinimum
    end

    // This is the user and general unflipped orientation control of the y-axis min
    action SetYAxisMinimum(number yAxisMinimum)
        if orientationFlag
            me:xAxisMinimum = yAxisMinimum
        else
            me:yAxisMinimum = yAxisMinimum
        end
    end
    // This is used when the minimum needs to be changed regardless of flipping in any chart's LoadGraphics action
    action SetYAxisMinimum(number yAxisMinimum, boolean flag)
        if flag
            me:yAxisMinimum = yAxisMinimum
        end
    end

    action GetYAxisMaximum returns number
        return yAxisMaximum
    end

    // This is the user and general unflipped orientation control of the y-axis max
    action SetYAxisMaximum(number yAxisMaximum)
        if orientationFlag
            me:xAxisMaximum = yAxisMaximum
        else
            me:yAxisMaximum = yAxisMaximum
        end
    end
    // This is used when the minimum needs to be changed prior to the flipping in any chart's LoadGraphics action
    // See an example of its use in SharedBarChartParent:LoadGraphics when stacking bars.
    action SetYAxisMaximum(number yAxisMaximum, boolean flag)
        if flag
            me:yAxisMaximum = yAxisMaximum
        end
    end

    action UseIntegersOnXAxis(boolean flag)
        useIntegersOnXAxis = flag
    end

    action UseIntegersOnYAxis(boolean flag)
        useIntegersOnYAxis = flag
    end


    action GetPaddedChartOffset returns integer
        return paddedChartOffset
    end
    action SetPaddedChartOffset(integer offset)
        paddedChartOffset = offset
    end

    /*
    These actions are used to get and set the orientation. The default will
    be set on creation of each chart but can be changed afterwards manually
    or the user can call FlipOrientation().
    */
    action GetOrientation returns text
        return currentOrientation
    end
    action GetDefaultOrientation returns text
        return defaultOrientation
    end

    action SetOrientation(text orient)
        text newOrientation = orient:ToLowerCase()
        if newOrientation = "horizontal" or newOrientation = "vertical"
            if newOrientation = currentOrientation
                orientationFlag = false
            else
                currentOrientation = newOrientation
                orientationFlag = true
            end
        else
            alert("Orientation can only by vertical or horizontal")
        end
    end

    action SetDefaultOrientation(text orient)
        text newOrientation = orient:ToLowerCase()
        if newOrientation = "horizontal" or newOrientation = "vertical"
            defaultOrientation = newOrientation
            currentOrientation = newOrientation
        else
            alert("Orientation can only by vertical or horizontal")
        end
    end

    action FlipOrientation()
        if currentOrientation not= undefined
            orientationFlag = true
            if currentOrientation = "horizontal"
                currentOrientation = "vertical"
            else
                currentOrientation = "horizontal"
            end
        end
    end

    action OrientationChanged() returns boolean
        return orientationFlag 
    end

    action GetGroupPanels returns Array<Icon>
        return groupPanels
    end

    action GetHorizontalFlag() returns boolean
        if currentOrientation = "horizontal"
            return true
        else
            return false
        end
    end

    action GetVerticalFlag() returns boolean
        if currentOrientation = "vertical"
            return true
        else
            return false
        end
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetHorizontalPanel returns Control
        return horizontalPanel
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetVerticalPanel returns Control
        return verticalPanel
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetChartArea returns Control
        return chartArea
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetYTicks returns Array<Drawable>
        return yTicks
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetMajorYGridlines returns Array<Drawable>
        return majorYGridlines
    end

    action GetMajorXGridlines returns Array<Drawable>
        return majorXGridlines
    end
    
    action GetMinorYGridlines returns Array<Drawable>
        return minorYGridlines
    end

    action GetMinorXGridlines returns Array<Drawable>
        return minorXGridlines
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetYLabels returns Array<ControlLabel>
        return yLabels
    end

    action SetYLabels(Array<ControlLabel> newLabels)
        yLabels = newLabels
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetXTicks returns Array<Drawable>
        return xTicks
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetXLabels returns Array<ControlLabel>
        return xLabels
    end

    action SetXLabels(Array<ControlLabel> newLabels)
        xLabels = newLabels
    end

    action RotateXLabels(integer degrees) // "360 -" because it rotates opposite as how you'd imagine.
        xLabelsRotation = 360 - degrees
        SetRotationOverride(true)
    end

    action GetXLabelsRotation() returns integer
        return xLabelsRotation
    end

    action GetRotationOverride() returns boolean
        return overrideXLabelsRotation
    end

    action SetRotationOverride(boolean flag)
        overrideXLabelsRotation = flag
    end

    action SetSumOfXLabelWidths(number sum)
        sumOfWidthsOfXLabels = sum
    end

    action GetSumOfXLabelWidths() returns number
        return sumOfWidthsOfXLabels
    end

    action SetName(text name)
        parent:Item2D:SetName(name)
        
        LayoutProperties defaultProperties = GetDefaultLayoutProperties()

        if defaultProperties not= undefined
            defaultProperties:SetLabelText(name)
        end
        if GetView2D() is ControlView
            ControlView content = cast(ControlView, GetView2D())
            content:SetText(name)
        end
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetTitleLabel returns Label
        return title
    end

    action SetTitleLabel(Label label)
        me:title = label
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetXAxis returns Drawable
        return xAxis
    end

    action SetXAxis(Drawable drawable)
        xAxis = drawable
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetYAxis returns Drawable
        return yAxis
    end
    
    action SetYAxis(Drawable drawable)
        yAxis = drawable
    end
    /*
        Set the Title of the Bar Chart.

        Attribute: Parameter name the name of the title.
    */
    action SetTitle(text name)
        SetName(name)
    end

    /*
        Returns the Title of the Bar Chart.

        Attribute: Returns the name
    */
    action GetTitle returns text
        return GetName()
    end

    
    /*
        Set the title for the X-Axis(Categories) of the Bar Chart.
    */
    action SetXAxisTitle(text name)
        xAxisTitle = name
    end

    /*
        Returns the title for the X-Axis(Categories) of the Bar Chart.
    */
    action GetXAxisTitle returns text
        return xAxisTitle
    end

    /*
        Set the title for the Y-Axis(Scale) of the Bar Chart.
    */
    action SetYAxisTitle(text name)
        yAxisTitle = name
    end

    /*
        Returns the title for the Y-Axis(Scale) of the Bar Chart.
    */
    action GetYAxisTitle returns text
        return yAxisTitle
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetXLabel returns ControlLabel
        return xLabel
    end

    action SetXLabel(ControlLabel label)
        me:xLabel = label
    end

    action SetYLabel(ControlLabel label)
        me:yLabel = label
    end

    /*
    This action is used by the layout to position the graphical components of 
    the Chart. Layout is handled automatically so users don't need to use this
    action directly.
    */
    action GetYLabel returns ControlLabel
        return yLabel
    end

    action GetDefaultFontSize returns integer
        return 24
    end

    action DisposeDrawables()

        if title not= undefined
            title:Dispose()
            Remove(title)
            title = undefined
        end

        if xLabel not= undefined
            xLabel:Dispose()
            Remove(xLabel)
            xLabel = undefined
        end

        if yLabel not= undefined
            yLabel:Dispose()
            Remove(yLabel)
            yLabel = undefined
        end

        if backgroundD not= undefined
            backgroundD:Dispose()
            Remove(backgroundD)
            backgroundD = undefined
        end

        if xAxis not= undefined
            xAxis:Dispose()
            Remove(xAxis)
            xAxis = undefined
        end

        if yAxis not= undefined
            yAxis:Dispose()
            Remove(yAxis)
            yAxis = undefined
        end

        if not yTicks:IsEmpty()
            Drawable temp = undefined
            integer i = 0
            repeat while i < yTicks:GetSize()
                temp = yTicks:Get(i)
                if temp not= undefined
                    temp:Dispose()
                    Remove(temp)
                    temp = undefined
                end
                i = i + 1
            end
            yTicks:Empty()
        end

        if not yLabels:IsEmpty()
            Label temp = undefined
            integer i = 0
            repeat while i < yLabels:GetSize()
                temp = yLabels:Get(i)
                if temp not= undefined
                    temp:Dispose()
                    Remove(temp)
                    temp = undefined
                end
                i = i + 1
            end
            yLabels:Empty()
        end

        if not xTicks:IsEmpty()
            Drawable temp = undefined
            integer i = 0
            repeat while i < xTicks:GetSize()
                temp = xTicks:Get(i)
                if temp not= undefined
                    temp:Dispose()
                    Remove(temp)
                    temp = undefined
                end
                i = i + 1
            end
            xTicks:Empty()
        end

        if not xLabels:IsEmpty()
            Label temp = undefined
            integer i = 0
            repeat while i < xLabels:GetSize()
                temp = xLabels:Get(i)
                if temp not= undefined
                    temp:Dispose()
                    Remove(temp)
                    temp = undefined
                end
                i = i + 1
            end
            xLabels:Empty()
        end

        GetLegend():Empty()
        GetVerticalPanel():Empty()
        GetHorizontalPanel():Empty()
    end

    /*  Returns the relative size difference in the x axis label for the chart. 
        Attribute: Returns the size difference compared to the base font size
    */
    action GetXAxisFontSizeOffset returns number
        return xAxisSizeOffset
    end

    /*  Sets the relative size difference in the x axis label for the chart. 
        Attribute: Parameter value the size difference compared to the base font size
    */
    action SetXAxisFontSizeOffset(number value)
        me:xAxisSizeOffset = value
    end

    /*  Returns the relative size difference in the y axis label for the chart. 
        Attribute: Returns the size difference compared to the base font size
    */
    action GetYAxisFontSizeOffset returns number
        return yAxisSizeOffset
    end

    /*  Sets the relative size difference in the y axis label for the chart. 
        Attribute: Parameter value the size difference compared to the base font size
    */
    action SetYAxisFontSizeOffset(number value)
        me:yAxisSizeOffset = value
    end

    action LoadGraphics(LayoutProperties properties)
        DisposeDrawables()
        parent:Control:LoadGraphics(properties)   
        if properties = undefined
            return now
        end

        if IsGrayScale()
            options:SetPaletteToGrayScale()
        end

        ColorGroup background = properties:GetBackgroundColor()
        ColorGroup border = properties:GetBorderColor()
        number borderThickness = properties:GetBorderThickness()
        text labelText = properties:GetLabelText()

        //Control chartArea = GetChartArea()

        font = properties:GetFont()
        TextureRegion iconTexture = properties:GetIcon()
        
        if GetWidth() = 0 or GetHeight() = 0
            SetSize(500,500)//this is for a default size
        end

        if GetBackground() = undefined
            Drawable rect
            rect:LoadFilledRectangle(cast(integer, GetWidth()) ,cast(integer, GetHeight()), color:White())
            SetBackground(rect)
            Add(rect)
        end

        ColorGroup chartAreaBackground = chartArea:GetDefaultLayoutProperties():GetBackgroundColor()
        ColorGroup chartAreaBorder = chartArea:GetDefaultLayoutProperties():GetBorderColor()
        number chartAreaBorderThickness = chartArea:GetDefaultLayoutProperties():GetBorderThickness()
        View2D chartAreaView = chartArea:GetDefaultLayoutProperties():GetView2D()

        if chartAreaView = undefined
            //background of chart area
            LabelBoxView chartAreaLabelBoxView
            if chartAreaBackground = undefined
                chartAreaBackground = color:CustomColor(0, 0, 0, 0)
            end
            if chartAreaBorder = undefined
                chartAreaBorder = color:CustomColor(0, 0, 0, 0)
            end
    
            chartAreaLabelBoxView:SetBorderThickness(cast(integer, chartAreaBorderThickness))
            chartAreaLabelBoxView:Initialize(chartAreaBackground, chartAreaBorder)
            chartAreaView = chartAreaLabelBoxView
            chartArea:SetView2D(chartAreaLabelBoxView)
        end

        if chartAreaView not= undefined
            chartArea:SetView2D(chartAreaView)
        end
        
        if GetTitleLabel() = undefined
            Label newLabel
            SetTitleLabel(newLabel)
            newLabel:SetFont(font)
            newLabel:SetSize(GetFontSize())
            newLabel:SetText(labelText)
            Add(newLabel)
        end

        Item2D xLabelAnchor
        if GetXLabel() = undefined 
            ControlLabel newLabel
            SetXLabel(newLabel)
            newLabel:SetFont(font:Copy())
            newLabel:SetSize(cast(integer, GetFontSize()*xAxisSizeOffset))
            newLabel:SetText(GetXAxisTitle())
            newLabel:SetName(GetXAxisTitle())
            newLabel:SetDescription("Horizontal axis")
            newLabel:SetFocusable(true)
            newLabel:SetAccessibilityCode(parent:Item:ITEM)
        end

        Item2D yLabelAnchor
        if GetYLabel() = undefined 
            ControlLabel newLabel
            SetYLabel(newLabel)
            newLabel:SetFont(font:Copy())
            newLabel:SetSize(cast(integer, GetFontSize()*yAxisSizeOffset))
            newLabel:SetText(GetYAxisTitle())
            newLabel:SetName(GetYAxisTitle())
            newLabel:SetDescription("Vertical axis")
            newLabel:SetFocusable(true)
            newLabel:SetAccessibilityCode(parent:Item:ITEM)
        end

        if orientationFlag
            FlipAxes()
        end

        xLabelAnchor:Add(GetXLabel())
        yLabelAnchor:Add(GetYLabel())

        LoadAxes()

        Add(horizontalPanel)
        Add(verticalPanel)
        Add(chartArea)
        SetNeedsUpdate(true)
        Resize()
        SetNextFocus(GetNextFocus())
        SetPreviousFocus(GetPreviousFocus())
    end

    action LoadAxes()
        if xAxisActivated
            LoadXAxis()
        end
        if yAxisActivated
            LoadYAxis()
        end
    end

    action LoadXAxis()
        xTicks:Empty()
        xLabels:Empty()
        majorXGridlines:Empty()
        minorXGridlines:Empty()
        horizontalPanel:Empty()
        horizontalPanel:Add(GetXLabel():GetParent())

        if GetXAxis() = undefined
            Drawable line
            line:LoadFilledRectangle(cast(integer, GetWidth() * xAxisSizeOffset), 5)
            SetXAxis(line)
            chartArea:Add(line)
        end

        if xLabelsOverride not= undefined
            xAxisMinimum = 0
            xAxisMaximum = xLabelsOverride:GetSize()-1
        end

        number scaleNum = xAxisMinimum
        number scaleWidth = xAxisCalculateScaleWidth()

        if xTicks:GetSize() not= xTickCount
            
            if xTicks:GetSize() < xTickCount
                integer i = 0
                repeat while i < xTickCount
                    Drawable tick
                    tick:LoadFilledRectangle(tickWidth, tickLength)
                    horizontalPanel:Add(tick)
                    xTicks:Add(tick)

                    if showMajorXGridLines
                        Drawable gridline
                        majorXGridlines:Add(gridline)
                        chartArea:Add(gridline)
                    end
                    if showMinorXGridLines
                        integer j = 0
                        repeat while j < 5
                            Drawable gridline
                            minorXGridlines:Add(gridline)
                            chartArea:Add(gridline)
                            j = j + 1
                        end
                    end

                    Item2D labelAnchor
                    ControlLabel label
                    label:SetFontSize(GetFontSize() - 5)
                    label:SetFocusable(true)
                    label:SetAccessibilityCode(parent:Item:ITEM)
                    xLabels:Add(label)
                    labelAnchor:Add(label)
                    horizontalPanel:Add(labelAnchor)
                    i = i + 1
                end
            else
                repeat until xTicks:GetSize() = xTickCount - 1
                    Drawable tick = xTicks:RemoveFromEnd()
                    horizontalPanel:Remove(tick)

                    ControlLabel label = xLabels:RemoveFromEnd()
                    horizontalPanel:Remove(label)
                end
            end

            number sumOfWidths = 0
            if xTickCount > 0
                i = 0
                repeat while i < xTickCount
                    Drawable tick = xTicks:Get(i)
                    tick:SetName("X Tick " + (i + 1))
    
                    //make the labels for each scale tick (auto based on max)
                    text scaleText = "" + math:Round(scaleNum, options:GetTickDigits())
                    if useIntegersOnXAxis 
                        scaleText = "" + cast(integer, math:Round(scaleNum, options:GetTickDigits()))
                    end
                    ControlLabel label = xLabels:Get(i)
                    if xLabelsOverride = undefined
                        label:SetText(scaleText)
                    else
                        number percent = (i * 1.0) / ((xTickCount) * 1.0)
                        integer index = cast(integer, math:Round(percent * xLabelsOverride:GetSize()))
                        label:SetText(xLabelsOverride:Get(index))
                    end
                    label:SetName(scaleText + " " + (i + 1) + " of " + xTickCount)
                    number labelWidth = label:GetWidth()
                    sumOfWidths = sumOfWidths + labelWidth
                    scaleNum = scaleNum + scaleWidth
                    i = i + 1
                end
                SetSumOfXLabelWidths(sumOfWidths)
            end
        end
    end

    action LoadYAxis()
        yTicks:Empty()
        yLabels:Empty()
        majorYGridlines:Empty()
        minorYGridlines:Empty()
        verticalPanel:Empty()
        verticalPanel:Add(GetYLabel():GetParent())

        if GetYAxis() = undefined
            Drawable line
            line:LoadFilledRectangle(5, cast(integer, GetHeight() * yAxisSizeOffset))
            SetYAxis(line)
            chartArea:Add(line)
        end

        if yLabelsOverride not= undefined
            yAxisMinimum = 0
            yAxisMaximum = yLabelsOverride:GetSize()-1
        end

        number scaleNum = yAxisMinimum
        number scaleWidth = yAxisCalculateScaleWidth()

        if yTicks:GetSize() not= yTickCount
            if yTicks:GetSize() < yTickCount
                repeat until yTicks:GetSize() = yTickCount
                    Drawable tick
                    tick:LoadFilledRectangle(tickLength, tickWidth)
                    verticalPanel:Add(tick)
                    yTicks:Add(tick)

                    if showMajorYGridLines
                        Drawable gridline
                        majorYGridlines:Add(gridline)
                        chartArea:Add(gridline)
                    end
                    if showMinorYGridLines
                        integer j = 0
                        repeat while j < 5
                            Drawable gridline
                            minorYGridlines:Add(gridline)
                            chartArea:Add(gridline)
                            j = j + 1
                        end
                    end

                    Item2D labelAnchor
                    ControlLabel label
                    label:SetFontSize(GetFontSize() - 5)
                    label:SetFocusable(true)
                    label:SetAccessibilityCode(parent:Item:ITEM)
                    yLabels:Add(label)
                    labelAnchor:Add(label)
                    verticalPanel:Add(labelAnchor)
                end
            else
                repeat until yTicks:GetSize() = yTickCount
                    Drawable tick = yTicks:RemoveFromEnd()
                    verticalPanel:Remove(tick)

                    ControlLabel label = yLabels:RemoveFromEnd()
                    verticalPanel:Remove(label)
                end
            end

            i = 0
            repeat while i < yTickCount
                Drawable tick = yTicks:Get(i)
                tick:SetName("Y Tick " + (i + 1))

                //make the labels for each scale tick (auto based on max)
                text scaleText = "" + math:Round(scaleNum, options:GetTickDigits())
                if useIntegersOnYAxis 
                    scaleText = "" + cast(integer, math:Round(scaleNum, options:GetTickDigits()))
                end
                ControlLabel label = yLabels:Get(i)
                if yLabelsOverride = undefined
                    label:SetText(scaleText)
                else
                    //now get the location of the text value to put in
                    if i = yTickCount
                        label:SetText(yLabelsOverride:Get(yLabelsOverride:GetSize())) 
                    else
                        number percent = (i * 1.0) / ((yTickCount) * 1.0)
                        integer index = cast(integer, math:Round(percent * yLabelsOverride:GetSize()))
                        label:SetText(yLabelsOverride:Get(index))
                    end
                end
                label:SetName(scaleText + " " + (i + 1) + " of " + yTickCount)
                scaleNum = scaleNum + scaleWidth
                i = i + 1
            end
        end
    end
    
    /*
        This action will flip the axis min/max and any labels associated.  
        Eventually when there are charts with no axis or only one.
        Then the un-used axis will be deactivated so it won't interfere with the
        accessibility navigation.
    */
    action FlipAxes()
        GetVerticalPanel():Empty()
        GetHorizontalPanel():Empty()

        number temp = xAxisMaximum
        xAxisMaximum = yAxisMaximum
        yAxisMaximum = temp

        temp = xAxisMinimum
        xAxisMinimum = yAxisMinimum
        yAxisMinimum = temp

        if xLabelsOverride not= undefined
            if yLabelsOverride not= undefined
                Array<text> temps = xLabelsOverride
                xLabelsOverride = yLabelsOverride
                yLabelsOverride = temps
                
                xTickCount = xLabelsOverride:GetSize()
                yTickCount = yLabelsOverride:GetSize()
            else
                OverrideYLabelsWithText(xLabelsOverride)
                xLabelsOverride = undefined
            end
        else
            if yLabelsOverride not= undefined
                OverrideXLabelsWithText(yLabelsOverride)
                yLabelsOverride = undefined
            end
        end

        boolean tempBool = useIntegersOnXAxis
        useIntegersOnXAxis = useIntegersOnYAxis
        useIntegersOnYAxis = tempBool

        if GetXLabel() = undefined 
            if GetYLabel() = undefined
                //Nothing to be done
            else
                //Define XLabel and undefine YLabel
            end
        else
            if GetYLabel() = undefined
                //Define YLabel and undefine XLabel
            else
                ControlLabel tempLabel = GetXLabel()
                SetXLabel(GetYLabel())
                SetYLabel(tempLabel)
            end
        end
    end

    /*
        This action takes a range of data and returns a decent interval, this is only the default.
        The user can choose any interval they wish and set it manually.  
    */
    action CalculateBestIntervalForRange(number range) returns number
        number tickSkips = 0
        if range <= 2.5
            if range > 1.5
                tickSkips = 0.5
            else
                tickSkips = 0.1
            end
        else
            if range > 5000
                tickSkips = 1000
            elseif range > 2500
                tickSkips = 500
            elseif range > 1000
                tickSkips = 250
            elseif range > 500
                tickSkips = 100
            elseif range > 200
                tickSkips = 50
            elseif range > 100
                tickSkips = 20
            elseif range > 50
                tickSkips = 10
            elseif range > 20
                tickSkips = 5
            elseif range > 10
                tickSkips = 2
            else
                tickSkips = 1
            end
        end
        return tickSkips
    end

    /*
        These actions calculates the best scale width and tick count for the given axis range.
        If the tick count is manually entered, the calculation will try to accomodate to that 
        specific count. If it is not entered manually the tick count will be based off of clean 
        easy-to-read intervals.
    */
    action xAxisCalculateScaleWidth() returns number
        number xRange = xAxisMaximum-xAxisMinimum
        number scaleWidth = 0.0
        // Calculating intervals and/or number of ticks
        if xIntervalBasedOnTickCount
            if xTickCount > 1
                SetXTickInterval(math:Round(xRange / cast(number, xTickCount-1), 2))
                xAxisMaximum = cast(number, xTickCount-1) * GetXTickInterval() + xAxisMinimum
                xRange = xAxisMaximum-xAxisMinimum
            end
        end
        // Numerical x-scale (number intervals)
        if xLabelsOverride = undefined
            number tickSkips = GetXTickInterval()
            if tickSkips = -1
                tickSkips = CalculateBestIntervalForRange(xRange)
            end
            if tickSkips not= 1.0
                number i = xAxisMinimum
                repeat while i < xAxisMaximum
                    i = i + tickSkips
                end
                xAxisMaximum = math:Round(i, 2)
                xRange = xAxisMaximum-xAxisMinimum
                xTickCount = cast(integer, xRange / tickSkips) + 1
                scaleWidth = tickSkips
            else
                xTickCount = cast(integer, xRange) + 1
                scaleWidth = xRange / (xTickCount - 1)
            end 
        // Text x-scale (integer intervals only)
        else
            number tickSkips = 1
            if xLabelsOverride:GetSize() > 25
                tickSkips = cast(integer, xLabelsOverride:GetSize()/5)
            end
            if tickSkips = -1
                tickSkips = CalculateBestIntervalForRange(xRange)
            end
            if tickSkips > 1 and tickSkips < xLabelsOverride:GetSize()
                Array <text> labels
                number i = 0
                repeat while i < xLabelsOverride:GetSize()
                    labels:Add(xLabelsOverride:Get(cast(integer, i)))
                    i = i + tickSkips
                end
                xAxisMaximum = i
                labels:Add(cast(text, cast(integer, xAxisMaximum)))
                xTickCount = labels:GetSize()
                xLabelsOverride = labels
            end
            scaleWidth = xRange / (xTickCount - 1)
        end
        return scaleWidth
    end

    action yAxisCalculateScaleWidth() returns number
        number yRange = yAxisMaximum-yAxisMinimum
        number scaleWidth = 0.0
        // Calculating intervals and/or number of ticks
        if yIntervalBasedOnTickCount
            if yTickCount > 1
                yTickInterval = math:Round(yRange / cast(number, yTickCount-1), 2)
                yAxisMaximum = cast(number, yTickCount-1) * yTickInterval + yAxisMinimum
            end
        end
        // Numerical x-scale (number intervals)
        if yLabelsOverride = undefined
            number tickSkips = yTickInterval
            if tickSkips = -1
                tickSkips = CalculateBestIntervalForRange(yRange)
            end
            if tickSkips not= 1.0
                number i = yAxisMinimum
                repeat while i < yAxisMaximum
                    i = i + tickSkips
                end
                yAxisMaximum = math:Round(i, 2)
                yTickCount = cast(integer, (yAxisMaximum-yAxisMinimum) / tickSkips) + 1
                scaleWidth = tickSkips
            else
                yTickCount = cast(integer, yRange) + 1
                scaleWidth = yRange / (yTickCount - 1)
            end 
        // Text x-scale (integer intervals only)
        else
            number tickSkips = 1 // Edit: perhaps yTickInterval, perhaps not.
            if tickSkips = -1
                tickSkips = CalculateBestIntervalForRange(yRange)
            end
            if tickSkips > 1 and tickSkips < yLabelsOverride:GetSize()
                Array <text> labels
                number i = 0
                repeat while i < yLabelsOverride:GetSize()
                    labels:Add(yLabelsOverride:Get(cast(integer, i)))
                    i = i + tickSkips
                end
                yAxisMaximum = i
                labels:Add(cast(text, cast(integer, yAxisMaximum)))
                yTickCount = labels:GetSize()
                yLabelsOverride = labels
            end
            scaleWidth = yRange / (yTickCount - 1)
        end
        return scaleWidth
    end

    action Resize
        if GetBackground() not= undefined
            GetBackground():SetSize(GetWidth(), GetHeight())
        end

        AdjustForLegend()

        Control horizontalPanel = GetHorizontalPanel()
        Control verticalPanel = GetVerticalPanel()
        Control chartArea = GetChartArea()
        Array<Drawable> scaleTicks = GetYTicks()
        Array<ControlLabel> xLabels = GetXLabels()
        Array<ControlLabel> yLabels = GetYLabels()

        horizontalPanel:SetSize(GetWidth()*xAxisSizeOffset, GetHeight()*0.15)
        verticalPanel:SetSize(GetWidth()*0.15, GetHeight()*yAxisSizeOffset)
        chartArea:SetSize(GetWidth()*xAxisSizeOffset, GetHeight()*yAxisSizeOffset)
        integer relativeFont = cast(integer, (GetWidth() + GetHeight()/2) * 0.02)
        
        integer thickness = cast(integer, GetWidth()*0.001) + 3
        
        if GetXAxis() not= undefined
            GetXAxis():SetSize(chartArea:GetWidth(), thickness)
        end

        if GetYAxis() not= undefined
            GetYAxis():SetSize(thickness, chartArea:GetHeight())
        end

        if not scaleTicks:IsEmpty()
            integer i = 0
            repeat while i < scaleTicks:GetSize()
                scaleTicks:Get(i):SetHeight(GetXAxis():GetHeight())
                scaleTicks:Get(i):SetWidth(GetXAxis():GetHeight() * 3)
                i = i + 1
            end
        end

        if not xLabels:IsEmpty()
            integer i = 0
            repeat while i < xLabels:GetSize()
                xLabels:Get(i):SetFontSize(cast(integer, GetFontSize()*GetXAxisFontSizeOffset()))
                i = i + 1
            end
        end

        if not yLabels:IsEmpty()
            integer i = 0
            repeat while i < yLabels:GetSize()
                yLabels:Get(i):SetFontSize(cast(integer, GetFontSize()*GetYAxisFontSizeOffset()))
                i = i + 1
            end
        end

        if GetXLabel() not= undefined
            GetXLabel():SetFontSize(cast(integer, GetFontSize()*GetXAxisFontSizeOffset()))
        end

        if GetYLabel() not= undefined
            GetYLabel():SetFontSize(cast(integer, GetFontSize()*GetYAxisFontSizeOffset()))
        end

        parent:Control:Resize()
    end
    action AdjustForLegend()
        if IsShowingLegend()
            legend:Resize()
            number legendPercent = legend:GetWidth() / GetWidth()
            Math math
            number remainingChartArea = math:Round(1 - legendPercent - 0.20, 2) //0.15 is hardcoded elsewhere as a flat xOrigOffset and 0.05 for legend padding 
            SetChartAreaWidthPercent(remainingChartArea)
        end
    end

    /* 
        Unlike many kinds of user interface controls, there is no universal way of interacting with a chart and, as such, this 
        may be defined by any chart to be custom. As such, charts must be able to take messages suggesting an item in the chart
        has either lost or gained the focus. Broadly speaking, this is done automatically and while charts need to implement
        this action, they do not need to call this action directly.

        Attribute: Parameter ci the ChartItem representing the structure for this particular kind of chart. 
    */
    blueprint action LostSelection(ChartItem item)

    /* 
        Unlike many kinds of user interface controls, there is no universal way of interacting with a chart and, as such, this 
        may be defined by any chart to be custom. As such, charts must be able to take messages suggesting an item in the chart
        has either lost or gained the focus. Broadly speaking, this is done automatically and while charts need to implement
        this action, they do not need to call this action directly.

        Attribute: Parameter ci the ChartItem representing the structure for this particular kind of chart. 
    */
    blueprint action GainedSelection(ChartItem item)

    /*
        This action gets the ChartSelection, which contains the ChartItem that is currently selected. 
        The reason why we use this indirection, instead of getting the items directly, is because this ensures
        the operating system is informed whenever selections are changed. The item can be obtained from this selection
        by calling GetChartItem on the selection. The selection is intended to never be undefined, even if nothing is selected.

        Attribute: Returns the current selection
    */
    action GetSelection returns ChartSelection
        return selection
    end

    /*
        This action sets the ChartItem that is currently selected. 
        This call has the same effect as calling GetSelection, then Set(ChartItem) on the selection.

        Attribute: Parameter item the current item to be selected
    */
    action Select(ChartItem item)
        selection:Set(item)
    end

    /*
        This action tells the chart to select the next item in its navigation path.
    */
    action SelectNext
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        ChartItem next = selected:GetNext()
        if next = undefined
            return now
        end
        selection:Set(next)
    end
    
    /*
        This action tells the chart to select the previous item in its navigation path.
    */
    action SelectPrevious
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        ChartItem next = selected:GetPrevious()
        if next = undefined
            return now
        end

        selection:Set(next)
    end

    /*
        This action tells the chart to select a child in its list, if it has one.
    */
    action SelectChild
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        ChartItem next = selected:GetChild()
        if next = undefined
            return now
        end

        selection:Set(next)
    end

    /*
        This action tells the chart to select the parent of the current item.
    */
    action SelectParent
        ChartSelection selection = GetSelection()
        ChartItem selected = selection:GetChartItem()
        if selected = undefined
            return now
        end

        ChartItem next = selected:GetParent()
        if next = undefined
            return now
        end

        selection:Set(next)
    end

    /*
        This action states to turn on the legend. 
        Attribute: Parameter true if the legend should be shown.
    */
    action ShowLegend(boolean show)
        showLegend = show
    end

    /*
        This action states to turn on the legend. 
        Attribute: Returns true if the legend is shown.
    */
    action IsShowingLegend returns boolean
        return showLegend
    end

    /*
        The gridline actions to customize which gridlines are visible
        No option to customize density or color at this time.
    */
    action ShowAllGridLines()
        showMajorYGridLines = true
        showMajorXGridLines = true
        showMinorYGridLines = true
        showMinorXGridLines = true
    end
    action HideAllGridLines()
        showMajorYGridLines = false
        showMajorXGridLines = false
        showMinorYGridLines = false
        showMinorXGridLines = false
    end

    action ShowAllXGridLines()
        showMajorXGridLines = true
        showMinorXGridLines = true
    end
    action HideAllXGridLines()
        showMajorXGridLines = false
        showMinorXGridLines = false
    end

    action ShowAllYGridLines()
        showMajorYGridLines = true
        showMinorYGridLines = true
    end
    action HideAllYGridLines()
        showMajorYGridLines = false
        showMinorYGridLines = false
    end

    action ShowMajorGridLines()
        showMajorYGridLines = true
        showMajorXGridLines = true
    end
    action HideMajorGridLines()
        showMajorYGridLines = false
        showMajorXGridLines = false
    end

    action ShowMinorGridLines()
        showMinorYGridLines = true
        showMinorXGridLines = true
    end
    action HideMinorGridLines()
        showMinorYGridLines = false
        showMinorXGridLines = false
    end

    action ShowMinorYGridLines()
        showMinorYGridLines = true
    end
    action HideMinorYGridLines()
        showMinorYGridLines = false
    end

    action ShowMinorXGridLines()
        showMinorXGridLines = true
    end
    action HideMinorXGridLines()
        showMinorXGridLines = false
    end

    action ShowMajorYGridLines()
        showMajorYGridLines = true
    end
    action HideMajorYGridLines()
        showMajorYGridLines = false
    end

    action ShowMajorXGridLines()
        showMajorXGridLines = true
    end
    action HideMajorXGridLines()
        showMajorXGridLines = false
    end

    action IsShowingMajorXGridLines returns boolean
        return showMajorXGridLines
    end

    action IsShowingMajorYGridLines returns boolean
        return showMajorYGridLines
    end

    action IsShowingMinorXGridLines returns boolean
        return showMinorXGridLines
    end

    action IsShowingMinorYGridLines returns boolean
        return showMinorYGridLines
    end


    action ShowGrayScale(boolean show)
        showGrayscale = show
    end

    action IsGrayScale returns boolean
        return showGrayscale
    end

    /*
        This action sets the Legend object

        Attribute: Parameter legend the legend to set
    */
    action SetLegend(Legend legend)
        me:legend = legend
    end

    /*
        This action returns the current legend, if one exists

        Attribute: Returns true if the legend is shown.
    */
    action GetLegend returns Legend
        return legend
    end

    /*
        This action tells the system to update all of its graphics because its structure has changed. This might 
        be true if the charts are being used to update a live data source.

        Attribute: Parameter update whether or not an update is required
    */
    action SetNeedsUpdate(boolean update)
        me:treeNeedsUpdate = update
    end
    
    /*
        This action indicates whether the system needs its graphics updated.

        Attribute: Returns whether or not an update is required
    */
    action NeedsTreeUpdate returns boolean
        return treeNeedsUpdate
    end

    /*
        This action overrides the default Update action. If the tree needs to be updated, the tree is regenerated.

        Attribute: Parameter seconds the number of seconds since the last update.
    */
    action Update(number seconds)
        if treeNeedsUpdate
            GenerateInfoTree()
            treeNeedsUpdate = false
        end
    end

    action GetBackground returns Drawable
        return backgroundD
    end

    action SetBackground(Drawable backgroundD)
        me:backgroundD = backgroundD
    end

    /* 
        This action converts this chart to a text value that contains information 
        for a scalable vector graphics file. This is useful for saving charts to disk.
        Each sub-class of chart must implement this action separately.

        Attribute: Returns the Scalable Vector Graphics (SVG) text.
    */
    action ConvertToScalableVectorGraphics returns text
        return ""
    end

    /*
        This action saves this chart to disk at the position of the current file. To conduct the 
        conversion, the file extension is used. Only Scalable Vector Graphics (SVG) is currently 
        supported.

        Attribute: Parameter file the location of where to save the file.
    */
    action Save(File file)
        if file:GetFileExtension() = "svg"
            text value = ConvertToScalableVectorGraphics()
            file:Write(value)
        end
    end

    /*
        This is a helper action for saving that saves at the path relative to the current working directory.

        Attribute: Parameter path the path relative to the working directory.
    */
    action Save(text path)
        File file
        file:SetPath(path)
        Save(file)
    end

    /*  This action creates a default Game object for displaying charts and sets this chart
        as the sole display. It is useful for interacting with charts without creating
        a complex game setup.
    */
    action Display
        ChartDisplay game
        game:SetChart(me)
        game:StartGame()
    end

    /*  This action creates a default Game object for displaying charts and sets this chart
        as the sole display. It is useful for interacting with charts without creating
        a complex game setup.
    */
    action Display(integer width, integer height)
        ChartDisplay game
        game:SetScreenSize(width,height)
        game:SetChart(me)
        game:StartGame()
    end
end