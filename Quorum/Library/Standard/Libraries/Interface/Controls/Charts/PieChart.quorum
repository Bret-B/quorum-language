package Libraries.Interface.Controls.Charts

use Libraries.Game.Graphics.Color
use Libraries.Game.Graphics.ColorGroup
use Libraries.Compute.Math
use Libraries.Interface.Selections.ChartSelection
use Libraries.Interface.Controls.ControlLabel
use Libraries.Interface.Layouts.LayoutProperties
use Libraries.Interface.Views.LabelBoxView
use Libraries.Interface.Layouts.PieChartLayout
use Libraries.Game.Graphics.Font
use Libraries.Game.Graphics.Gradient
use Libraries.Game.Graphics.Drawable
use Libraries.Containers.Array

/*
    The PieChart class is Chart object that inherits from Control and like other
    UI elements it is added to the Game class. 
    The Pie Chart is used to show catergorical data.
    The title label. Any number of slices can be added.

    Attribute: Author Hannah Williams

    Attribute: Example

    use Libraries.Compute.Statistics.DataFrame
    use Libraries.Compute.Statistics.Charts.PieChartCreator
    use Libraries.Interface.Controls.Charts.PieChart
    use Libraries.Game.Game
    
    class Main is Game
        action Main
            StartGame()
        end
    
        action CreateGame
            DataFrame frame
            frame:Load("Data/Data.csv")
            PieChartCreator creator
            creator:AddColumn(2)
        
            PieChart chart = cast(PieChart,frame:CreateChart(creator))
            Add(chart)
        end
    end
*/

class PieChart is Chart
    private ChartItem summary // The Root ChartItem.
    Array<Drawable> slices
    Array<number> sliceValues

    Color highlightColor = undefined
    ColorGroup previousColorGroup = undefined
    Color previousColor = undefined

    ChartOptions options
    Math math

    on create
        PieChartLayout layout
        SetLayout(layout)

        LayoutProperties properties = GetDefaultLayoutProperties()
        properties:SetHorizontalLayoutMode(properties:MAINTAIN_ASPECT_RATIO)
        properties:SetVerticalLayoutMode(properties:STANDARD)
        Font font = GetDefaultFont()
        properties:SetFont(font)
        properties:SetFontSize(GetDefaultFontSize())

        Color color
        Gradient gradient
        Color gray = color:LightGray()
        Color lightGray = color:CustomColor(0.9, 0.9, 0.9, 1)
        gradient:Set(gray, gray, lightGray, lightGray)

        properties:SetBackgroundColor(gradient)
        properties:SetBorderColor(color:Black())
        properties:SetBorderThickness(2)
        SetName("Pie Chart")

        SetInputGroup("Chart")
        SetFocusable(true)
        SetAccessibilityCode(parent:Item:ITEM)

        ShowXAxis(false)
        ShowYAxis(false)
    end

    /*
        LoadGraphics
        This action is used to load the graphical components of the Control. This is
        handled automatically by the Game engine as needed, and most users shouldn't
        need to use this action directly.
    */
    action LoadGraphics(LayoutProperties properties)
        DisposeDrawables()
        if properties = undefined
            return now
        end
        parent:Chart:LoadGraphics(properties)

        if GetHighlightColor() = undefined
            SetHighlightColor(options:GetSelectionColor())
        end

        if GetDefaultOrientation() = undefined
            SetDefaultOrientation("vertical")
        end

        LoadChartAreaItems()
    end

    action LoadChartAreaItems()
        Control chartArea = GetChartArea()

        integer i = 0
        repeat while i < slices:GetSize()
            Drawable slice = slices:Get(i)
            slice:SetFocusable(true)
            slice:SetAccessibilityCode(parent:Item:ITEM)
            slice:SetNextFocus(GetNextFocus())
            slice:SetPreviousFocus(GetPreviousFocus())
            chartArea:Add(slice)
            i = i + 1
        end
    end

    /*
        DisposeDrawables
        
        Empties drawables from the chart area.
    */
    action DisposeDrawables()
        parent:Chart:DisposeDrawables()

        GetChartArea():Empty()
    end

    /*
        LostSelection
        This an inherited action from a blueprint in parent Chart class

        Unlike many kinds of user interface controls, there is no universal way of interacting with a chart and, as such, this 
        may be defined by any chart to be custom. As such, charts must be able to take messages suggesting an item in the chart
        has either lost or gained the focus. Broadly speaking, this is done automatically and while charts need to implement
        this action, they do not need to call this action directly.

        Attribute: Parameter ci the ChartItem representing the structure for this particular kind of chart. 
    */
    action LostSelection(ChartItem item)
        if item = undefined
            return now
        end
        Item target = item:GetFocusTarget()

        if target not= undefined
            if target is ControlLabel
                ControlLabel temp = cast(ControlLabel, target)
                temp:LostSelection()
            elseif target is Series
                Series temp = cast(Series, target)
                integer i = 0
                repeat while i < temp:GetSize()
                    Drawable tempitem = temp:GetItemAt(i)
                    tempitem:SetColor(previousColor)
                    i = i + 1
                end
                temp:GetLabel():LostSelection()
                temp:GetIcon():SetColor(previousColor)
            elseif target is Control
                Control temp = cast(Control, target)
                LayoutProperties properties = temp:GetDefaultLayoutProperties()
                if properties not= undefined
                    LabelBoxView view
                    view:SetBorderThickness(cast(integer, properties:GetBorderThickness()))
                    view:Initialize(properties:GetBackgroundColor(), previousColorGroup)
                    temp:SetView2D(view)
                end
            end
        end
    end

    /* 
        GainedSelection
        This an inherited action from a blueprint in parent Chart class

        Unlike many kinds of user interface controls, there is no universal way of interacting with a chart and, as such, this 
        may be defined by any chart to be custom. As such, charts must be able to take messages suggesting an item in the chart
        has either lost or gained the focus. Broadly speaking, this is done automatically and while charts need to implement
        this action, they do not need to call this action directly.

        Attribute: Parameter ci the ChartItem representing the structure for this particular kind of chart. 
    */
    action GainedSelection(ChartItem item)
        if item = undefined
            return now
        end
        Item target = item:GetFocusTarget()

        if target not= undefined
            target:Focus()
            if target is ControlLabel
                ControlLabel temp = cast(ControlLabel, target)
                temp:GainedSelection()
            elseif target is Series
                Series temp = cast(Series, target)
                previousColor = temp:GetColor()
                integer i = 0
                repeat while i < temp:GetSize()
                    Drawable tempitem = temp:GetItemAt(i)
                    tempitem:SetColor(GetHighlightColor())
                    i = i + 1
                end
                temp:GetLabel():GainedSelection()
                temp:GetIcon():SetColor(GetHighlightColor())
            elseif target is Control
                Control temp = cast(Control, target)
                LayoutProperties properties = temp:GetDefaultLayoutProperties()
                if properties not= undefined
                    previousColorGroup = properties:GetBorderColor()
                    LabelBoxView view
                    view:SetBorderThickness(cast(integer, properties:GetBorderThickness())+4)
                    view:Initialize(properties:GetBackgroundColor(), GetHighlightColor())
                    temp:SetView2D(view)
                end
            end            
        end
    end


    /*
        Gets the default selection color (highlighting)
    */
    action GetHighlightColor returns Color
        return highlightColor
    end

    /*
        Sets the default selection color (highlighting)
    */
    action SetHighlightColor(Color color)
        me:highlightColor = color
    end

    action SetSlices(Array <Drawable> slices)
        me:slices = slices
    end

    action GetSlices returns Array <Drawable> 
        return slices
    end

    action SetSliceValues(Array <number> sliceValues)
        me:sliceValues = sliceValues
    end

    action GetSliceValues returns Array <number> 
        return sliceValues
    end

    /*
        This is called by GenerateInfoTree to generate the summary that is heard when
        you first focus on the chart. Also the highest level of the information tree
        of  the chart.
    */
    action GenerateSummary returns text
        SetDescription("This is a pie chart")
        return GetDescription()
    end

    /*
        GenerateInfoTree
        Generates the tree of ChartItems that define how the chart will be 
        navigated and what extra information might be sent to the screen reader.
    */
    action GenerateInfoTree
        if GetDefaultLayoutProperties():NeedsRendering()
            return now //we haven't loaded graphics yet, so bail.
        end
        
        //NOTE: These nodes implement a cheap form of ordinality might need changing
        ChartItem xAxis
        ChartItem yAxis
        ChartItem chartArea //not to be confused with panels
        
        // The chart area is the child unless y-axis is showing.
        summary:SetDisplayName(GenerateSummary())
        summary:SetNext(chartArea)
        summary:SetChild(chartArea)
        summary:SetContainer(me)
        summary:SetFocusTarget(me)
        chartArea:SetFocusTarget(me:GetChartArea())
        chartArea:SetParent(summary)
        chartArea:SetContainer(me)

        chartArea:SetDisplayName("Pie Chart")
    
        // If any of these are not showing the tree will skip them in the navigation        
        if IsShowingYAxis()
            GetVerticalPanel():GenerateInfoTree(me, summary, chartArea, yAxis, xAxis)
        end
        if IsShowingXAxis()
            GetHorizontalPanel():GenerateInfoTree(me, summary, chartArea, yAxis, xAxis)
        end
        if IsShowingLegend()
            GetLegend():GenerateInfoTree(me, summary, chartArea, yAxis, xAxis)
        end
        
        ChartSelection selection = GetSelection()
        selection:Set(summary)
            
    end //end of Genarate infotree
   
    /* 
        This action converts this chart to a text value that contains information 
        for a scalable vector graphics file. This is useful for saving charts to disk.
        Each sub-class of chart must implement this action separately.

        Attribute: Returns the Scalable Vector Graphics (SVG) text.
    */
//    action ConvertToScalableVectorGraphics returns text
//        PieChartWriter writer
//        return writer:WriteOutChart(me)
//    end
end