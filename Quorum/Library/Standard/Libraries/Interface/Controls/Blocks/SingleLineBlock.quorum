package Libraries.Interface.Controls.Blocks

use Libraries.Interface.Layouts.LayoutProperties
use Libraries.Interface.Views.SingleLineBlockView
use Libraries.Language.Compile.CompilerError
use Libraries.Language.Compile.Hints.Hint

class SingleLineBlock is Block

    action LoadGraphics(LayoutProperties properties)
        if GetView2D() = undefined
            UpdateHintsAndErrorsVisuals()
        end

        parent:Control:LoadGraphics(properties)
    end

    /*
    Nests a block into this block. This is illegal for single line blocks. For multi-line blocks,
    only multi-line block parts can be added. Multi-line block parts can accept either single or
    multi-line blocks (as contents of a scope).
    */
    private action AddChildBlock(Block block)
        alert("I was asked to add a block named " + block:GetName() + " to the block named " + GetName() + ", but single line blocks can't have children blocks.")
    end

    /*
    Nests a block into this block. This is illegal for single line blocks. For multi-line blocks,
    only multi-line block parts can be added. Multi-line block parts can accept either single or
    multi-line blocks (as contents of a scope).
    */
    private action AddChildBlock(integer index, Block block)
        alert("I was asked to add a block named " + block:GetName() + " to the block named " + GetName() + ", but single line blocks can't have children blocks.")
    end

    action RemoveChildBlock(Block block) returns boolean
        return false
    end

    action RemoveChildBlock(integer index) returns Block
        return undefined
    end

    action EmptyChildBlocks
    end

    action GetChildCount returns integer
        return 0
    end

    action GetChild(integer index) returns Block
        alert("I could not get a child node from the block " + GetName() + " because single line blocks cannot have children blocks.")
    end

    /*
        The broad design philophy here is to make it feel like a text editor, but to have tree-like mechanisms
        as clues when traversing. Broadly, if we land only on a scoped item, it will give you the level
        count and the number of children at the same level. You can then use hotkeys to traverse those points.
        The level is only given if IsEnteringScope is true, which means the top of an if statement or
        other scoped construct.
    */
    action GetDescription returns text
        text result = ""
        integer scope = GetScopeDepth()
        integer kids = GetChildCount()
        //only for scoped items, otherwise it tends to feel subjectively annoying in a screen reader.
        if scope > 1 and IsEnteringScope()
            result = ", level " + (scope - 1)
        end
        
        if kids = 1
            result = result + ", " + GetChildCount() + " block"
        elseif kids > 1
            result = result + ", " + GetChildCount() + " blocks"
        elseif kids = 0 and IsEnteringScope()
            result = result + ", 0 blocks"
        end
        
        boolean hints = IsHintsEmpty()
        boolean errors = IsErrorsEmpty()

        //if there's an error, put it in the description
        if not errors
            CompilerError error = GetFirstError()
            if error not= undefined
                if not hints //there's a hint and an error
                    result = ", ERROR. " + error:GetErrorMessage()
                else
                    result = ", ERROR + HINT. " + error:GetErrorMessage()
                end
            end
        end

        if not hints
            result = result + ", HINT. "
            Hint hint = GetFirstHint()
            if hint not= undefined
                result = result + hint:GetDisplayName()
            end
            result = result + " Press alt + enter to use the hint or the context menu to get a list"
        end
        return result
    end

    action GetName returns text
        CodeEditor editor = GetEditor()
        if GetStartIndex() >= 0 and GetEndIndex() >= 0 and editor not= undefined
            check
               return editor:GetCode():GetText(GetStartIndex(), GetEndIndex())
            detect error
                return parent:Item:GetName()
            end
        end
        return parent:Item:GetName()
    end
end