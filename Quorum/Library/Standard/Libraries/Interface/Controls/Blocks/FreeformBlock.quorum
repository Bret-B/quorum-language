package Libraries.Interface.Controls.Blocks

use Libraries.Interface.Controls.Blocks.EditRegion
use Libraries.Interface.Options.BlockOptionConstants
use Libraries.Interface.Controls.Layouts.SingleLineBlockLayout
use Libraries.Interface.Events.TextInputEvent
use Libraries.Interface.Events.FocusEvent
use Libraries.Language.Compile.Parsing.QuorumParser
use Libraries.Language.Compile.Context.StartContext
use Libraries.Language.Compile.CompilerErrorManager
use Libraries.Language.Compile.Parsing.QuorumLexer
use Libraries.Language.Compile.Blocks.ParserToBlockListener
use Libraries.Language.Compile.Context.StatementContext
use Libraries.Language.Compile.Context.ClassStatementsContext
use Libraries.Interface.Controls.Blocks.FreeformBlockListener
use Libraries.Language.Compile.Context.OutputContext
use Libraries.Language.Compile.Context.ParseContext
use Libraries.Language.Compile.Location
use Libraries.Game.Graphics.Color
use Libraries.Interface.Views.BlockErrorShaderView
use Libraries.Interface.Views.SingleLineBlockView
use Libraries.Interface.Controls.Blocks.EditBox
use Libraries.Interface.Controls.Blocks.Block
use Libraries.Language.Compile.Parsing.Token
use Libraries.Language.Compile.Parsing.TokenIterator
use Libraries.Language.Compile.Parsing.QuorumLexerConstants
use Libraries.Language.Compile.Context.PackageContext
use Libraries.Language.Compile.Context.UseContext

class FreeformBlock is SingleLineBlock
    FreeformBlockListener blockListener
    EditBox editRegion = undefined

    on create
        BlockOptionConstants constants
        SetInterfaceOptionsKey(constants:FREEFORM_KEY)

        SingleLineBlockLayout layout
        SetLayout(layout)

        SetName("Freeform Block")
    end

    action SetupElements
        CodeEditor editor = GetEditor()
        number spacing = editor:GetDefaultGlyphWidth()
        SetLeftPadding(spacing * 0.5)
        SetRightPadding(spacing * 0.5)

        EditBox edit
        editRegion = edit
        Add(editRegion) 

        editRegion:Setup("Free Text", 0, GetEndIndex() - GetStartIndex())
    end

    action UpdateName(integer line)
        SetName(editRegion:GetText())
    end

    action ReceivedTextInput(TextInputEvent event)
        editRegion:Focus()
        editRegion:SetCaretPosition(0)
        editRegion:Insert(event:GetText())
    end

    action GetEditBox returns EditBox
        return editRegion
    end

    action LostSelection
        ParseToBlock()
        parent:Control:LostSelection()
    end

    action GetName returns text
        if editRegion not= undefined and editRegion:GetSize() = 0
            return "Blank"
        else
            return parent:SingleLineBlock:GetName()
        end
    end



    /*
    This action attempts to parse the content of the FreeformBlock and convert it into a suitable block.
    If a suitable block is found, it will replace this FreeformBlock in the editor.
    */
    action ParseToBlock
        text code = editRegion:GetText()
        text newLine = editRegion:GetDefaultLineSeparator()
        text dq = code:GetDoubleQuote()
        if code = undefined or code = "" or GetParentBlock() = undefined
            return now
        end

        CodeEditor editor = GetEditor()
        if editor:GetFailState()
            editor:SetCode(editor:GetCode())
            return now
        end
        /*
        First check special cases where the user has typed a short-cut.
        If so, insert extra code to make it valid before we parse it.
        */
        CompilerErrorManager errorManager
        QuorumLexer shortcutLexer
        shortcutLexer:SetCompilerErrorManager(errorManager)
        shortcutLexer:Read(code)
        
        // If there's an error, set the block to reflect it, then bail.
        if not errorManager:IsCompilationErrorFree()
            // TO-DO: Set error state visuals
            BlockErrorShaderView view
            view:Initialize()
            SetView2D(view)
            return now
        end
    // output
        TokenIterator<Token> tokenIterator
        tokenIterator:SetLexer(shortcutLexer)
        Token current = tokenIterator:Next()
        QuorumLexerConstants constants
        isPackageStatement = false
        isUseStatement = false


        // since we ignore white space the shortcuts will overwrite the text to guarantee spacing

        if current:category = constants:OUTPUT and not tokenIterator:HasNext()
            editRegion:SetCaretPosition(editRegion:GetSize())
            editRegion:SetText("output " + dq + dq)
            code = editRegion:GetText()

    //  input
        elseif current:category = constants:INPUT and not tokenIterator:HasNext()
            editRegion:SetCaretPosition(editRegion:GetSize())
            editRegion:SetText("text myInput = input()")
            code = editRegion:GetText()
    //  integer
        elseif current:category = constants:INTEGER_KEYWORD and not tokenIterator:HasNext()
            editRegion:SetCaretPosition(editRegion:GetSize())
            editRegion:SetText("integer " + "myInteger" + " = 0")
            code = editRegion:GetText()
    //  number
        elseif current:category = constants:NUMBER_KEYWORD and not tokenIterator:HasNext()
            editRegion:SetCaretPosition(editRegion:GetSize())
            editRegion:SetText("number " + "myNumber" + " = 0.0")
            code = editRegion:GetText()
    //  boolean
        elseif current:category = constants:BOOLEAN_KEYWORD and not tokenIterator:HasNext()
            editRegion:SetCaretPosition(editRegion:GetSize())
            editRegion:SetText("boolean " + "myBoolean" + " = false")
            code = editRegion:GetText()
    //  text
        elseif current:category = constants:TEXT and not tokenIterator:HasNext()
            editRegion:SetCaretPosition(editRegion:GetSize())
            editRegion:SetText("text " + "myText" + " = "+dq+dq)
            code = editRegion:GetText()
    //  say
        elseif current:category = constants:SAY and not tokenIterator:HasNext()
            editRegion:SetCaretPosition(editRegion:GetSize())
            editRegion:SetText("say " + dq + dq)
            code = editRegion:GetText()
    //  return (now for void or with a field if it does)
        elseif current:category = constants:RETURN and not tokenIterator:HasNext()
            editRegion:SetCaretPosition(editRegion:GetSize())
            Block parentBlock = GetParentBlock()
            repeat until parentBlock is ActionBlock or parentBlock = undefined
                parentBlock = parentBlock:GetParentBlock()
            end
            if parentBlock not= undefined
                ActionBlock parentAction = cast(ActionBlock, parentBlock)
                if parentAction:HasReturn()
                    editRegion:SetText("return undefined")
                else
                    editRegion:SetText("return now")
                    code = editRegion:GetText()
                end
            end
    // if
        elseif current:category = constants:IF and not tokenIterator:HasNext()
            editRegion:SetCaretPosition(editRegion:GetSize())
            text value = "if true" + newLine + editor:GetIndentationText(GetScopeDepth()) + "end"
            editRegion:SetText(value)
            code = editRegion:GetText()
    // if (condition)
        elseif code:StartsWith("if") = true and code:EndsWith("end") = false
            editRegion:SetCaretPosition(editRegion:GetSize())
            text value = newLine + editor:GetIndentationText(GetScopeDepth()) + "end"
            editRegion:Insert(value)
            code = editRegion:GetText()
    //  elseif
        elseif code = "elseif"
            editRegion:SetCaretPosition(editRegion:GetSize())
            editRegion:Insert(" false")
            Block grandparent = GetParentBlock():GetParentBlock()
            if grandparent not= undefined and grandparent is IfBlock
                IfBlock ifParent = cast(IfBlock, grandparent)
                ifParent:AddElseifLineFromFreeform(me, " false")
                
            else
                // TO-DO: Set error state visuals
                BlockErrorShaderView view
                view:Initialize()
                SetView2D(view)
                return now
            end 
    //  else
    //  repeat - by default it's times
    //  repeat while
    //  repeat while i (or some name) - maybe
    //  repeat until
    //  repeat until i (or some name) - maybe
        elseif current:category = constants:REPEAT
            if not tokenIterator:HasNext()
                editRegion:SetCaretPosition(editRegion:GetSize())
                editRegion:SetText("repeat 1 times" + newLine + editor:GetIndentationText(GetScopeDepth()) + "end")
                code = editRegion:GetText()
            else
                current = tokenIterator:Next()
                boolean hasExpression = true
                
                if current:category = constants:WHILE
                    if not tokenIterator:HasNext()
                        editRegion:SetCaretPosition(editRegion:GetSize())
                        editRegion:SetText("repeat while false" + newLine + editor:GetIndentationText(GetScopeDepth()) + "end")
                        code = editRegion:GetText()
                        hasExpression = false
                    end
                    tokenIterator:Next()
                elseif current:category = constants:UNTIL
                    if not tokenIterator:HasNext()
                        editRegion:SetCaretPosition(editRegion:GetSize())
                        editRegion:SetText("repeat until true" + newLine + editor:GetIndentationText(GetScopeDepth()) + "end")
                        code = editRegion:GetText()
                        hasExpression = false
                    end
                    tokenIterator:Next()
                end
                // there is an expression here
                if hasExpression
                    
//                    QuorumParser parser
//                    parser:SetCompilerErrorManager(errorManager)
//                    parser:SetLexer(shortcutLexer)
//                    ParseContext context = parser:Expression()
//
//                    if context not= undefined
//                        if 
//                    end
                end
            end
    //  check
        elseif current:category = constants:CHECK
            editRegion:SetCaretPosition(editRegion:GetSize())
            text value ="check" + newLine + editor:GetIndentationText(GetScopeDepth()) + "detect error" + newLine +  editor:GetIndentationText(GetScopeDepth()) + "end"
            editRegion:SetText(value)
            code = editRegion:GetText()
        
    //  detect
    //  always
    //  action
    //  blueprint
    //  system
    //  class
    //  shared
    // other
        elseif current:category = constants:PACKAGE_NAME
            isPackageStatement = true
        elseif current:category = constants:USE
            isUseStatement = true
        end

        /*
        Read the code, and if it's valid, try to parse it.
        */
        CompilerErrorManager manager
        QuorumLexer lexer
        lexer:SetCompilerErrorManager(manager)
        lexer:Read(code)
        
        // If there's an error, set the block to reflect it, then bail.
        if not manager:IsCompilationErrorFree()
            // TO-DO: Set error state visuals
            BlockErrorShaderView view
            view:Initialize()
            SetView2D(view)
            return now
        end

        QuorumParser parser
        parser:SetCompilerErrorManager(manager)
        parser:SetLexer(lexer)

        // Set the initial information for the listener. This gives it offset info it needs to calculate correct values.
        blockListener:SetSourceBlock(me)

        /*
        If the freeform block is attached to a class, we need to parse a class statement,
        which might be a full on action declaration.
        We can check for this by testing if our grandparent is a class block (which can only
        hold if our direct parent is one of the block parts of the class block).
        */
        if GetParentBlock() is MultipleLineBlockPart and GetParentBlock():GetParentBlock() is ClassBlock
            ClassStatementsContext statement = parser:ClassStatement()

            if statement not= undefined
                blockListener:EnterClassStatements(statement)
            end
        elseif isPackageStatement
            PackageContext context = parser:Package()
            if context not= undefined
                blockListener:EnterPackageRule(context)
            end
        elseif isUseStatement
            UseContext context = parser:Use()
            if context not= undefined
                blockListener:EnterUse(context)
            end
        else
            // If we're not in a class, parse for a standard statement. 
            // If you KNOW you are inside of an action, you use this
            StatementContext statement = parser:Statement()

            if statement not= undefined
                blockListener:EnterStatement(statement)
            end
        end

        // Once again, if there's an error, set the block to reflect it, then bail.
        if not manager:IsCompilationErrorFree()
            // TO-DO: Set error state visuals
            BlockErrorShaderView view
            view:Initialize()
            SetView2D(view)
            return now
        end

        // Once we've parsed, the listener will give us a block (if there's a valid option). It's stored here.
        Block result = blockListener:GetBlock()

        // If we have a valid block, replace this Freeform block with the new one.
        if result not= undefined
            editor:Replace(me, result)
        end
    end

end