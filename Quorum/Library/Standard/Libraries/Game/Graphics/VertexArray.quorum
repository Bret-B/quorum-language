package Libraries.Game.Graphics

use Libraries.Containers.Number32BitArray
use Libraries.Game.Graphics.VertexData
use Libraries.Containers.Array
use Libraries.Game.Graphics.Shaders.ShaderProgram
use Libraries.Game.GameStateManager

class VertexArray is VertexData
  
    VertexAttributes attributes = undefined
    Number32BitBuffer buffer
    boolean isBound = false
    GameStateManager manager

    on create
        alert("Created the Forbidden Class")
    end

    /*
    This action will initialize the VertexArray to use the given number of
    vertices and to use the provided VertexAttributes.
    */
    action Load(integer numVertices, VertexAttributes attributes)
        me:attributes = attributes
        buffer:SetSize(attributes:vertexSize * numVertices / 4)
        buffer:SetWritePosition(0, buffer:GetSize())
    end

    /*
    This action releases the memory stored by this VertexData. This should only
    be used when the VertexData is not in use and will not be needed again!
    */
    action Dispose
        buffer:Dispose()
    end

    action GetBuffer returns Number32BitBuffer
        return buffer
    end

    /*
    This action returns the number of vertices currently stored in this
    VertexData object.
    */
    action GetSize returns integer
        return (buffer:GetSize() * 4) / attributes:vertexSize
    end

    /*
    This action returns the maximum number of vertices that can be stored in
    this VertexData object.
    */
    action GetMaxSize returns integer
        return (buffer:GetMaxSize() * 4) / attributes:vertexSize
    end

    action Get(integer index) returns number
        alert("NYI")
    end

    /*
    This action will return the VertexAttributes that describe this VertexData.
    */
    action GetAttributes returns VertexAttributes
        return attributes
    end

    action UpdateVertices(integer targetOffset, Number32BitArray vertices, integer sourceOffset, integer count)
        buffer:Set(targetOffset, vertices, sourceOffset, count)
    end
    
    action SetVertices(Number32BitArray vertices)
        buffer:Set(vertices)
    end

    /*
    Used to invalidate the data when applicable, e.g. due to context loss.
    */
    action Reload
        // Do nothing. The VertexArray doesn't require manual reloading.
    end

    action Bind(ShaderProgram program)
        Bind(program, undefined)
    end

    action Bind(ShaderProgram program, Array<integer> locations)
        GraphicsManager graphics = manager:GetGameGraphics()
        integer attributeCount = attributes:GetSize()

        if locations = undefined
            integer i = 0
            repeat while i < attributeCount
                VertexAttribute attribute = attributes:GetAttribute(i)
                integer location = program:GetVertexInputLocation(attribute:alias)

                if location >= 0
                    program:EnableVertexInput(location)

                    // TO-DO: Reevaluate if this needs to be handled in separate cases for GL_FLOAT vs. other types.
                    // This is just the GL_FLOAT case, but it should work for all elements in the buffer (which should be 4 bytes long)
//                    buffer:SetWritePosition(attribute:offset / 4)
//                    program:SetVertexInputInformation(location, attribute:componentCount, attribute:type, attribute:normalized, attribute:vertexSize, buffer)

                end

                i = i + 1
            end
        else

        end
    end

    action Unbind(ShaderProgram program)
        Unbind(program, undefined)
    end

    action Unbind(ShaderProgram program, Array<integer> locations)

    end

    /*
    public void Bind(final ShaderProgram shader, final int[] locations) 
    {
        final GraphicsManager gl = GameStateManager.nativeGraphics;
        final int numAttributes = attributes.GetSize();
        byteBuffer.limit(buffer.limit() * 4);
        if (locations == null) 
        {
            for (int i = 0; i < numAttributes; i++) 
            {
                final VertexAttribute_ attribute = attributes.GetAttribute(i);
                final int location = shader.GetAttributeLocation(attribute.Get_Libraries_Game_Graphics_VertexAttribute__alias_());
                if (location < 0)
                    continue;

                shader.EnableVertexAttribute(location);

                if (attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_() == GraphicsManager.GL_FLOAT) 
                {
                    buffer.position(attribute.Get_Libraries_Game_Graphics_VertexAttribute__offset_() / 4);
                    shader.SetVertexAttribute(location, attribute.Get_Libraries_Game_Graphics_VertexAttribute__componentCount_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__normalized_(),
                        attributes.Get_Libraries_Game_Graphics_VertexAttributes__vertexSize_(),
                        buffer);
                }
                else
                {
                    byteBuffer.position(attribute.Get_Libraries_Game_Graphics_VertexAttribute__offset_());
                    shader.SetVertexAttribute(location, attribute.Get_Libraries_Game_Graphics_VertexAttribute__componentCount_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__normalized_(),
                        attributes.Get_Libraries_Game_Graphics_VertexAttributes__vertexSize_(),
                        byteBuffer);
                }
            }
        } 
        else 
        {
            for (int i = 0; i < numAttributes; i++) 
            {
                final VertexAttribute_ attribute = attributes.GetAttribute(i);
                final int location = locations[i];
                if (location < 0)
                    continue;

                shader.EnableVertexAttribute(location);

                if (attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_() == GraphicsManager.GL_FLOAT) 
                {
                    buffer.position(attribute.Get_Libraries_Game_Graphics_VertexAttribute__offset_() / 4);
                    shader.SetVertexAttribute(location, attribute.Get_Libraries_Game_Graphics_VertexAttribute__componentCount_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__normalized_(),
                        attributes.Get_Libraries_Game_Graphics_VertexAttributes__vertexSize_(), buffer);
                }
                else 
                {
                    byteBuffer.position(attribute.Get_Libraries_Game_Graphics_VertexAttribute__offset_());
                    shader.SetVertexAttribute(location, attribute.Get_Libraries_Game_Graphics_VertexAttribute__componentCount_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_(), 
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__normalized_(),
                        attributes.Get_Libraries_Game_Graphics_VertexAttributes__vertexSize_(),
                        byteBuffer);
                }
            }
        }
        isBound = true;
    }

    @Override
    public void Unbind(ShaderProgram shader) 
    {
        Unbind(shader, null);
    }

    @Override
    public void Unbind(ShaderProgram shader, int[] locations) 
    {
        final GraphicsManager gl = GameStateManager.nativeGraphics;
        final int numAttributes = attributes.GetSize();
        if (locations == null) 
        {
            for (int i = 0; i < numAttributes; i++) 
            {
                shader.DisableVertexAttribute(attributes.GetAttribute(i).Get_Libraries_Game_Graphics_VertexAttribute__alias_());
            }
        }
        else 
        {
            for (int i = 0; i < numAttributes; i++) 
            {
                final int location = locations[i];
                if (location >= 0)
                    shader.DisableVertexAttribute(location);
            }
        }
        isBound = false;
    }

    public void Bind(ShaderProgram_ shader)
    {
        Bind(shader, null);
    }

    public void Bind(ShaderProgram_ shader, int[] locations)
    {
        final GraphicsManager gl = GameStateManager.nativeGraphics;
        final int numAttributes = attributes.GetSize();
        byteBuffer.limit(buffer.limit() * 4);
        if (locations == null) 
        {
            for (int i = 0; i < numAttributes; i++) 
            {
                final VertexAttribute_ attribute = attributes.GetAttribute(i);
                final int location = shader.GetVertexInputLocation(attribute.Get_Libraries_Game_Graphics_VertexAttribute__alias_());
                if (location < 0)
                    continue;

                gl.glEnableVertexAttribArray(location);

                if (attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_() == GraphicsManager.GL_FLOAT) 
                {
                    buffer.position(attribute.Get_Libraries_Game_Graphics_VertexAttribute__offset_() / 4);
                    gl.glVertexAttribPointer(location, attribute.Get_Libraries_Game_Graphics_VertexAttribute__componentCount_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__normalized_(),
                        attributes.Get_Libraries_Game_Graphics_VertexAttributes__vertexSize_(),
                        buffer);
                }
                else
                {
                    byteBuffer.position(attribute.Get_Libraries_Game_Graphics_VertexAttribute__offset_());
                    gl.glVertexAttribPointer(location, attribute.Get_Libraries_Game_Graphics_VertexAttribute__componentCount_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__normalized_(),
                        attributes.Get_Libraries_Game_Graphics_VertexAttributes__vertexSize_(),
                        byteBuffer);
                }
            }
        } 
        else 
        {
            for (int i = 0; i < numAttributes; i++) 
            {
                final VertexAttribute_ attribute = attributes.GetAttribute(i);
                final int location = locations[i];
                if (location < 0)
                    continue;

                gl.glEnableVertexAttribArray(location);

                if (attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_() == GraphicsManager.GL_FLOAT) 
                {
                    buffer.position(attribute.Get_Libraries_Game_Graphics_VertexAttribute__offset_() / 4);
                    gl.glVertexAttribPointer(location, attribute.Get_Libraries_Game_Graphics_VertexAttribute__componentCount_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__normalized_(),
                        attributes.Get_Libraries_Game_Graphics_VertexAttributes__vertexSize_(), buffer);
                }
                else 
                {
                    byteBuffer.position(attribute.Get_Libraries_Game_Graphics_VertexAttribute__offset_());
                    gl.glVertexAttribPointer(location, attribute.Get_Libraries_Game_Graphics_VertexAttribute__componentCount_(),
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__type_(), 
                        attribute.Get_Libraries_Game_Graphics_VertexAttribute__normalized_(),
                        attributes.Get_Libraries_Game_Graphics_VertexAttributes__vertexSize_(),
                        byteBuffer);
                }
            }
        }
        isBound = true;
    }

    public void Unbind(ShaderProgram_ shader)
    {
        Unbind(shader, null);
    }

    public void Unbind(ShaderProgram_ shader, int[] locations)
    {
        final GraphicsManager gl = GameStateManager.nativeGraphics;
        final int numAttributes = attributes.GetSize();
        if (locations == null) 
        {
            for (int i = 0; i < numAttributes; i++) 
            {
                gl.glDisableVertexAttribArray(shader.GetVertexInputLocation(attributes.GetAttribute(i).Get_Libraries_Game_Graphics_VertexAttribute__alias_()));
            }
        }
        else 
        {
            for (int i = 0; i < numAttributes; i++) 
            {
                final int location = locations[i];
                if (location >= 0)
                    gl.glDisableVertexAttribArray(location);
            }
        }
        isBound = false;
    }
    

    */

end