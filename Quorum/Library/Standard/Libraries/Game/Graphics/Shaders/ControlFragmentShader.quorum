package Libraries.Game.Graphics.Shaders

class ControlFragmentShader is Shader

    constant text SHADER_NAME = "Control Fragment Shader"

    on create
        SetName(SHADER_NAME)
        SetType(parent:Shader:FRAGMENT_SHADER)
        SetCode(GetOpenGLVersion() +
"
" +
"#ifdef GL_ES
    #define LOWP lowp
    precision mediump float;
#else
    #define LOWP 
#endif
in LOWP vec4 v_color;
in vec2 v_texCoords;
uniform sampler2D u_texture;
uniform vec4 u_rounding;
uniform vec4 u_enabledBorders;
uniform vec4 u_borderColor;
uniform float u_borderThickness;
layout (location = 0) out vec4 outputColor;

// Calculate how far a point is from the outer shell of a rounded rectangle.
// The rounding vector contains edge roundness values for:
// x: top-right
// y: bottom-right
// z: top-left
// w: bottom-left
float signedDistanceFunction(in vec2 point, in vec2 dimensions, in vec4 rounding)
{
    // We calculate as though the point is in the top-right quadrant.
    // If this isn't true, we need adjust which of the edge rounding values we use.
    rounding.xy = (point.x > 0.0) ? rounding.xy : rounding.zw;
    rounding.x = (point.y > 0.0) ? rounding.x : rounding.y;
    
    // We take the absolute value of the point to ensure we're calculating from the top-right quadrant
    vec2 calc = abs(point) - dimensions + rounding.x;
    return min(max(calc.x, calc.y), 0.0) + length(max(calc, 0.0)) - rounding.x;
}

void main()
{
    vec4 fillColor = vec4(1, 1, 1, 1);

    vec2 point = (v_texCoords.xy - 0.5) * 2;
    vec2 dimensions = vec2(1.0, 1.0);

    float distance = signedDistanceFunction(point, dimensions, u_rounding);

    // The enabled borders vector stores values for the sides in the following order:
    // x: right
    // y: top (y-positive: technically the bottom due to how GLSL handles texture coordinates)
    // z: left
    // w: bottom (y-negative)
    vec4 borderDepths = vec4(u_enabledBorders.x * u_borderThickness, u_enabledBorders.y * u_borderThickness, u_enabledBorders.z * u_borderThickness, u_enabledBorders.w * u_borderThickness);
    vec2 fillPoint = point - vec2(borderDepths.x - borderDepths.z, borderDepths.y - borderDepths.w);
    vec2 fillDimensions = vec2(1.0 - borderDepths.x - borderDepths.z, 1.0 - borderDepths.y - borderDepths.w);
    float fillDistance = signedDistanceFunction(fillPoint, fillDimensions, u_rounding);

    vec4 resultColor = (distance > 0.0) ? vec4(u_borderColor.r, u_borderColor.g, u_borderColor.b, 0.0) : (fillDistance > 0) ? u_borderColor * texture(u_texture, v_texCoords) : v_color * texture(u_texture, v_texCoords) * fillColor;

    

    //float antiAliasThreshold = -2.0 / 400.0;
    //
    //if (distance < 0 && distance > antiAliasThreshold)
    //{
    //    resultColor = mix(vec4(u_borderColor.r, u_borderColor.g, u_borderColor.b, 0.0), resultColor, distance / antiAliasThreshold);
    //}

    outputColor = resultColor;
}")
    end

end