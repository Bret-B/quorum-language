package Libraries.Game.Graphics

use Libraries.Containers.Number32BitArray
use Libraries.Containers.Integer32BitArray
use Libraries.Compute.Matrix3
use Libraries.Compute.Matrix4
use Libraries.Compute.Vector2
use Libraries.Compute.Vector3
use Libraries.Game.BoundingBox
use Libraries.Containers.Array
use Libraries.Game.Disposable
use Libraries.Game.Graphics.IndexBufferObject
use Libraries.Game.Graphics.VertexBufferObject
use Libraries.Game.Graphics.IndexArray
use Libraries.Game.Graphics.VertexArray
use Libraries.Game.Graphics.Shaders.ShaderProgram
use Libraries.Game.GameStateManager

class Mesh is Disposable

    VertexData vertices = undefined
    IndexData indices = undefined
    boolean autoBind = true
    boolean isVertexArray = false
    GameStateManager manager

    on create
        SetQuorumReference(me)
    end

    action Load(VertexData vertices, IndexData indices, boolean isVertexArray)
        me:vertices = vertices
        me:indices = indices
        me:isVertexArray = isVertexArray

        AddReloadableMesh()
    end

    action Load(boolean isStatic, integer maxVertices, integer maxIndices, VertexAttributes attributes)
        vertices = MakeVertexBuffer(isStatic, maxVertices, attributes)
        IndexBufferObject index
        index:Load(isStatic, maxIndices)
        indices = index
        isVertexArray = false

        AddReloadableMesh()
    end

    action Load(boolean isStatic, integer maxVertices, integer maxIndices, VertexAttributes attributes, boolean isArray)
        // TO-DO: Change this. Currently hard coding so VertexArrays aren't made
        isArray = false
        if isArray = false
            Load(isStatic, maxVertices, maxIndices, attributes)
            return now
        end

        VertexArray vertexArray
        vertexArray:Load(maxVertices, attributes)
        vertices = vertexArray

        IndexArray indexArray
        indexArray:Load(maxIndices)
        indices = indexArray

        isVertexArray = true
    end

    private action MakeVertexBuffer(boolean isStatic, integer maxVertices, VertexAttributes attributes) returns VertexData
        // if SupportsGL30() return new VertexBufferObjectWithVAO end
        VertexBufferObject temp
        temp:Load(isStatic, maxVertices, attributes)
        return temp
    end

    action SetVertices(Number32BitArray vertices)
       me:vertices:SetVertices(vertices)//, 0, vertices:GetSize()) 
    end

//    action SetVertices(Array<number> vertices)
//       SetVertices(vertices, 0, vertices:GetSize()) 
//    end

//    action SetVertices(Number32BitArray vertices, integer offset, integer count)
//        me:vertices:SetVertices(vertices, offset, count)
//    end

//    action SetVertices(Array<number> vertices, integer offset, integer count)
//        me:vertices:SetVertices(vertices, offset, count)
//    end

    action UpdateVertices(integer targetOffset, Number32BitArray source)
        UpdateVertices(targetOffset, source, 0, source:GetSize())
    end

    action UpdateVertices(integer targetOffset, Number32BitArray source, integer sourceOffset, integer count)
        vertices:UpdateVertices(targetOffset, source, sourceOffset, count)
    end

    action SetIndices(Integer32BitArray indices)
        me:indices:SetIndices(indices, 0, indices:GetSize())
    end

    action SetIndices(Integer32BitArray indices, integer offset, integer count)
        me:indices:SetIndices(indices, offset, count)
    end

    action GetIndicesCount returns integer
        return indices:GetSize()
    end

    action GetVerticesCount returns integer
        return vertices:GetSize()
    end

    action GetMaxIndices returns integer
        return indices:GetMaxSize()
    end

    action GetMaxVertices returns integer
        return vertices:GetMaxSize()
    end

    action Dispose
        vertices:Dispose()
        indices:Dispose()
        RemoveReloadableMesh()
    end

    action GetVertexData returns VertexData
        return vertices
    end

    action GetIndexData returns IndexData
        return indices
    end

    action GetVertexAttributes returns VertexAttributes
        return vertices:GetAttributes()
    end

    /*
    This action will create a new BoundingBox object that will contain all of
    the vertices stored in this Mesh. If no vertices have been defined yet, this
    will alert an error.
    */
    action CalculateBoundingBox returns BoundingBox
        BoundingBox box
        return CalculateBoundingBox(box)
    end

    /*
    This action will calculate the bounds of this Mesh's vertices, and store it
    inside the given BoundingBox. This will overwrite any data in the provided
    BoundingBox. If no vertices have been defined yet for this Mesh, the action
    will alert an error.
    */
    action CalculateBoundingBox(BoundingBox box) returns BoundingBox
        box:Invalidate()

        if GetVerticesCount() = 0
            alert("There were no vertices defines for this Mesh!")
        end

        Number32BitBuffer buffer = GetVertexData():GetBuffer()

        VertexAttribute positionAttribute = GetVertexAttributes():FindByUsage(GetVertexAttributes():POSITION)
        integer offset = positionAttribute:offset / 4
        integer vertexSize = vertices:GetAttributes():vertexSize
        integer index = offset
        integer componentCount = positionAttribute:componentCount

        integer i = 0
        
        if componentCount = 1
            repeat while i < GetVerticesCount()
                box:Extend(buffer:Get(index), 0, 0)
                index = index + vertexSize
                i = i + 1
            end
        elseif componentCount = 2
            repeat while i < GetVerticesCount()
                box:Extend(buffer:Get(index), buffer:Get(index + 1), 0)
                index = index + vertexSize
                i = i + 1
            end
        elseif componentCount = 3
            repeat while i < GetVerticesCount()
                box:Extend(buffer:Get(index), buffer:Get(index + 1), buffer:Get(index + 2))
                index = index + vertexSize
                i = i + 1
            end
            
        end

        return box
    end

    /*
    This action will extend the given BoundingBox to include the vertices of
    this Mesh. If this Mesh has no vertices defined, this action will alert an
    error.
    */
    action ExtendBoundingBox(BoundingBox box, integer offset, integer count, Matrix4 transform) returns BoundingBox
        integer indicesCount = GetIndicesCount()

        if offset < 0
            alert("Attempted to extend bounding box with offset = " + offset + ", but the offset must be greater than 0.")
        elseif count < 1
            alert("I can't extend the bounding box using " + count + " indices -- the count must be >= 1")
        elseif (offset + count > indicesCount)
            alert("Out of bounds: attempted to access the indices between " + offset + " and " + (offset + count) + ", but there are only " + indicesCount + " total indices")
        end

        Number32BitBuffer vertexBuffer = vertices:GetBuffer()
        Integer32BitBuffer indexBuffer = indices:GetBuffer()

        VertexAttribute positionAttribute = GetVertexAttributes():FindByUsage(GetVertexAttributes():POSITION)

        integer positionOffset = positionAttribute:offset / 4
        integer vertexSize = vertices:GetAttributes():vertexSize / 4
        integer stop = offset + count
        integer componentCount = positionAttribute:componentCount

        Vector3 calcVector

        if componentCount = 1
            integer i = offset
            repeat while i < stop
                integer index = indexBuffer:Get(i) * vertexSize + positionOffset
                calcVector:Set(vertexBuffer:Get(index), 0, 0)
                if transform not= undefined
                    calcVector:Multiply(transform)
                end
                
                box:Extend(calcVector)

                i = i + 1
            end
        elseif componentCount = 2
            integer i = offset
            repeat while i < stop
                integer index = indexBuffer:Get(i) * vertexSize + positionOffset
                calcVector:Set(vertexBuffer:Get(index), vertexBuffer:Get(index + 1), 0)
                if transform not= undefined
                    calcVector:Multiply(transform)
                end
                
                box:Extend(calcVector)

                i = i + 1
            end
        elseif componentCount = 3
            integer i = offset
            repeat while i < stop
                integer index = indexBuffer:Get(i) * vertexSize + positionOffset
                calcVector:Set(vertexBuffer:Get(index), vertexBuffer:Get(index + 1), vertexBuffer:Get(index + 2))
                if transform not= undefined
                    calcVector:Multiply(transform)
                end
                
                box:Extend(calcVector)

                i = i + 1
            end
        end

        return box
    end

    action ExtendBoundingBox(BoundingBox box, integer offset, integer count)
        ExtendBoundingBox(box, offset, count, undefined)
    end

    /*
    This action forcibly reloads the Mesh's IndexData and VertexData. This is
    necessary after the OpenGL context is lost. This is automatically performed
    by the engine, so it shouldn't be necessary for users to call this directly.
    */
    action Reload
        indices:Reload()
        vertices:Reload()
    end

    /*
    This action is used during creation to pass a reference of this object down
    to the corresponding plugin class.
    */
    private system action SetQuorumReference(Mesh mesh)

    /*
    Adds this mesh to the static collection of meshes in the plugins, which are
    maintained so that they can be reloaded in case of context loss.
    */
    private system action AddReloadableMesh

    /*
    Removes this mesh from the static collection of meshes in the plugins, which
    are maintained so that they can be reloaded in case of context loss.
    */
    private system action RemoveReloadableMesh

    action Render(ShaderProgram program, integer type, integer offset, integer count)
        Render(program, type, offset, count, autoBind)
    end

    action Render(ShaderProgram program, integer type, integer offset, integer count, boolean autoBind)
        if count = 0
            return now
        end

        if autoBind
            Bind(program)
        end

        GraphicsManager graphics = manager:GetGameGraphics()
        // TO-DO: REMOVE THIS
//        graphics:EnableProperty(graphics:GL_BLEND)

        if isVertexArray
            if indices:GetSize() > 0
                graphics:DrawIndexedBuffer(type, count, graphics:GL_UNSIGNED_INT, offset * 4)
            else
                graphics:DrawBuffer(type, offset, count)
            end
        else
            if indices:GetSize() > 0
                graphics:DrawIndexedBuffer(type, count, graphics:GL_UNSIGNED_INT, offset * 4)
            else
                graphics:DrawBuffer(type, offset, count)
            end
        end

        if autoBind
            Unbind(program)
        end
    end

    action Bind(ShaderProgram program)
        Bind(program, undefined)
    end

    action Bind(ShaderProgram program, Array<integer> locations)
        vertices:Bind(program, locations)
        if indices:GetSize() > 0
            indices:Bind()
        end
    end

    action Unbind(ShaderProgram program)
        Unbind(program, undefined)
    end

    action Unbind(ShaderProgram program, Array<integer> locations)
        vertices:Unbind(program, locations)
        if indices:GetSize() > 0
            indices:Unbind()
        end
    end

    /*
    
    public void Bind(final ShaderProgram_ shader, final int[] locations)
    {
        if (quorumMesh.isVertexArray)
        {
            ((quorum.Libraries.Game.Graphics.VertexArray)quorumMesh.vertices).plugin_.Bind(shader, locations);
            if (quorumMesh.indices.GetSize() > 0)
                ((quorum.Libraries.Game.Graphics.IndexArray)quorumMesh.indices).plugin_.Bind();
        }
        else
        {
            ((quorum.Libraries.Game.Graphics.VertexBufferObject)quorumMesh.vertices).plugin_.Bind(shader, locations);
            if (quorumMesh.indices.GetSize() > 0)
                ((quorum.Libraries.Game.Graphics.IndexBufferObject)quorumMesh.indices).plugin_.Bind();
        }
    }
    
    public void Unbind(final ShaderProgram_ shader)
    {
        Unbind(shader, null);
    }
    
    public void Unbind(final ShaderProgram_ shader, final int[] locations)
    {
        if (quorumMesh.isVertexArray)
        {
            ((quorum.Libraries.Game.Graphics.VertexArray)quorumMesh.vertices).plugin_.Unbind(shader, locations);
            if (quorumMesh.indices.GetSize() > 0)
                ((quorum.Libraries.Game.Graphics.IndexArray)quorumMesh.indices).plugin_.Unbind();
        }
        else
        {
            ((quorum.Libraries.Game.Graphics.VertexBufferObject)quorumMesh.vertices).plugin_.Unbind(shader, locations);
            if (quorumMesh.indices.GetSize() > 0)
                ((quorum.Libraries.Game.Graphics.IndexBufferObject)quorumMesh.indices).plugin_.Unbind();
        }
    }
    */
end