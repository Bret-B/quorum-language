package Libraries.Compute.MatrixTransform

use Libraries.Compute.Matrix
use Libraries.Compute.Vector
use Libraries.Containers.Array
use Libraries.Compute.Math

/*
    An Eigen decomposition is a matrix decomposition of a matrix A into 
    a matrix D and a matrix V such that:
        If A is symmetric then A = V*D*V^(T) 
        If A is not symmetric then A*V = V*D

    More information on Eigen decomposition can be found at 
        <a href="http://mathworld.wolfram.com/EigenDecomposition.html">MathWorld</a> or
        <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">Wikipedia</a>.

    Attribute: Author Hannah Williams
    Attribute: Example

    use Libraries.Compute.Matrix
    use Libraries.Compute.MatrixTransform.EigenDecomposition

    class Main
        action Main
            Matrix matrix
            matrix:Fill(3, 3, 5.0)
            EigenDecomposition decomp
            decomp:Calculate(matrix)
            output decomp:GetEigenvalues():ToText()
        end
    end
*/

class EigenDecomposition
    constant number DEFAULT_EPSILON = 1.0e-12

    /* Maximum allowed iterations for convergence of the transformation. */
    constant integer maxIterations = 30

    /* This matrix represents the original matrix */
    Matrix original = undefined

    /* This matrix represents the eigenvalue matrix (D) */
    Matrix eigenvalueMatrix = undefined

    /* This matrix represents the eigenvector orthogonal matrix (V). */
    Matrix eigenvectorMatrix = undefined

    /* This matrix represents the orthogonal matrix transposed (VT). */
    Matrix eigenvectorTransposedMatrix = undefined

    Array<number> realEigenvalues
    Array<number> imaginaryEigenvalues
    Array<Vector> eigenvectors

    /* This is used if the user explicitly wants to assume symmetry or not */
    boolean symmetric = false
    boolean symmetricOverride = false

    Math math

    action Calculate(Matrix matrix)
        original = matrix
        eigenvalueMatrix = undefined
        eigenvectorMatrix = undefined
        eigenvectorTransposedMatrix = undefined
        realEigenvalues:Empty()
        imaginaryEigenvalues:Empty()
        eigenvectors:Empty()
        if not symmetricOverride
            symmetric = matrix:IsSymmetric()
        end
        if symmetric
            TridiagonalDecomposition decomposition
            decomposition:Symmetric(symmetric)
            decomposition:Calculate(matrix)
            CalculateEigenVectorsFromTridiagonalDecomposition(decomposition)
        else
            SchurDecomposition decomposition
            decomposition:Calculate(matrix)
            CalculateEigenVectorsFromSchurDecomposition(decomposition)        
        end
    end

    private action CalculateEigenVectorsFromTridiagonalDecomposition(TridiagonalDecomposition decomposition)
        Matrix z = decomposition:GetOrthogonalMatrix():Copy()
        Array<number> primary = decomposition:GetPrimary()
        Array<number> secondary = decomposition:GetSecondary()
        if z not= undefined and primary not= undefined and secondary not= undefined
            integer size = primary:GetSize()
            realEigenvalues:SetSize(size)
            Array<number> e
            e:SetSize(size)

            integer i = 0
            repeat while i < size - 1
                realEigenvalues:Set(i, primary:Get(i))
                e:Set(i, secondary:Get(i))
                i = i + 1
            end    
            realEigenvalues:Set(size-1, primary:Get(size-1))
            e:Set(size-1, 0)

            // Determine the largest primary and secondary value in absolute term.
            number maxAbsoluteValue = 0
            i = 0
            repeat while i < size
                if math:AbsoluteValue(realEigenvalues:Get(i)) > maxAbsoluteValue
                    maxAbsoluteValue = math:AbsoluteValue(realEigenvalues:Get(i))
                end
                if math:AbsoluteValue(e:Get(i)) > maxAbsoluteValue
                    maxAbsoluteValue = math:AbsoluteValue(e:Get(i))
                end
                i = i + 1
            end 

            // Make any primary and secondary value too small to be significant null
            // TODO: Needs precision class set up for this part.
//            if maxAbsoluteValue not= 0
//                i = 0
//                repeat while i < size
//                    if math:AbsoluteValue(realEigenvalues:Get(i)) <= DEFAULT_EPSILON * maxAbsoluteValue
//                        realEigenvalues:Set(i, 0)
//                    end
//                    if math:AbsoluteValue(e:Get(i)) <= DEFAULT_EPSILON * maxAbsoluteValue
//                        e:Set(i, 0)
//                    end
//                    i = i + 1
//                end 
//            end

            integer j = 0
            repeat while j < size
                integer iterations = 0
                integer m = 0
                boolean loop = true
                repeat while loop
                    boolean flag = true
                    m = j
                    repeat while m < size - 1 and flag
                        number delta = math:AbsoluteValue(realEigenvalues:Get(m)) + math:AbsoluteValue(realEigenvalues:Get(m + 1))
                        if math:AbsoluteValue(e:Get(m)) + delta = delta
                            flag = false // break
                        end
                        if flag
                            m = m + 1
                        end
                    end

                    if m not= j
                        if iterations = maxIterations
                            alert("Exceeds max iterations. Can not converge.")
                        end
                        iterations = iterations + 1

                        number q = (realEigenvalues:Get(j+1) - realEigenvalues:Get(j)) / (2.0 * e:Get(j))
                        number t = math:SquareRoot(1 + q * q)
                        if q < 0
                            q = realEigenvalues:Get(m) - realEigenvalues:Get(j) + e:Get(j) / (q - t)
                        else
                            q = realEigenvalues:Get(m) - realEigenvalues:Get(j) + e:Get(j) / (q + t)
                        end
                        number u = 0
                        number s = 1
                        number c = 1
                        flag = true
                        i = m - 1
                        repeat while i >= j and flag
                            number p = s * e:Get(i)
                            number h = c * e:Get(i)
                            if math:AbsoluteValue(p) >= math:AbsoluteValue(q)
                                c = q / p
                                t = math:SquareRoot(c*c + 1)
                                e:Set(i+1, p * t)
                                s = 1.0 / t
                                c = c * s
                            else
                                s = p / q
                                t = math:SquareRoot(s*s + 1)
                                e:Set(i+1, q * t)
                                c = 1.0 / t
                                s = s * c
                            end

                            if e:Get(i+1) = 0
                                realEigenvalues:Set(i+1, realEigenvalues:Get(i+1) - u)
                                e:Set(m, 0)
                                flag = false // break
                            end

                            if flag
                                q = realEigenvalues:Get(i+1) - u
                                t = (realEigenvalues:Get(i) - q) * s + 2.0 * c * h
                                u = s * t
                                realEigenvalues:Set(i+1, q + u)
                                q = c * t - h 
                                integer k = 0
                                repeat while k < size
                                    p = z:Get(k, i+1)
                                    z:Set(k, i+1, s * z:Get(k, i) + c * p)
                                    z:Set(k, i, c * z:Get(k, i) - s * p)
                                    k = k + 1
                                end
                                i = i - 1
                            end
                        end

                        if t = 0 and i >= j
                            //continue
                        else
                            realEigenvalues:Set(j, realEigenvalues:Get(j) - u)
                            e:Set(j, q)
                            e:Set(m, 0) 
                        end
                    end
                    if m = j
                        loop = false
                    end
                end
                j = j + 1
            end 

            //Sort the eigen values (and vectors) in increase order
            i = 0
            repeat while i < size
                number p = realEigenvalues:Get(i)
                k = i
                j = i + 1
                repeat while j < size
                    if realEigenvalues:Get(j) > p
                        k = j 
                        p = realEigenvalues:Get(j)
                    end
                    j = j + 1
                end 

                if k not= i
                    realEigenvalues:Set(k, realEigenvalues:Get(i))
                    realEigenvalues:Set(i, p)
                    j = 0
                    repeat while j < size
                        p = z:Get(j, i)
                        z:Set(j, i, z:Get(j, k))
                        z:Set(j, k, p)
                        j = j + 1
                    end 
                end
                i = i + 1
            end
//
//            // Determine the largest eigen value in absolute term.
//            maxAbsoluteValue = 0
//            i = 0
//            repeat while i < size
//                 if math:AbsoluteValue(realEigenvalues:Get(i)) > maxAbsoluteValue
//                    maxAbsoluteValue = math:AbsoluteValue(realEigenvalues:Get(i))
//                end
//                i = i + 1
//            end

            // Make null any eigenvalue too small to be significant
            // TODO: Needs precision class set up for this part.
//            if maxAbsoluteValue not= 0
//                i = 0
//                repeat while i < size
//                    if math:AbsoluteValue(realEigenvalues:Get(i)) <= DEFAULT_EPSILON * maxAbsoluteValue
//                        realEigenvalues:Set(i, 0)
//                    end
//                    i = i + 1
//                end  
//            end

            // Fill eigenvectors
            eigenvectors:SetSize(size)
            i = 0
            repeat while i < size
                Vector vector
                vector:SetSize(size)
                j = 0
                repeat while j < size
                    vector:Set(j, z:Get(j,i))
                    j = j + 1
                end  
                eigenvectors:Set(i, vector)
                i = i + 1
            end        
        end
    end

    private action CalculateEigenVectorsFromSchurDecomposition(SchurDecomposition decomposition)
        Matrix matT = decomposition:GetTriangularMatrix()
        Matrix matP = decomposition:GetOrthogonalMatrix()
        integer size = matT:GetColumns()

        realEigenvalues:SetSize(size)
        imaginaryEigenvalues:SetSize(size)
        
        integer i = 0
        repeat while i < size
            if i = size - 1 or matT:Get(i+1, i) = 0
                realEigenvalues:Set(i, matT:Get(i, i))
            else
                number x = matT:Get(i+1, i+1)
                number p = 0.5 * (matT:Get(i, i) - x)
                number z = math:SquareRoot(math:AbsoluteValue(p * p + matT:Get(i+1, i) * matT:Get(i, i+1)))
                realEigenvalues:Set(i, x + p)
                imaginaryEigenvalues:Set(i, z)
                realEigenvalues:Set(i+1, x + p)
                imaginaryEigenvalues:Set(i+1, -z)                
            end
            i = i + 1
        end

        number norm = 0
        i = 0
        repeat while i < size
            integer j = cast(integer, math:MaximumOf(i-1, 0))
            repeat while j < size
                norm = norm + math:AbsoluteValue(matT:Get(i, j))
                j = j + 1
            end
            i = i + 1
        end

        if norm = 0
            alert("Cannot handle a matrix with a norm of 0")
        end

        // Backsubstitute to find vectors of upper triangular form
        number r = 0
        number s = 0
        number z = 0

        integer index = size - 1
        repeat while index >= 0
            number p = realEigenvalues:Get(index)
            number q = imaginaryEigenvalues:Get(index)

            if q = 0
                integer l = index
                matT:Set(index, index, 1.0)
                i = index - 1
                repeat while i >= 0
                    number w = matT:Get(i, i) - p
                    r = 0
                    j = l
                    repeat while j <= index
                        r = r + matT:Get(i, j) * matT:Get(j, index)
                        j = j + 1
                    end
                    if imaginaryEigenvalues:Get(i) < 0
                        z = w
                        s = r
                    else
                        l = i
                        if imaginaryEigenvalues:Get(i) = 0
                            if w not= 0
                                matT:Set(i, index, -r / w)
                            else
                                matT:Set(i, index, -r / norm)
                            end
                        else
                            number x = matT:Get(i, i+1)
                            number y = matT:Get(i+1, i)
                            q = (realEigenvalues:Get(i) - p) * (realEigenvalues:Get(i) - p) + imaginaryEigenvalues:Get(i) * imaginaryEigenvalues:Get(i)
                            number t = (x * s - z * r) / q
                            matT:Set(i, index, t)
                            if math:AbsoluteValue(x) > math:AbsoluteValue(z)
                                matT:Set(i+1, index, (-r - w * t) / x)
                            else
                                matT:Set(i+1, index, (-s - y * t) / z)
                            end
                        end

                        // Overflow control
                        number t = math:AbsoluteValue(matT:Get(i, index))
                        
                    end
                    i = i - 1 
                end
            elseif q < 0
                // Complex vector
                alert("Complex numbers not set up yet.")

//                integer l = index - 1
//
//                if math:AbsoluteValue(matT:Get(index, index-1)) > math:AbsoluteValue(matT:Get(index-1, index))
//                    matT:Set(index-1, index-1, q / matT:Get(index, index-1))
//                    matT:Set(index-1, index, -(matT:Get(index, index) - p) / matT:Get(index, index-1))
//                else
//                    ComplexNumber top
//                    top:SetValues(0, -matT:Get(index -1, index))
//                    ComplexNumber bottom
//                    bottom:SetValues(matT:Get(index-1, index-1) - p, q)
//                    ComplexNumber result = top.divide(bottom)
//                end       
//                // TODO: Finsih complex vector portion.         
            end
            index = index - 1 
        end

        // Back transformation to get eigenvectors of original matrix
        j = size - 1
        repeat while j >= 0
            i = 0
            repeat while i < size
                z = 0.0
                k = 0
                repeat while k <= math:MinimumOf(j, size-1)
                    z = z + matP:Get(i, k) * matP:Get(k, j)
                    k = k + 1 
                end
                matP:Set(i, j, z)
                i = i + 1
            end
            j = j - 1
        end

        // Fill eigenvectors
        eigenvectors:SetSize(size)
        i = 0
        repeat while i < size
            Vector vector
            vector:SetSize(size)
            j = 0
            repeat while j < size
                vector:Set(j, matP:Get(j,i))
                j = j + 1
            end  
            eigenvectors:Set(i, vector)
            i = i + 1
        end 
    end

    action GetEigenvalues returns Array<number>
        return realEigenvalues
    end

    action GetEigenVectors returns Array<Vector>
        return eigenvectors
    end

    action Symmetric(boolean symmetric)
        me:symmetric = symmetric
        me:symmetricOverride = true
    end
end