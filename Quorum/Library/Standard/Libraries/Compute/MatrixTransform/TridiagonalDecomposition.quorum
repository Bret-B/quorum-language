package Libraries.Compute.MatrixTransform

use Libraries.Compute.Matrix
use Libraries.Containers.Array
use Libraries.Compute.Math
use Libraries.Compute.Vector

/*
    A Tridiagonal decomposition is a matrix decomposition/reduction of a symmetric matrix A into 
    a unitary orthogonal matrix Q and a symmetric tridiagonal matrix T such that:
         A = Q*T*Q^(T)

    This was adapted from the same model in Apache Commons, but was expanded 
    upon to simplify the library and add a variety of helper actions that were missing.
    More information about this class can be found on its documentation page TriDiagonalTransformer:
    https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/index.html

    For more information: https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm

    Attribute: Author Hannah Williams
    Attribute: Example

    use Libraries.Compute.Matrix
    use Libraries.Compute.MatrixTransform.TridiagonalDecomposition

    class Main
        action Main
            Matrix matrix
            matrix:Fill(3, 3, 5.0)
            TridiagonalDecomposition decomp
            decomp:Calculate(matrix)
            output decomp:GetTridiagonalMatrix():ToText()
        end
    end
*/

class TridiagonalDecomposition
    Math math
    /* This matrix represents the original matrix */
    Matrix original = undefined

    /* This matrix represents the house holder matrix */
    Matrix holder = undefined

    /* This matrix represents the symmetrical tridiagonal matrix (T) */
    Matrix tridiagonal = undefined

    /* This matrix represents the orthogonal matrix (Q). */
    Matrix orthogonal = undefined

    /* This matrix represents the orthogonal matrix transposed (QT). */
    Matrix orthogonalTransposed = undefined

    /* This array represents the center diagonal. */
    Array<number> diagonal

    /* This array represents the below center diagonal. */
    Array<number> subdiagonal

    /* This is used if the user explicitly wants to assume symmetry or not */
    boolean symmetric = false
    boolean symmetricOverride = false

    action Calculate(Matrix matrix)
        if not symmetricOverride
            symmetric = matrix:IsSymmetric()
        end
        if not symmetric
            alert("TridiagonalDecomposition is only valid for symmetric matrices.")
        end

        if not matrix:IsSquare()
            alert("TridiagonalDecomposition is only valid for square matrices.")
        end
        original = matrix
        holder = original:Copy()
        tridiagonal = undefined
        orthogonal = undefined
        orthogonalTransposed = undefined
        diagonal:Empty()
        subdiagonal:Empty()

        integer size = holder:GetColumns()

        Array<number> z
        z:SetSize(size)

        diagonal:SetSize(size)
        subdiagonal:SetSize(size-1)

        integer k = 0
        repeat while k < size - 1
            diagonal:Set(k, holder:Get(k,k))
            number xNormSqr = 0
            integer j = k + 1
            repeat while j < size
                number c = holder:Get(k,j)
                xNormSqr = xNormSqr + c * c
                j = j + 1
            end

            number alpha = 0
            if holder:Get(k, k+1) > 0
                alpha = -math:SquareRoot(xNormSqr)
            else
                alpha = math:SquareRoot(xNormSqr)
            end
            subdiagonal:Set(k, alpha)

            if alpha not= 0
                // apply Householder transform from left and right simultaneously
                holder:Set(k, k+1, holder:Get(k, k+1) - alpha)
                number beta = -1.0 / (alpha * holder:Get(k, k+1))
                
                // Fill z array
                i = k + 1
                repeat while i < size
                    z:Set(i, 0)
                    i = i + 1
                end  

                // Compute a = beta A v, where v is the Householder vector
                // this loop is written in such a way
                //   1) only the upper triangular part of the matrix is accessed
                //   2) access is cache-friendly for a matrix stored in rows
                i = k + 1
                repeat while i < size
                    number hki = holder:Get(k,i)
                    number zi = holder:Get(i,i) * hki
                    j = i + 1 
                    repeat while j < size
                        number hij = holder:Get(i,j)
                        zi = zi + hij * holder:Get(k,j)
                        z:Set(j, z:Get(j) + hij * hki)
                        j = j + 1
                    end
                    z:Set(i, beta * (z:Get(i) + zi))
                    i = i + 1
                end               
                
                // compute gamma = beta vT z / 2
                number gamma = 0
                i = k + 1
                repeat while i < size
                    gamma = gamma + (z:Get(i) * holder:Get(k,i))
                    i = i + 1
                end
                gamma = gamma * (beta / 2.0)

                // compute z = z - gamma v
                i = k + 1
                repeat while i < size
                    z:Set(i, z:Get(i) - (gamma * holder:Get(k,i)))
                    i = i + 1
                end      

                // update matrix: A = A - v zT - z vT
                // only the upper triangular part of the matrix is updated
                i = k + 1
                repeat while i < size
                    j = i
                    repeat while j < size
                        holder:Set(i, j, holder:Get(i,j) - holder:Get(k,i) * z:Get(j) + z:Get(i) * holder:Get(k,j))
                        j = j + 1
                    end
                    i = i + 1
                end               
            end
            k = k + 1
        end
        diagonal:Set(size-1, holder:Get(size-1,size-1))
        CalculateTridiagonalMatrix()
    end

    action GetOriginalMatrix returns Matrix
        return original
    end

    private action CalculateTridiagonalMatrix
        if tridiagonal = undefined
            tridiagonal = GetOrthogonalTransposedMatrix():Multiply(GetOriginalMatrix()):Multiply(GetOrthogonalMatrix())
            FillDiagonalArrays()
        end
    end

    private action FillDiagonalArrays
        diagonal:Empty()
        subdiagonal:Empty()
        integer size = tridiagonal:GetRows()

        integer i = 0
        repeat while i < size
            diagonal:Add(tridiagonal:Get(i, i))
            if i > 0 
                subdiagonal:Add(tridiagonal:Get(i, i-1))
            end
            i = i + 1
        end
    end

    action GetTridiagonalMatrix returns Matrix
        return tridiagonal
    end

    action GetOrthogonalMatrix returns Matrix
        if orthogonal = undefined and holder not= undefined
            orthogonal = GetOrthogonalTransposedMatrix():Transpose()
        end
        return orthogonal
    end


    action GetOrthogonalTransposedMatrix returns Matrix
        if orthogonalTransposed = undefined and holder not= undefined
            integer size = holder:GetColumns()
            Matrix matrix
            matrix:Fill(size, size, 0)

            k = size - 1
            repeat while k > 0
                matrix:Set(k, k, 1)

                if holder:Get(k-1,k) not= 0
                    number inv = 1.0 / (subdiagonal:Get(k-1) * holder:Get(k-1,k))
                    number beta = 1.0 / subdiagonal:Get(k-1)
                    matrix:Set(k, k, 1 + beta * holder:Get(k-1,k))

                    i = k + 1
                    repeat while i < size
                        matrix:Set(k, i, beta * holder:Get(k-1,i))
                        i = i + 1
                    end

                    j = k + 1
                    repeat while j < size
                        beta = 0
                        i = k + 1
                        repeat while i < size
                            beta = beta + matrix:Get(j, i) * holder:Get(k-1, i)
                            i = i + 1
                        end
                        beta = beta * inv
                        matrix:Set(j, k, beta * holder:Get(k-1, k))

                        i = k + 1
                        repeat while i < size
                            matrix:Set(j, i, matrix:Get(j, i) + beta * holder:Get(k-1, i))
                            i = i + 1
                        end
                        j = j + 1
                    end
                end
                k = k - 1
            end
            matrix:Set(0, 0, 1)   
 
            orthogonalTransposed = matrix
        end
        return orthogonalTransposed
    end

    action GetDiagonal returns Array<number>
        return diagonal
    end

    action GetSubDiagonal returns Array<number>
        return subdiagonal
    end

    action Symmetric(boolean symmetric)
        me:symmetric = symmetric
        me:symmetricOverride = true
    end
end