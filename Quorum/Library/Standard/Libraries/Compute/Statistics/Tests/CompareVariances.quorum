package Libraries.Compute.Statistics.Tests

use Libraries.Compute.Statistics.DataFrame
use Libraries.Compute.Statistics.DataFrameColumn
use Libraries.Compute.Statistics.Columns.NumberColumn
use Libraries.Compute.Statistics.Distributions.ClassificationDistribution
use Libraries.Compute.Statistics.Calculations.Median
use Libraries.Compute.Statistics.Calculations.Mean
use Libraries.Compute.Statistics.Transforms.CovarianceMatrixTransform
use Libraries.Compute.Statistics.Reporting.CompareVariancesResult
use Libraries.Compute.MatrixTransform.EigenDecomposition
use Libraries.Compute.Matrix
use Libraries.Compute.Math
use Libraries.Containers.Array
use Libraries.Compute.Vector
use Libraries.Compute.Statistics.Reporting.CompareMeansResult
use Libraries.Containers.HashTable
use Libraries.Compute.Statistics.Distributions.VarianceRatioDistribution
use Libraries.Compute.Statistics.Transforms.TransformWider

/*
    This class implements several tests:
        CompareSeveralVariances is a Levene's Homogeneity Test 
        Check that several groups vary in the same way using the mean
        For more information: https://en.wikipedia.org/wiki/Levene%27s_test

        CompareSeveralVariances is a Brown–Forsythe Extension of Levene's Homogeneity Test 
        Check that several groups vary in the same way using the median or trimmed mean
        For more information: https://en.wikipedia.org/wiki/Brown%E2%80%93Forsythe_test
    
        CompareSeveralRelatedVariances is a Mauchly's Sphericity Test
        Check that several groups vary in the same way when there are repeated measures.
        For more information: https://en.wikipedia.org/wiki/Mauchly%27s_sphericity_test

        _________________ is a Bartlett’s Test for Homogeneity of Variances (sensitive to non-normality)
        Check that several groups vary in the same way if all are normally distributed 
        For more information: https://en.wikipedia.org/wiki/Bartlett%27s_test
        For more information: https://www.statology.org/bartletts-test/

        CompareSeveralVariances is a Box's M Test for Homogeneity of Covariances Extension of Bartlett’s Homogeneity Test (sensitive to non-normality)
        >> CompareCovarianceMatrices (private)
        Check that several multivariate groups vary in the same way if all are normally distributed 
        For more information: https://en.wikipedia.org/wiki/Box%27s_M_test

        _________________ is a Conover Equal Variance Test aka Squared Ranks Test
        Check that several groups vary in the same way without assumptions about the distribution
        For more information: https://en.wikipedia.org/wiki/Squared_ranks_test

    Attribute: Author Tim Kluthe, Hannah Williams
    Attribute: Example

    use Libraries.Compute.Statistics.DataFrame
    use Libraries.Compute.Statistics.Tests.CompareVariances

    DataFrame frame
    frame:Load("Data/Data.csv")
    frame:AddSelectedColumnRange(0,3)

    CompareVariances compare = frame:CompareVariances()
    output compare:GetFormalSummary()
*/
class CompareVariances is StatisticalTest
    private HashTable<text, DataFrame> groups       // Contain the dataframe objects for the most factored of the groups (i.e. the samples)
    private integer numberOfFactors = 0             // Number of factors selected
    private integer numberOfColumns = 0             // Number of columns selected
    private Array<text> factorHeaders               // Used factor headers
    private Array<text> columnHeaders               // Used column headers
    private boolean multivariate = false            // Flag for multiple dependent variables
    private boolean factorial = false               // Flag for multiple independent factors
    private boolean needToSelectTest = true         // Flag to let this class auto-select a test based on given data
    private boolean needToProcessData = true        // Flag to let tell this class to process the selected data

    /* The distribution used to calculate the p-value.*/
    private ClassificationDistribution x2distribution
    private VarianceRatioDistribution fdistribution

    /* Default uses median as center for calculations */
    boolean useMedianAsCenter = true 

    /* Flag to use mean as center for calculations */
    boolean useMeanAsCenter = false 

    /* Flag to use trimmed mean as center for calculations */
    boolean useTrimmedMeanAsCenter = false

    /* Used if trimmed mean calculation is necessary */
    number trimmedMeanPercent = 0

    /* Flag if repeated measures are used in one-way within-subjects anova */
    boolean repeatedMeasures = false

    /* Flag if distribution is found to be normal or not */
    boolean normalDistribution = false

    /* This stores a hash of all of the results. */
    Array<CompareVariancesResult> results

    ExperimentalDesign experimentalDesign = undefined
    DataFrame designFrame = undefined
    Math math

    action Calculate(DataFrame frame) 
        results:Empty()
        groups:Empty()
        factorHeaders:Empty()
        columnHeaders:Empty()

        if experimentalDesign = undefined 
            ExperimentalDesign design
            i = 0
            repeat while i < frame:GetSelectedFactorSize()
                if repeatedMeasures
                    design:AddWithinSubjectsFactor(frame:GetColumn(frame:GetSelection():GetFactor(i)):GetHeader())
                else
                    design:AddBetweenSubjectsFactor(frame:GetColumn(frame:GetSelection():GetFactor(i)):GetHeader())
                end
                i = i + 1
            end
            design:RepeatedMeasures(repeatedMeasures)
            if design:GetDesignFrame() = undefined
                design:Transform(frame)
            end 
            experimentalDesign = design
        else
            experimentalDesign:RepeatedMeasures(repeatedMeasures)
            if experimentalDesign:GetDesignFrame() = undefined
                experimentalDesign:Transform(frame)
            end 
        end
        repeatedMeasures = experimentalDesign:RepeatedMeasures()
        designFrame = experimentalDesign:GetDesignFrame()

        numberOfFactors = designFrame:GetSelectedFactorSize()
        numberOfColumns = designFrame:GetSelectedColumnSize()

        multivariate = numberOfColumns > 1
        factorial = numberOfFactors > 1

        // Copy the frame keeping only the selected factors/columns and reselect them
        // Anything else will be dropped for this computation.
        // No need to remove undefined values unless using a factor
        DataFrame cleanedFrame = designFrame:Copy()
        if multivariate
            cleanedFrame = designFrame:RemoveUndefinedRowsFromSelectedColumns()
        end
        DataFrame copy
        integer index = 0
        i = 0
        repeat while i < designFrame:GetSelectedFactorSize()
            DataFrameColumn factor = cleanedFrame:GetColumn(designFrame:GetSelection():GetFactor(i))
            if factor:GetHeader() = experimentalDesign:GetSubjectIdentifier() // Skip id factor 
                if not repeatedMeasures
                    copy:AddColumn(factor)
                    copy:AddSelectedFactor(index)
                    factorHeaders:Add(factor:GetHeader())
                    index = index + 1
                end
            else
                copy:AddColumn(factor)
                copy:AddSelectedFactor(index)
                factorHeaders:Add(factor:GetHeader())
                index = index + 1
            end
            i = i + 1
        end

        i = 0
        repeat while i < designFrame:GetSelectedColumnSize()
            DataFrameColumn column = cleanedFrame:GetColumn(designFrame:GetSelection():GetColumn(i))
            copy:AddColumn(column)
            copy:AddSelectedColumn(index)
            columnHeaders:Add(column:GetHeader())
            index = index + 1
            i = i + 1
        end

        // Copy the selection to test for easier access 
        CopySelection(copy)


        // Check the data for missing data or incorrect column types
        CheckDataIntegrity(copy)


        // Collect data for each possible group (ignoring ID factor when repeated)
        if repeatedMeasures
            DataFrame removeID = copy:Copy()
            i = 0
            repeat while i < copy:GetSelectedFactorSize()
                removeID:AddSelectedFactor(copy:GetSelection():GetFactor(i))
                i = i + 1
            end  
            i = 0
            repeat while i < copy:GetSelectedColumnSize()
                removeID:AddSelectedColumn(copy:GetSelection():GetColumn(i))
                i = i + 1
            end
            if removeID:HasColumn(experimentalDesign:GetSubjectIdentifier())
                removeID:RemoveSelectedFactors(experimentalDesign:GetSubjectIdentifier())
            end
            groups = GetGroups(removeID)
        else
            groups = GetGroups(copy)
        end

        if repeatedMeasures
            if needToSelectTest
                RunTest(copy)
            end
        else
            if needToSelectTest
                designFrame = copy
                RunTest(copy)
            else
                designFrame = copy
            end
        end

        needToProcessData = false
    end

    private action CopySelection(DataFrame frame)
        if frame:GetSelection() not= undefined
            frame:GetSelection():CopyTo(cast(ColumnInput, me))
        end
        if frame:GetSelection() not= undefined 
            frame:GetSelection():CopyTo(cast(FactorInput, me))
        end
    end

    private action RunTest(DataFrame frame)
        if groups:GetSize() < 2
            alert("A CompareVariances calculation must include at least two samples.")
        end

        if repeatedMeasures
            if experimentalDesign:HasBetweenSubjectsFactors() // mixed needs both homogeneity and sphericity
                CompareSeveralRelatedVariances(frame)
            else
                CompareSeveralRelatedVariances(frame) 
            end   
        else
            CompareSeveralVariances(frame)  
        end
    end

    /* 
        This action tests for variance equality (homogeneity) for 2 or more independent samples. 
        It is commonly used with an ANOVA in CompareMeans.

        It conducts the following tests: 
            Brown-Forsythe Test > CompareVariances:UseMedianAsCenter() or UseTrimmedMeanAsCenter(0.05)
            Levene's Test       > CompareVariances:UseMeanAsCenter()

        Assumptions:
            1. Samples are independent
                If not independent: Use Mauchly's Sphericity Test   > CompareVariances:CompareSeveralRelatedVariances 

        Null hypothesis: The variances are equal across all samples
        Alternative hypothesis: At least one variance is not equal to the others.

        Attribute: Example
    
        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareVariances
    
        DataFrame frame
        frame:Load("data.csv")
        frame:AddSelectedColumnRange(0,2)
    
        CompareVariances compare = frame:CompareVariances()
        output compare:GetFormalSummary()
    */
    action CompareSeveralVariances(DataFrame frame)
        if needToProcessData
            needToSelectTest = false  // This test has been selected (skip RunTest)
            me:Calculate(frame)
        end
        if groups:GetSize() < 2
            alert("CompareSeveralVariances must have at least two samples.")
        end
        if multivariate
            CompareCovarianceMatrices(frame)
        else
            text center = ""
            DataFrame uncenteredGroupFrame
            DataFrame centeredGroupFrame = GetCenteredGroupsFrame(uncenteredGroupFrame)
            centeredGroupFrame:SelectAllColumns()
        
            if useMedianAsCenter
                center = " with median as center"
            elseif useMeanAsCenter
                center = " with mean as center"
            elseif useTrimmedMeanAsCenter
                center = " with trimmed mean as Center"
                alert("Trimmed mean not yet implemented")             
            end
    
            // Conduct a one-way ANOVA on the centered groups
            CompareMeans compare       
            compare:CompareSeveralMeans(centeredGroupFrame)
            CompareMeansResult aov = compare:GetResult()
    
            // Get anova result
            CompareVariancesResult result
            Array<text> sources
            text source = "Groups"
            if numberOfFactors > 0
                i = 0
                repeat while i < numberOfFactors
                    if i = 0
                        source = factorHeaders:Get(i)
                    else
                        source = source + ":"+ factorHeaders:Get(i)
                    end
                    i = i + 1
                end
            end
            sources:Add(source)
            text aovSource = "Groups"
            number f = aov:GetInformation():GetValue("Groups"):GetValue("F")
            number dfn = aov:GetInformation():GetValue("Groups"):GetValue("df")
            number dfd = aov:GetInformation():GetValue("Groups"):GetValue("error df")
            number p = aov:GetInformation():GetValue("Groups"):GetValue("p")
            
            result:SetTestStatistic(source, "F", f)
            result:SetDegreesOfFreedom(source, "numerator", dfn)
            result:SetDegreesOfFreedom(source, "denominator", dfd)
            result:SetProbabilityValue(source, source, p)
            result:SetSignificanceLevel(GetSignificanceLevel())
            result:SetFormat(GetStatisticalFormatting())
            result:SetFormalTestName("Levene's Test for Homogeneity of Variances"+center)
            result:SetInformation(source, "F", f)
            result:SetInformation(source, "dfn", dfn)
            result:SetInformation(source, "dfd", dfd)
            result:SetInformation(source, "p", p)
            result:SetGroupsFrame(uncenteredGroupFrame)
            result:SetFactors(factorHeaders)
            result:SetColumns(columnHeaders)
            result:SetSources(sources)
            results:Add(result)
        end
        needToProcessData = true // Reset processing flag in case user changes selections
    end

    /* 
        Box's M Test for variance-covariace equality (homogeneity)  
        It is commonly used with a MANOVA in CompareMeans.
        This action is not intended to be accessed directly. 
        Simply use CompareSeveralVariances, if the design is multivariate it will be redirected here.
        This expects the data in wide format, meaning each row is a subject or observation and each column is a dependent variable.
        Note: Each sample should have more subjects or observations than there are variables.

        If the multivariate design is balanced (meaning the same sample size for each group) this test is not really necessary.
        This test is typically compared to a significance level of 0.001
        Assumptions:
            1. Samples are independent
                If not independent: Use Mauchly's Sphericity Test   > CompareVariances:CompareSeveralRelatedVariances 
            2. There is more than one dependent variable
                If only one: Use Levene's Homogeneity Test          > CompareVariances:CompareSeveralVariances 

        Null hypothesis: The variance-covariance matrices are equal across all samples
        Alternative hypothesis: At least one variance-covariance matrix is not equal to the others.

        Attribute: Example
    
        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareVariances
    
        DataFrame frame
        frame:Load("data.csv")
        frame:AddSelectedColumnRange(0,2)
    
        CompareVariances compare = frame:CompareVariances()
        output compare:GetFormalSummary()
    */
    private action CompareCovarianceMatrices(DataFrame frame)   
        number dfTotal = 0
        Matrix pooledCovMatrix
        Array<Matrix> covMatrices
        number numberOfSubjects = 0 
        number numberOfGroups = groups:GetSize()
        number numberOfVariables = 0
        number c1Sum = 0
        number c2Sum = 0
        number mSum = 0

        // For information on the equations: 
        // https://www.ipen.br/biblioteca/slr/cel/0241
        // https://www.sussex.ac.uk/its/pdfs/SPSS_Statistics_Algorithms_22.pdf
        // https://real-statistics.com/multivariate-statistics/boxs-test/boxs-test-basic-concepts/
        Array<text> groupsArray = groups:CopyToKeyArray()
        integer i = 0
        repeat while i < groupsArray:GetSize()
            text groupText = groupsArray:Get(i)
            DataFrame groupFrame = groups:GetValue(groupText)
            groupFrame:SelectAllColumns()
            groupSize = groupFrame:GetColumn(0):GetSize() 
            if groupSize <= groupFrame:GetSize()
                alert("CompareCovarianceMatrices: "+groupText+" has only "+groupSize+" observations. You need at least "+(groupFrame:GetSize()+1)+", to be more than the number of dependent variables")
            end
            Matrix covMatrix = groupFrame:CovarianceMatrix()
            if i = 0
                pooledCovMatrix = covMatrix:Multiply(groupSize - 1)
                numberOfVariables = groupFrame:GetSize()
            else
                pooledCovMatrix = pooledCovMatrix:AddElements(covMatrix:Multiply(groupSize - 1))
            end
            mSum = mSum + math:NaturalLogarithm(covMatrix:GetDeterminant())*(groupSize - 1)
            c1Sum = c1Sum + 1.0 / (groupSize - 1)
            c2Sum = c2Sum + 1.0 / ((groupSize - 1) * (groupSize - 1))

            covMatrices:Add(covMatrix)
            numberOfSubjects = numberOfSubjects + groupSize
            dfTotal = dfTotal + (groupSize - 1)
            i = i + 1     
        end
        pooledCovMatrix = pooledCovMatrix:Multiply(1.0 / dfTotal)
        c1Sum = c1Sum - 1.0 / (numberOfSubjects - numberOfGroups)
        c2Sum = c2Sum - 1.0 / ((numberOfSubjects - numberOfGroups) * (numberOfSubjects - numberOfGroups))
   
        number M = (numberOfSubjects - numberOfGroups) * math:NaturalLogarithm(pooledCovMatrix:GetDeterminant()) - mSum
        number c1 = ((2 * numberOfVariables * numberOfVariables + 3 * numberOfVariables - 1) / (6.0 * (numberOfVariables + 1.0) * (numberOfGroups - 1))) * c1Sum 
        number c2 = ((numberOfVariables - 1.0) * (numberOfVariables + 2.0) / (6.0 * (numberOfGroups - 1.0))) * c2Sum
        number df1 = 0.5 * (numberOfGroups - 1) * numberOfVariables * (numberOfVariables + 1)
        number df2 = (df1 + 2) / math:AbsoluteValue(c2 - c1*c1)
        number x2 = M * (1 - c1)
        number f = 0
        if c2 > c1*c1
            a = df1 / (1.0 - c1 - df1 / df2)
            f = M / a
        else
            a = df2 / (1.0 - c1 + 2.0 / df2)
            f = df2 * M / df1 * (a - M)
        end

        // Chi-Squared Approximation (for large sample sizes)
        x2distribution:Setup(df1)
        number pX2 = 1.0 - x2distribution:CumulativeDistribution(x2)

        // F-Test Approximation (for small sample sizes)
        fdistribution:Setup(df1, df2)
        number pF = 1.0 - fdistribution:CumulativeDistribution(f)

        CompareVariancesResult result
        Array<text> sources
        text source = "Groups"
        if numberOfFactors > 0
            i = 0
            repeat while i < numberOfFactors
                if i = 0
                    source = factorHeaders:Get(i)
                else
                    source = source + ":"+ factorHeaders:Get(i)
                end
                i = i + 1
            end
        end
        sources:Add(source)
        result:SetTestStatistic(source, "M", M)
        result:SetTestStatistic(source, "χ2", x2)
        result:SetTestStatistic(source, "F", f)
        result:SetDegreesOfFreedom(source+"χ2", source+"χ2", df1)
        result:SetProbabilityValue(source+"χ2", source+"χ2", pX2)
        result:SetDegreesOfFreedom(source+"F", "numerator", df1)
        result:SetDegreesOfFreedom(source+"F", "denominator", df2)
        result:SetProbabilityValue(source+"F", source+"F", pF)
        result:SetSignificanceLevel(GetSignificanceLevel())
        result:SetFormat(GetStatisticalFormatting())
        result:SetFormalTestName("Box's M-test for Homogeneity of Covariance Matrices")
        result:SetGroupsTable(groups)
        result:SetFactors(factorHeaders)
        result:SetColumns(columnHeaders)
        result:SetSources(sources)
        results:Add(result)
    end

    /* 
        Mauchly's Sphericity Test for variance of differences equality (sphericity). 

        Assumptions:
            1. Samples are dependent
                If not dependent: Use Levene's Test   > CompareVariances:CompareIndependentVariances 

        Null hypothesis: The variances of the differences are equal across all samples
        Alternative hypothesis: At least one variance of a difference is not equal to the others.

        Attribute: Example
    
        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareVariances
    
        DataFrame frame
        frame:Load("data.csv")
        frame:AddSelectedColumn(0)
        frame:AddSelectedFactor(1)
    
        CompareVariances compare = frame:CompareRelatedVariances()
        output compare:GetFormalSummary()
    */
    action CompareSeveralRelatedVariances(DataFrame frame)
        if needToProcessData
            repeatedMeasures = true
            needToSelectTest = false  // This test has been selected (skip RunTest)
            me:Calculate(frame)
        end
        if multivariate
            alert("A multivariate repeated measures CompareVariances test is not supported yet. Formal Test Name: Mauchly's Sphericity")
        end

        integer numberOfSubjects = experimentalDesign:GetNumberOfSubjects()

        // Get groups for response matrix using only within-subjects factors
        DataFrame groupFrame = GetWithinGroupsFrame()
        groupFrame:SelectAllColumns()

        // Remove id and between factors leaving only measurement groups selected for response matrix
        if groupFrame:HasColumn(experimentalDesign:GetSubjectIdentifier())
            groupFrame:RemoveSelectedColumns(experimentalDesign:GetSubjectIdentifier())
        end
        Array<text> between = experimentalDesign:GetBetweenSubjectsFactors()
        i = 0
        repeat while i < between:GetSize()
            groupFrame:RemoveSelectedColumns(between:Get(i))
            i = i + 1
        end

        Matrix responseMatrix = groupFrame:CopySelectedColumns():ConvertToMatrix()

        // Create residual SSCP Matrix
        // Create the design matrix using between-subjects factors (intercept only if no factors)
        ExperimentalDesign betweenDesign
        i = 0
        repeat while i < between:GetSize()
            betweenDesign:AddBetweenSubjectsFactor(between:Get(i))
            i = i + 1
        end
        betweenDesign:Multivariate(true) // Use measurements as variables even if there are between-subjects factors
        betweenDesign:Transform(groupFrame)
        Matrix designMatrix = betweenDesign:GetDesignMatrix()
        Matrix sscpResiduals = ComputeSumOfSquaresCrossProductMatrix(designMatrix, responseMatrix)
        Matrix identity = sscpResiduals:Identity()

        CompareVariancesResult result
        Array<text> sources = experimentalDesign:GetContrastSources()
        s = 0
        repeat while s < sources:GetSize()
            text source = sources:Get(s)
            
            Matrix transformationMatrix = experimentalDesign:GetContrastMatrix(source)

            if transformationMatrix:GetColumns() > 1    
                // Solve the matrices against the identity matrix AX = B
                Matrix A = transformationMatrix:Transpose():Multiply(identity):Multiply(transformationMatrix)
                Matrix B = transformationMatrix:Transpose():Multiply(sscpResiduals):Multiply(transformationMatrix)
                Matrix X = A:Inverse():Multiply(B)
    
                // X is not a symmetric matrix
                // Get eigenvalues of X matrix
                EigenDecomposition eig
                eig:Calculate(X)
    
                number productOfEvals = 1
                number sumOfEvals = 0
                number sumOfSquaredEvals = 0
                Vector evals = eig:GetEigenvalues()
                i = 0
                repeat while i < evals:GetSize()
                    eval = evals:Get(i)
                    if eval > 1.0e-10 // Eigen values cannot be negative and ignore if basically 0
                        productOfEvals = productOfEvals * eval
                        sumOfEvals = sumOfEvals + eval
                        sumOfSquaredEvals = sumOfSquaredEvals + eval * eval
                    end
                    i = i + 1 
                end 
    
                // Degrees of freedom between subjects (different than n-1 for mixed designs)
                number dfSubjects = numberOfSubjects - designMatrix:GetColumns()
        
                // Degrees of freedom for effect or interaction
                number dfFactor = X:GetRows()
    
                // Degrees Of Freedom
                number df = 0.5 * dfFactor * (dfFactor + 1.0) - 1.0
                
                // See page 493: https://www.sussex.ac.uk/its/pdfs/SPSS_Statistics_Algorithms_22.pdf
                // Test Statistics: Mauchly's W
                number mauchlys_w = productOfEvals / math:RaiseToPower(sumOfEvals / dfFactor, dfFactor)
                number rho = 1.0 - (2.0 * dfFactor * dfFactor + dfFactor + 2.0)/(6.0 * dfFactor * dfSubjects)
                number approx_chi_w = -1.0 * rho * dfSubjects * math:NaturalLogarithm(mauchlys_w)
                x2distribution:Setup(df)
                number p1 = x2distribution:CumulativeDistribution(approx_chi_w)
                x2distribution:Setup(df+4)
                number p2 = x2distribution:CumulativeDistribution(approx_chi_w)
                number w2 = ((dfFactor + 2.0) * (dfFactor - 1.0) * (dfFactor - 2.0) * (2.0 * dfFactor * dfFactor * dfFactor + 6 * dfFactor * dfFactor + 3 * dfFactor + 2))
                w2 = w2 / (288 * dfFactor * dfFactor * dfSubjects * dfSubjects * rho * rho)
                number p_w = 1.0 - p1 - w2 * (p2 - p1)
    
                // See: https://real-statistics.com/anova-repeated-measures/sphericity/additional-information-sphericity/    
                // Test Statistics: JNS' V
                number jns_v = sumOfEvals * sumOfEvals / sumOfSquaredEvals
                number approx_chi_v = 0.5 * numberOfSubjects * dfFactor * dfFactor * (jns_v - 1.0/(dfFactor))
                x2distribution:Setup(df)
                number p_v = 1.0 - x2distribution:CumulativeDistribution(approx_chi_v)

                // The equations can be found here:
                // https://pingouin-stats.org/generated/pingouin.epsilon.html
                // Page 493: https://www.sussex.ac.uk/its/pdfs/SPSS_Statistics_Algorithms_22.pdf
        
                // Lower-bound epsilon
                number lbCorrectionEpsilon = 1.0/dfFactor
    
                // Greenhouse-Geisser epsilon
                number ggCorrectionEpsilon = sumOfEvals * sumOfEvals / (sumOfSquaredEvals * dfFactor)
    
                // Huynh-Feldt epsilon
                number hfCorrectionEpsilon = ((dfSubjects + 1) * dfFactor * ggCorrectionEpsilon - 2.0) / (dfFactor * (dfSubjects - dfFactor * ggCorrectionEpsilon))

                // Mauchly's W Test Statistic (default)
                result:SetTestStatistic(source, "W", mauchlys_w)
                result:SetTestStatistic(source+"W", "χ2", approx_chi_w)
                result:SetDegreesOfFreedom(source, "W", df)
                result:SetProbabilityValue(source, "W", p_w)
                result:SetInformation(source, "W", mauchlys_w)
                result:SetInformation(source, "X2", approx_chi_w)
                result:SetInformation(source, "df", df)
                result:SetInformation(source, "p", p_w)
                // JNS's V Test Statistic
                result:SetInformation(source, "JNS V", jns_v)
                result:SetInformation(source, "JNS V χ2", approx_chi_v)
                result:SetInformation(source, "JNS V df", df)
                result:SetInformation(source, "JNS V p", p_v)
                result:SetInformation(source, "lb", lbCorrectionEpsilon)
                result:SetInformation(source, "gg", ggCorrectionEpsilon)
                result:SetInformation(source, "hf", hfCorrectionEpsilon)
            else
                // Mauchly's W Test Statistic (default)
                result:SetTestStatistic(source, "W", 1)
                result:SetTestStatistic(source+"W", "χ2", 0)
                result:SetDegreesOfFreedom(source, "W", 0)
                result:SetProbabilityValue(source, "W", 1)
                result:SetInformation(source, "W", 1)
                result:SetInformation(source, "X2", 0)
                result:SetInformation(source, "df", 0)
                result:SetInformation(source, "p", 1)
                // JNS's V Test Statistic
                result:SetInformation(source, "JNS V", 1)
                result:SetInformation(source, "JNS V χ2", 0)
                result:SetInformation(source, "JNS V df", 0)
                result:SetInformation(source, "JNS V p", 1)
                result:SetInformation(source, "lb", 1)
                result:SetInformation(source, "gg", 1)
                result:SetInformation(source, "hf", 1)
            end

            // Additional Sources
            // https://www.sussex.ac.uk/its/pdfs/SPSS_Statistics_Algorithms_22.pdf
            // https://support.sas.com/rnd/app/stat/papers/mixedglm.pdf
            // https://github.com/cran/ez/blob/1d7a35d30f31b1671e7f6548b15864ddfe61c5ef/R/ez-internal.R
            // https://zief0002.github.io/matrix-algebra/statistical-application-sscp-variancecovariance-and-correlation-matrices.html#sscp-matrix
            // https://www.originlab.com/doc/en/UserGuide/UserGuide/Algorithms_(Repeated_Measures_ANOVA).html
            s = s + 1
        end
        result:SetSignificanceLevel(GetSignificanceLevel())
        result:SetFormat(GetStatisticalFormatting())
        result:Repeated(true)
        result:SetFormalTestName("Mauchly's Test of Sphericity")
        result:SetGroupsFrame(groupFrame:CopySelectedColumns()) // The only groupings that matter in mauchly's are the within-subjects groups
        result:SetFactors(factorHeaders)
        result:SetColumns(columnHeaders)
        if between:GetSize() > 0 // For mixed design, do a levene's test on the each between subject effect and interaction
            DataFrame copy = experimentalDesign:GetDesignFrame():Copy()
            Array<text> dvs = experimentalDesign:GetDependentVariables()
            Array<text> betweenSources = betweenDesign:GetDesignSources()
            text formalNameAddition = ""
            s = 0
            repeat while s < betweenSources:GetSize()
                text source = betweenSources:Get(s)
                Array<text> betweenFactors = source:Split(":")

                betweenDesign:Empty()
                i = 0
                repeat while i < betweenFactors:GetSize()
                    betweenDesign:AddBetweenSubjectsFactor(betweenFactors:Get(i))
                    i = i + 1
                end
                i = 0
                repeat while i < dvs:GetSize()
                    betweenDesign:AddDependentVariable(dvs:Get(i))
                    i = i + 1
                end
                CompareVariances levene
                levene:SetExperimentalDesign(betweenDesign)
                levene:Calculate(copy)
    
                CompareVariancesResult betweenResult = levene:GetResult()
                number f = betweenResult:GetInformation():GetValue(source):GetValue("F")
                number dfn = betweenResult:GetInformation():GetValue(source):GetValue("dfn")
                number dfd = betweenResult:GetInformation():GetValue(source):GetValue("dfd")
                number p = betweenResult:GetInformation():GetValue(source):GetValue("p")
    
                result:SetTestStatistic(source, "F", f)
                result:SetDegreesOfFreedom(source, "numerator", dfn)
                result:SetDegreesOfFreedom(source, "denominator", dfd)
                result:SetProbabilityValue(source, source, p)
                result:SetInformation(source, "F", f)
                result:SetInformation(source, "dfn", dfn)
                result:SetInformation(source, "dfd", dfd)
                result:SetInformation(source, "p", p)
                sources:Add(source)

                if s = 0
                    formalNameAddition = betweenResult:GetFormalTestName()
                end
                s = s + 1
            end
            result:SetFormalTestName("Mauchly's Test of Sphericity and "+formalNameAddition)
        end
        result:SetSources(sources)
        results:Add(result)
    end

    action SetExperimentalDesign(ExperimentalDesign design)
        experimentalDesign = design:Copy() // make a copy of the design so it can be used in other tests.
    end

    action GetExperimentalDesign returns ExperimentalDesign
        return experimentalDesign
    end

    /* Used in independent-sample tests */
    action UseMedianAsCenter
        useMedianAsCenter = true
        useMeanAsCenter = false
        useTrimmedMeanAsCenter = false
    end

    /* Used in independent-sample tests */
    action UseMeanAsCenter
        useMedianAsCenter = false
        useMeanAsCenter = true
        useTrimmedMeanAsCenter = false
    end

    /* Used in independent-sample tests */
    action UseTrimmedMeanAsCenter(number percent)
        if percent < 0 or percent >= 0.5
            alert("Trimmed mean percent must be between 0 and 0.5")
        end
        useMedianAsCenter = false
        useMeanAsCenter = false
        useTrimmedMeanAsCenter = true
        trimmedMeanPercent = percent
    end

    /* Used in dependent-sample tests */
    action RepeatedMeasures(boolean repeatedMeasures)
        me:repeatedMeasures = repeatedMeasures
    end

    /* Used in independent-sample tests */
    action AssumeNormalDistribution(boolean assume)
        assumeNormalDistribution = assume
    end

    /*
        This returns the probability if only one result exists.

        Attribute: Returns the P-Value. 
    */
    action GetProbabilityValue returns number
        return GetResult():GetProbabilityValue()
    end

    /*
        This returns the degrees of freedom if only one result exists.

        Attribute: Returns the Degrees of Freedom. 
    */
    action GetDegreesOfFreedom returns number
        return GetResult():GetDegreesOfFreedom()
    end

    /*
        This returns the test statistic if only one result exists.

        Attribute: Returns the test statistic. 
    */
    action GetTestStatistic returns number
        return GetResult():GetTestStatistic()
    end

    /*
        This returns the effect size if only one result exists.

        Attribute: Returns the effect size. 
    */
    action GetEffectSize returns number
        return GetResult():GetEffectSize()
    end

    /*
        This returns a result if only one exists.

        Attribute: Returns the CompareVariancesResult object
        Attribute: Example

        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareVariances
    
        DataFrame frame
        frame:Load("Data/Data.csv")

        CompareVariances compare
        compare:AddColumn(0)
        compare:AddColumn(1)
        compare:Calculate(frame)
        
        CompareVariancesResult result = compare:GetResult()
    */
    action GetResult returns CompareVariancesResult
        if results:GetSize() = 0
            alert("There are no results calculated")
        elseif results:GetSize() = 1
            return results:Get(0)
        else
            alert("There is more than one test result, use GetResults() for an array of all results")
        end
    end

    /*
        Attribute: Returns an array of CompareVariancesResult objects
        Attribute: Example

        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareVariances
    
        DataFrame frame
        frame:Load("Data/Data.csv")
    
        CompareVariances compare
        compare:AddColumn(0)
        compare:AddColumn(1)
        compare:AddColumn(2)
        frame:Calculate(compare)

        Array<CompareVariancesResult> results = compare:GetResults()
    */
    action GetResults returns Array<CompareVariancesResult>
        return results
    end

    /*
        Attribute: Returns a list of the important statistics of the test
        Attribute: Example

        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareVariances
    
        DataFrame frame
        frame:Load("Data/Data.csv")
    
        CompareVariances compare
        compare:Add(0)
        compare:Add(1)
        frame:Calculate(compare)

        output compare:GetSummary()
    */
    action GetSummary returns text
        text summary = ""
        text lf = summary:GetLineFeed()
        i = 0
        CompareVariancesResult result 
        repeat while i < results:GetSize()
            result = results:Get(i)

            summary = summary + lf
            summary = summary + result:GetSummary()
            summary = summary + lf
            i = i + 1
        end
        return summary
    end

    /*
        Attribute: Returns a DataFrame of the important statistics of the test
        Attribute: Example

        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareVariances
    
        DataFrame frame
        frame:Load("Data/Data.csv")
    
        CompareVariances compare
        compare:Add(0)
        compare:Add(1)
        frame:Calculate(compare)
        
        DataFrame result = compare:GetSummaryDataFrame()
        result:Save("myresult.csv")
    */
    action GetSummaryDataFrame returns DataFrame
        return GetResult():GetSummaryDataFrame()
    end

    /*
        This action summarizes the results and places them into formal academic language, in 
        APA format.
        For more information: https://apastyle.apa.org/instructional-aids/numbers-statistics-guide.pdf

        Attribute: Returns a condensed formal result of the test
        Attribute: Example

        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareVariances
    
        DataFrame frame
        frame:Load("Data/Data.csv")
    
        CompareVariances compare
        compare:Add(0)
        compare:Add(1)
        frame:Calculate(compare)

        output compare:GetFormalSummary()
    */
    action GetFormalSummary returns text
        text summary = ""
        text lf = summary:GetLineFeed()
        i = 0
        CompareVariancesResult result 
        repeat while i < results:GetSize()
            result = results:Get(i)

            summary = summary + lf
            summary = summary + result:GetFormalSummary()
            summary = summary + lf
            i = i + 1
        end
        return summary
    end

    
    private action ComputeSumOfSquaresCrossProductMatrix(Matrix x, Matrix y) returns Matrix
        Matrix xT = x:Transpose()
        Matrix xTx_inv = xT:Multiply(x):Inverse()       
        Matrix b = xTx_inv:Multiply(xT):Multiply(y)          
        Matrix result = y:SubtractElements(x:Multiply(b))

        Matrix centered = result:CenterByColumn()
        return centered:Transpose():Multiply(centered)
    end

    // This is used for univariate designs with check for variance equality
    private action GetCenteredGroupsFrame(DataFrame groupFrame) returns DataFrame
        DataFrame centeredGroupFrame

        Array<text> groupsArray = groups:CopyToKeyArray()
        integer i = 0
        repeat while i < groupsArray:GetSize()
            text groupText = groupsArray:Get(i)
            DataFrame group = groups:GetValue(groupText)
            group:SelectAllColumns()
        
            NumberColumn centeredgroup
            centeredgroup:SetHeader(groupText)
            centeredGroupFrame:AddColumn(centeredgroup)

            NumberColumn uncenteredgroup
            uncenteredgroup:SetHeader(groupText)
            groupFrame:AddColumn(uncenteredgroup)

            number center = 0
            if useMeanAsCenter
                center = group:Mean()
            elseif useMedianAsCenter 
                // median in dataframe calculation different from levene's requirement, manually calculate
                Vector v = group:GetColumn(0):ConvertToVector()
                v:Sort()
                size = v:GetSize()
                if size mod 2 = 1
                    center = v:Get(size / 2)
                else
                    center = 0.5 * (v:Get((size / 2) - 1) + v:Get(size / 2))
                end
            elseif useTrimmedMeanAsCenter
                alert("Trimmed mean not yet implemented") 
            end

            DataFrameColumn column = group:GetColumn(0)
            j = 0
            repeat while j < column:GetSize()
                uncenteredgroup:Add(column:GetAsNumber(j))
                centeredgroup:Add(math:AbsoluteValue(column:GetAsNumber(j) - center))
                j = j + 1
            end
            i = i + 1     
        end
        return centeredGroupFrame
    end

    // This is only used for univariate designs
    private action GetGroupsFrame() returns DataFrame
        DataFrame groupFrame

        integer size = 0
        Array<text> groupsArray = groups:CopyToKeyArray()
        groupsArray:Sort()
        integer i = 0
        repeat while i < groupsArray:GetSize()
            text groupText = groupsArray:Get(i)
            DataFrame group = groups:GetValue(groupText)
            DataFrameColumn column = group:GetColumn(0)
            if repeatedMeasures and not experimentalDesign:HasBetweenSubjectsFactors()
                if i = 0
                    size = column:GetSize()
                else
                    if size not= column:GetSize()
                        alert("Samples must be the same size for a repeated design.")
                    end
                end
            end
            group:GetColumn(0):SetHeader(groupText)
            groupFrame:AddColumn(group:GetColumn(0):Copy())
            i = i + 1     
        end

        return groupFrame
    end

    // This is only used for univariate designs
    private action GetWithinGroupsFrame() returns DataFrame
        DataFrame frame = designFrame:Copy()

        DataFrame copy
        // Copy and merge within-subjects selection
        Array<text> within = experimentalDesign:GetWithinSubjectsFactors()
        text source = ""
        if within:GetSize() > 1
            // Select everything
            frame:SelectAllColumns()

            // Unselect the within-subejcts main effects and merge them
            text operation = ""
            j = 0
            repeat while j < within:GetSize()
                if j = 0
                    operation = operation + within:Get(j)
                    source = source + within:Get(j)
                else
                    operation = operation + " + " + within:Get(j)
                    source = source + ":" + within:Get(j)
                end
                frame:RemoveSelectedColumns(within:Get(j))
                j = j + 1
            end

            // Add within-subejcts merged interaction column and select
            frame:AddColumn(source,operation)
            frame:AddSelectedColumns(source)

            // Keep only currently selected columns
            copy = frame:CopySelectedColumns()
        elseif within:GetSize() = 1
            source = within:Get(0)
            copy = frame
        end

        Array<text> dv = experimentalDesign:GetDependentVariables()
        i = 0
        repeat while i < dv:GetSize()
            copy:AddSelectedColumns(dv:Get(i))
            i = i + 1
        end
        copy:AddSelectedFactors(source)

        // Take the mean of any id+source repetitions
        TransformWider widen
        widen:ResolveConflictsWithMean()
        DataFrame groupFrame = widen:Transform(copy)

        return groupFrame
    end

    private action CheckDataIntegrity(DataFrame frame)
        i = 0
        repeat while i < frame:GetSelectedColumnSize()
            DataFrameColumn column = frame:GetColumn(frame:GetSelection():GetColumn(i))
    
            if column:IsUndefined()
                alert("Column is undefined.")
            end
            if not column:IsNumberColumn() and not column:IsIntegerColumn()
                alert("Columns must be numerical. " + column:GetHeader() + " is not a numerical column.")
            end
            if column:GetSize() < 2
                alert("Columns must have 2 or more entries. Not enough data for comparison to be calculated.")
            end
            i = i + 1
        end
    end
end