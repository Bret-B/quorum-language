package Libraries.Compute.Statistics.Tests

use Libraries.Compute.Statistics.Tests.StatisticalTest
use Libraries.Compute.Statistics.DataFrame
use Libraries.Compute.Math
use Libraries.Compute.Statistics.Distributions.NormalDistribution
use Libraries.Compute.Statistics.Distributions.ClassificationDistribution
use Libraries.Compute.Statistics.DataFrameColumn
use Libraries.Compute.Statistics.Columns.TextColumn
use Libraries.Compute.Statistics.Columns.NumberColumn
use Libraries.Compute.Statistics.Transforms.ConvertColumnsToRanksTransform
use Libraries.Containers.HashTable
use Libraries.Containers.Iterator
use Libraries.Containers.Array

/*
    This class implements several non-parametric tests: 
        Compare2IndependentRanks is a Mann-Whiteney U-Test aka Wilcoxon Rank-Sum Test
        Difference between two rank ordered groups without assumptions about the distribution
        For more information: https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test
    
        Compare2DependentRanks is a Wilcoxon Signed-Ranks Test
        Difference between one or two rank ordered paired groups without assumptions about the distribution.
        For more information: https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test
    
        CompareNIndependentRanks is a Kruskal-Wallis H Test
        Difference between three or more rank ordered groups without assumptions about the distribution
        For more information: https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_one-way_analysis_of_variance
    
        CompareNDependentRanks is a Friedman Test
        Difference between three or more rank ordered repeated measures groups without assumptions about the distribution
        For more information: https://en.wikipedia.org/wiki/Friedman_test

    It was partially adapted from the same model in Apache Commons, but was expanded 
    upon to simplify the library and add a variety of helper actions and calculations that were missing.
    More information about this class can be found on then documentation pages MannWhitneyUTest and WilcoxonSignedRankTest:
    https://commons.apache.org/proper/commons-math/javadocs/api-3.6.1/index.html

    Attribute: Author Hannah Williams
    Attribute: Example

    use Libraries.Compute.Statistics.DataFrame
    use Libraries.Compute.Statistics.Tests.CompareRanks

    DataFrame frame
    frame:Load("Data/Data.csv")

    CompareRanks compare
    compare:Add(0)
    compare:Add(1)
    frame:Calculate(compare)
    
    output compare:GetCorrelation()
*/
class CompareRanks is StatisticalTest
    /* The distribution used to calculate the p-value from the z value for 2 samples.*/
    NormalDistribution zdistribution

    /* The distribution used to calculate the p-value from the H/Q and df values for N samples.*/
    ClassificationDistribution x2distribution

    /* A flag to let the user know probability may be incorrect due to tied rankings. */
    boolean rankTiesWarning = false

    /* A flag to let the user know probability may be incorrect due to zero values. */
    boolean zeroRankWarning = false

//    /* This stores a hash of all of the results. */
//    HashTable<text, CompareGroupsResult> results        // Used to find the result by column or pair of columns.        
//    HashTable<text, CompareGroupsResult> indexResults   // Used to find the result by index or pair of indices.

    /* Flag if the samples are paired in a two-sample test */
    boolean paired = false

    /* Flag if repeated measures are used in one-way within-subjects anova */
    boolean repeatedMeasures = false

    /* Flag if calculations are to assume variances are equal or not */
    boolean equalVariances = true

    /* Flag for use of continuity correction in 2 sample tests */
    boolean useCorrection = true

    /* User determined mean to be used in one-sample or paired two-sample tests */
    number userMean = 0

    Math math

    private action RunTest(DataFrame frame)
        if GetColumnSize() < 1
            alert("Must include at least one column.")
        end

        if GetColumnSize() < 2     
            if paired or GetColumnSize() = 1
                Compare2DependentRanks(frame)
            else             
                Compare2IndependentRanks(frame)
            end
        elseif GetColumnSize() > 2
            if repeatedMeasures
                CompareNDependentRanks(frame)
            else
                CompareNIndependentRanks(frame)
            end
        end
    end

    /* 
        Mann-Whiteney U-Test aka Wilcoxon Rank-Sum Test is for 2 independent groups.

        Null hypothesis: The population medians are equal
        Alternative hypothesis: The population medians are not equal

        Attribute: Example
    
        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareRanks
    
        DataFrame frame
        frame:Load("data.csv")
    
        CompareRanks compare
        compare:AddColumn(0)
        compare:AddColumn(1)
        compare:Calculate(frame)
        output compare:GetSummary()
    */
    action Compare2IndependentRanks(DataFrame frame)
        if GetColumnSize() < 2
            RunTest(frame)
        end

        // Sort the data for all groups/samples into ascending order in one combined set.
        TextColumn group
        group:SetHeader("group")
        NumberColumn data
        data:SetHeader("data")
        i = 0
        repeat while i < GetColumnSize()
            DataFrameColumn column = frame:GetColumn(GetColumn(i))
            if column:IsUndefined()
                alert("Column is undefined.")
            end

            if not column:IsNumberColumn() and not column:IsIntegerColumn()
                alert("Columns must be numerical. " + column:GetHeader() + " is not a numerical column.")
            end
            j = 0
            repeat while j < column:GetSize()
                group:Add(column:GetHeader())
                data:Add(column:GetAsNumber(j))
                j = j + 1
            end
            i = i + 1
        end

        DataFrame sorted
        sorted:AddColumn(group)
        sorted:AddColumn(data)
        sorted:Sort("data")

        // Assign ranks to the sorted data points. Give tied values the average rank.
        ConvertColumnsToRanksTransform transform
        transform:AddColumn(1)
        DataFrame ranked = sorted:Transform(transform)
        ranked:AddColumn(0, sorted:GetColumn(0))
        output ranked:ToText()

        // Add up the different ranks for each group/sample.
        HashTable<text, number> sums
        DataFrameColumn groups = ranked:GetColumn(0)
        DataFrameColumn ranks = ranked:GetColumn(1)
        i = 0
        repeat while i < ranks:GetSize()
            if not sums:HasKey(groups:GetAsText(i))
                sums:Add(groups:GetAsText(i), ranks:GetAsNumber(i))
            else
                sums:Set(groups:GetAsText(i), sums:GetValue(groups:GetAsText(i)) + ranks:GetAsNumber(i))
            end
            i = i + 1
        end

        // Calculate the max sum statistic, the larger of the two sums
        number n1 = frame:GetColumn(GetColumn(0)):GetSize()
        number n2 = frame:GetColumn(GetColumn(1)):GetSize()
        number sum1 = sums:GetValue(frame:GetColumn(GetColumn(0)):GetHeader())
        number sum2 = sums:GetValue(frame:GetColumn(GetColumn(1)):GetHeader())
        number maxSum = sum1
        number n = n1   // The size of the larger sum sample
        if sum2 > sum1
            maxSum = sum2
            n = n2
        end

        // Calculate the W statistic, the smaller of the two u values
        number u1 = sum1 - (n1 * (n1 + 1) / 2.0)
        number u2 = sum2 - (n2 * (n2 + 1) / 2.0)
        number W = math:MinimumOf(u1, u2)
        
        // Calculate normal approximation and corrections
        // See: https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test#Normal_approximation_and_tie_correction
        number N = n1 + n2
        number meanSum = n * (N + 1) / 2.0 // The mean of the larger sum sample
        number varSum = n1 * n2 * (N + 1) / 12.0
        number tieCorrectionSum = CalculateTieCorrectionSum(ranks)
        if tieCorrectionSum not= 0
            varSum = (n1 * n2 / 12.0) * ((N + 1) - (tieCorrectionSum / (N * (N - 1)))) // The tie correction
        end
        number sdSum = math:SquareRoot(varSum)
        number correction = 0
        if useCorrection
            correction = 0.5 // The continuity correction
        end
        number z = (maxSum - meanSum - correction) / sdSum

        // Calculate two-tailed probability value from normal distribution
        number p = 2.0 * (1.0 - zdistribution:CumulativeDistribution(z))

        output "sum1: "+sum1
        output "sum2: "+sum2
        output "W: "+W
        output "z: "+z
        output "p: "+p
    end

    /* 
        Wilcoxon Signed-Ranks Test for 2 dependent (paired) groups.
        This can also be used on 1 group.

        Null hypothesis: The median difference is zero 
        Alternative hypothesis: The median difference is negative

        Attribute: Example
    
        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareRanks
    
        DataFrame frame
        frame:Load("data.csv")
    
        CompareRanks compare
        compare:AddColumn(0)
        compare:AddColumn(1)
        compare:Paired(true)
        compare:Calculate(frame)
        output compare:GetSummary()
    */
    action Compare2DependentRanks(DataFrame frame)
        if GetColumnSize() < 1
            alert("Compare2DependentRanks must have at least one column.")
        end

        NumberColumn difference 
        if GetColumnSize() = 1
            difference = frame:GetColumn(GetColumn(0)):ConvertToNumberColumn()
        else
            NumberColumn left = frame:GetColumn(GetColumn(0)):ConvertToNumberColumn()
            NumberColumn right = frame:GetColumn(GetColumn(1)):ConvertToNumberColumn()
            if left:GetSize() not= right:GetSize()
                alert("Columns must be the same size.")
            end
            difference = left:Subtract(right)
        end
        difference:SetHeader("difference")

        NumberColumn noZerosDifference
        noZerosDifference:SetHeader("noZerosDifference")
        NumberColumn absoluteDifference
        absoluteDifference:SetHeader("absoluteDifference")
        i = 0
        repeat while i < difference:GetSize()
            number value = difference:GetAsNumber(i)
            if value not= 0 // Drop any zero difference from test
                if value < 0
                    absoluteDifference:Add(math:AbsoluteValue(value))
                else
                    absoluteDifference:Add(value)
                end
                noZerosDifference:Add(value)
            end
            i = i + 1
        end

        // Sort the data for the difference into ascending order by absolute difference.
        DataFrame sorted
        sorted:AddColumn(noZerosDifference)
        sorted:AddColumn(absoluteDifference)
        sorted:Sort("absoluteDifference")
        
        // Assign ranks to the sorted data points. Give tied values the average rank.
        ConvertColumnsToRanksTransform transform
        transform:AddColumn(1)
        DataFrame ranked = sorted:Transform(transform)

        // Reapply signs to ranks and add to postive or negative sums
        HashTable<text, number> sums
        sums:Add("positive", 0)
        sums:Add("negative", 0)
        DataFrameColumn values = sorted:GetColumn(0)
        DataFrameColumn ranksSigned = ranked:GetColumn(0):Copy()
        i = 0
        repeat while i < ranksSigned:GetSize()
            number value = values:GetAsNumber(i)
            number rank = ranksSigned:GetAsNumber(i)
            if value < 0
                ranksSigned:SetAsNumber(i, -1.0 * rank)
                sums:Set("negative", sums:GetValue("negative") + rank)
            else
                sums:Set("positive", sums:GetValue("positive") + rank)
            end
            i = i + 1
        end

        // Calculate the W Statistic, the smaller of the two sums
        number sumPos = sums:GetValue("positive")
        number sumNeg = sums:GetValue("negative")
        number W = math:MinimumOf(sumPos, sumNeg)

        // Calculate normal approximation and corrections
        number n = ranksSigned:GetSize()
        number meanW = (n * (n + 1)) / 4.0
        number varW = (n * (n + 1) * (2 * n + 1)) / 24.0
        number tieCorrectionSum = CalculateTieCorrectionSum(ranked:GetColumn(0)) // Do tie correction on unsigned ranks
        if tieCorrectionSum not= 0
            varW = varW - (tieCorrectionSum / 48.0) // The tie correction
        end
        number sdW = math:SquareRoot(varW)
        number correction = 0
        if useCorrection
            correction = 0.5 // The continuity correction
        end
        number z = (math:AbsoluteValue(W - meanW) - correction) / sdW

        // Calculate two-tailed probability value from normal distribution
        number p = 2.0 * (1.0 - zdistribution:CumulativeDistribution(z))

        output "sumPos: "+sumPos
        output "sumNeg: "+sumNeg
        output "W: "+W
        output "z: "+z
        output "p: "+p
    end

    /* 
        Kruskal-Wallis ranked one-way analysis of variance (ANOVA) for 3 or more independent groups.
        This can be used on 2 independent groups, although the better option would be the Mann-Whiteney U Test

        Null hypothesis: The population medians are equal
        Alternative hypothesis: The population medians are not equal

        Attribute: Example
    
        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareRanks
    
        DataFrame frame
        frame:Load("data.csv")
    
        CompareRanks compare
        compare:AddColumn(0)
        compare:AddColumn(1)
        compare:AddColumn(2)
        compare:Calculate(frame)
        output compare:GetSummary()
    */
    action CompareNIndependentRanks(DataFrame frame)
        if GetColumnSize() < 2
            alert("CompareNIndependentRanks must have at least two columns.")
        end

        // Sort the data for all groups/samples into ascending order in one combined set.
        TextColumn group
        group:SetHeader("group")
        NumberColumn data
        data:SetHeader("data")
        i = 0
        repeat while i < GetColumnSize()
            DataFrameColumn column = frame:GetColumn(GetColumn(i))
            if column:IsUndefined()
                alert("Column is undefined.")
            end

            if not column:IsNumberColumn() and not column:IsIntegerColumn()
                alert("Columns must be numerical. " + column:GetHeader() + " is not a numerical column.")
            end
            j = 0
            repeat while j < column:GetSize()
                group:Add(column:GetHeader())
                data:Add(column:GetAsNumber(j))
                j = j + 1
            end
            i = i + 1
        end

        DataFrame sorted
        sorted:AddColumn(group)
        sorted:AddColumn(data)
        sorted:Sort("data")

        // Assign ranks to the sorted data points. Give tied values the average rank.
        ConvertColumnsToRanksTransform transform
        transform:AddColumn(1)
        DataFrame ranked = sorted:Transform(transform)
        ranked:AddColumn(0, sorted:GetColumn(0))

        // Add up the different ranks for each group/sample.
        HashTable<text, number> sums
        DataFrameColumn groups = ranked:GetColumn(0)
        DataFrameColumn ranks = ranked:GetColumn(1)
        i = 0
        repeat while i < ranks:GetSize()
            if not sums:HasKey(groups:GetAsText(i))
                sums:Add(groups:GetAsText(i), ranks:GetAsNumber(i))
            else
                sums:Set(groups:GetAsText(i), sums:GetValue(groups:GetAsText(i)) + ranks:GetAsNumber(i))
            end
            i = i + 1
        end

        // Calculate the H statistic:
        number n = groups:GetSize() // Overall size (all sample sizes)
        number c = GetColumnSize()  // Number of samples
        number sumOfRanks = 0
        i = 0
        repeat while i < GetColumnSize()
            number tj = sums:GetValue(frame:GetColumn(GetColumn(i)):GetHeader()) // Sum of ranks in the jth sample
            number nj = frame:GetColumn(GetColumn(i)):GetSize() // Size of the jth sample

            sumOfRanks = sumOfRanks + (tj * tj / nj)
            i = i + 1
        end
        number h = (12.0 / (n * (n + 1))) * sumOfRanks - (3 * (n + 1)) 

        // Correct for ties in ranking.
        // See: https://www.dataanalytics.org.uk/adjustment-for-tied-ranks-in-the-kruskal-wallis-test/
        number tieCorrectionSum = CalculateTieCorrectionSum(ranks)
        if tieCorrectionSum not= 0
            number d = 1 - (tieCorrectionSum / ((n - 1) * n * (n + 1))) // The tie correction
            h = h / d
        end

        // Calculate probability value from chi-squared distribution
        number df = c-1
        x2distribution:Setup(df)
        number p = 1.0 - x2distribution:CumulativeDistribution(h)

        output "h: "+h
        output "df: "+df
        output "p: "+p
    end

    /* 
        Friedman rank sum one-way repeated measures analysis of variance (ANOVA) for 3 or more independent groups.
        This can be used on 2 dependent groups, although the better option would be the Wilcoxon Signed-Ranks Test
       
        Null hypothesis: the means of each of the groups are equal
        Alternative hypothesis: At least one group mean is not equal to the others.

        Attribute: Example
    
        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CompareRanks
    
        DataFrame frame
        frame:Load("data.csv")
    
        CompareRanks compare 
        compare:AddColumn(0)
        compare:AddColumn(1)
        compare:AddColumn(2)
        compare:RepeatedMeasures(true)
        compare:Calculate(frame)

        output compare:GetSummary()
    */
    action CompareNDependentRanks(DataFrame frame)
        if GetColumnSize() < 2
            alert("CompareNDependentRanks must have at least two columns.")
        end

        // Assign ranks, give tied values the average rank.
        ConvertColumnsToRanksTransform transform

        // Ensure the columns are all the same size
        // Make rotated dataframe at the same time
        DataFrame rotated
        i = 0
        repeat while i < GetColumnSize()
            DataFrameColumn column = frame:GetColumn(GetColumn(i))
            if column:IsUndefined()
                alert("Column is undefined.")
            end

            if not column:IsNumberColumn() and not column:IsIntegerColumn()
                alert("Columns must be numerical. " + column:GetHeader() + " is not a numerical column.")
            end
            j = 0
            repeat while j < column:GetSize()
                if i = 0
                    NumberColumn jCol
                    jCol:SetHeader(""+j)
                    jCol:Add(column:GetAsNumber(j))
                    rotated:AddColumn(jCol) // Add new column to rotated frame
                    transform:AddColumn(j)  // Add new column to ranking tranform
                else
                    rotated:GetColumn(j):Add(cast(text, column:GetAsNumber(j)))
                end
                j = j + 1   
            end        
            i = i + 1
        end

        // Rank the data for each subject (each column in rotated frame)
        DataFrame ranked = rotated:Transform(transform)
        output ranked:ToText()
       
        // Number of subjects
        integer n = ranked:GetColumns():GetSize()

        // Number of measurements (groups)
        integer k = GetColumnSize()

        number sumOfRanksSquared = 0
        number tieCorrectionSum = 0
        // Get a rank sum for each group (sample) (each row in ranked frame)
        Array <number> rankSums
        i = 0
        repeat while i < n
            DataFrameColumn column = ranked:GetColumn(i)
            j = 0
            repeat while j < column:GetSize()
                if i = 0
                    rankSums:Add(column:GetAsNumber(j))
                else
                    rankSums:Set(j, rankSums:Get(j) + column:GetAsNumber(j))
                end
                sumOfRanksSquared = sumOfRanksSquared + column:GetAsNumber(j) * column:GetAsNumber(j)
                j = j + 1
            end
        
            // If ties occurred, apply adjustment later
            tieCorrectionSum = tieCorrectionSum + CalculateTieCorrectionSum(column)
            i = i + 1
        end

        // Calculate Q Statistic:
        number sumOfRankSumsSquared = 0
        number sumOfRankCalcsSquared = 0 
        number subtract = (n * (k + 1)) / 2.0
        i = 0
        repeat while i < k
            number value = rankSums:Get(i)
            sumOfRankCalcsSquared = sumOfRankCalcsSquared + (value - subtract) * (value - subtract)
            sumOfRankSumsSquared = sumOfRankSumsSquared + value * value
            i = i + 1
        end  

        number q = (12.0 / (n * k * (k + 1))) * sumOfRankCalcsSquared
        if tieCorrectionSum not= 0
            number d = 1 - (tieCorrectionSum / (n * k * (k * k - 1))) // The tie correction
            q = q / d
        end
    
        // Calculate probability value from chi-squared distribution
        number df = k-1
        x2distribution:Setup(df)
        number p = 1.0 - x2distribution:CumulativeDistribution(q)

        output "q: "+q
        output "df: "+df
        output "p: "+p
    end

    /*
        This action calculates the sum portion of the tie corrections for each 
        of the tests in this class. If there were no ties in ranks, then the sum 
        will be zero.

        Returns: Σ (t^3 - t)
    */
    private action CalculateTieCorrectionSum(DataFrameColumn ranks) returns number
        number sum = 0
        DataFrameColumn count = ranks:Copy()
        HashTable<text,integer> hash = count:CalculateValueCountAsText()
        Iterator<integer> i = hash:GetValueIterator()
        integer result = 0
        repeat while i:HasNext()
            result = i:Next()
            sum = sum + (result * result * result - result)
        end
        return sum
    end

    /*
        This action summarizes the results and lists them informally.

        Attribute: Example

        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CorrelateRanks
    
        DataFrame frame
        frame:Load("Data/Data.csv")
    
        CorrelateRanks correlate
        correlate:Add(0)
        correlate:Add(1)
        frame:Calculate(correlate)
        
        output correlate:GetSummary()
    */
    action GetSummary returns text
        text summary = ""
//        text lf = summary:GetLineFeed()
//        Iterator<CorrelateGroupsResult> i = results:GetValueIterator()
//        CorrelateGroupsResult result 
//        repeat while i:HasNext()
//            result = i:Next()
//
//            summary = summary + lf
//            summary = summary + result:GetSummary()
//            summary = summary + lf
//        end

        return summary
    end

    /*
        This action summarizes the results and places them into formal academic language, in 
        APA format.

        For more information: https://apastyle.apa.org/instructional-aids/numbers-statistics-guide.pdf

        Attribute: Example

        use Libraries.Compute.Statistics.DataFrame
        use Libraries.Compute.Statistics.Tests.CorrelateRanks
    
        DataFrame frame
        frame:Load("Data/Data.csv")
    
        CorrelateRanks correlate
        correlate:Add(0)
        correlate:Add(1)
        frame:Calculate(correlate)
        
        output correlate:GetFormalSummary()
    */
    action GetFormalSummary returns text
//        StatisticsFormatting format = GetStatisticalFormatting()
        text summary = ""
//        text lf = summary:GetLineFeed()
//        Iterator<CorrelateGroupsResult> i = results:GetValueIterator()
//        CorrelateGroupsResult result 
//        repeat while i:HasNext()
//            result = i:Next()
//            result:SetFormat(format)
//
//            summary = summary + lf
//            summary = summary + result:GetFormalSummary()
//            summary = summary + lf
//        end

        return summary
    end
end