package Libraries.Language.Compile
use Libraries.Containers.Array
use Libraries.Containers.Iterator
use Libraries.Language.Compile.Symbol.Class
use Libraries.Language.Compile.Symbol.Action
use Libraries.Language.Compile.Symbol.Block
use Libraries.Language.Compile.Symbol.Variable
use Libraries.System.File
use Libraries.Language.Compile.Symbol.Type
use Libraries.Language.Compile.Symbol.SymbolTable
use Libraries.Containers.HashTable
use Libraries.Language.Compile.Parsing.QuorumLexer
use Libraries.Language.Compile.Parsing.ActionIndexSort
use Libraries.Language.Compile.Parsing.QuorumLexerConstants
use Libraries.Language.Compile.Parsing.TokenIterator
use Libraries.Language.Compile.Parsing.Token
use Libraries.Containers.Stack
use Libraries.Language.Compile.Parsing.QuorumParser
use Libraries.Language.Compile.Context.ParseContext
use Libraries.Language.Compile.CodeCompletionListener
use Libraries.Language.Compile.Translate.QuorumOpcode
use Libraries.Language.Compile.Context.VariableFunctionCallContext
use Libraries.Language.Compile.Symbol.TypeChecker

class CodeCompletionHandler 
    constant text USE = "use"
    constant text PACKAGE = "package"
    QuorumLexerConstants constants
    ActionIndexSort actionSorter

    private action AddUseResults(CodeCompletionRequest request, CodeCompletionResult result, boolean isUse)
        text trim = request:line
        trim = trim:Trim()
        if isUse
            trim = trim:GetSubtext(USE:GetSize())
        else
            trim = trim:GetSubtext(PACKAGE:GetSize())
        end

        trim = trim:Trim()
        Array<text> values = trim:Split("\.")
        result:SetUsage(true)

        integer filterSize = 0
        if not values:IsEmpty() and not trim:IsEmpty()
            if trim:GetCharacter(trim:GetSize() - 1) = "."
                result:filter = ""
            else
                result:filter = values:Get(values:GetSize() - 1)
            end

            text filter = result:filter
            filterSize = filter:GetSize()
        end

        constant text root = "Libraries"
        if values:GetSize() = 1
            text left = values:Get(0)
            text leftTrimmed = left:Trim()
            if leftTrimmed:IsEmpty()
                CodeCompletionItem item
                item:SetType(item:PACKAGE)
                item:displayText = root
                item:documentationText = "Root package in Quorum"
                item:completionText = root
                text filter = ""
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:filter = filter
                result:Add(item)
                AddCustomClasses(request, result, root)
            elseif left = root
                AddSubpackagesAndClasses(request, result, root)
                AddCustomClasses(request, result, root)
            elseif root:StartsWith(left)
                CodeCompletionItem item
                item:SetType(item:PACKAGE)
                item:displayText = root
                item:completionText = root
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
                AddCustomClasses(request, result, root)
            end
        else 
            text valueNoFilter = trim:GetSubtext(0, trim:GetSize() - filterSize - 1)
            AddSubpackagesAndClasses(request, result, valueNoFilter)
        end
    end

    action Request(CodeCompletionRequest request) returns CodeCompletionResult
        CodeCompletionResult result
        if request:result = undefined or request:result:symbolTable = undefined
            return result
        end

        text source = request:source
        integer index = request:caretLocation
        text line = GetLineBeforeCursor(index, source)
        request:unmodifiedLine = line
        result:prefix = line
        text trimmed = line:Trim()
        request:line = trimmed
        boolean isUse = trimmed:StartsWith("use")
        boolean isPackage = trimmed:StartsWith("package")

        text requestLine = request:line //this is already trimmed
        Array<text> split = requestLine:Split(":")
        CompilerResult compilerResult = request:result
        CompilerResult lastCompiledResult = request:lastCompiledResult

        //now set the filter for this particular request
        SetFilter(result, split, line)
        if not split:IsEmpty() and not line:IsEmpty()
            i = 0
            text left = ""
            repeat while i < split:GetSize()
                left = left + split:Get(i)
                if i not= split:GetSize() - 1
                    left = left + ":"
                end
                i = i + 1
            end

            request:left = left
        end


        SymbolTable last = undefined
        SymbolTable compiled = undefined
        if compilerResult not= undefined
            last = compilerResult:symbolTable
        end

        if lastCompiledResult not= undefined
            compiled = lastCompiledResult:symbolTable
        end

        if last not= undefined 
            Class lastClazz = last:GetClassInFile(request:fileKey)
            if lastClazz not= undefined
                request:clazzCurrentParse = lastClazz
            end
        end

        Class clazz = GetBestChoiceClass(request:result, lastCompiledResult, request:fileKey)
        SymbolTable table = GetBestChoiceSymbolTable(request:result, lastCompiledResult)

        QuorumLexer luthor
        luthor:Read(source)
        TokenIterator<Libraries.Language.Compile.Parsing.Token> tokenIterator = luthor:GetIterator()

        //true or true  or true and false
        request:clazz = clazz
        request:table = table
        CalculateScope(request:caretLocation, tokenIterator, request)

        if (clazz = undefined or table = undefined) // or not IsLegalCall(request, request:clazzCurrentParse, split)
            and not (isUse or isPackage)
            return result
        end

        
        //FindLocation(request, clazz)
        //CheckIfVariableCall(request, result, clazz, split)

        if isUse
            AddUseResults(request, result, true)
        elseif not isUse and isPackage
            AddUseResults(request, result, false)
        elseif not isUse and not isPackage
            AddParsedRegion(request, result)
        end

        return result
    end

    private action AddParsedRegion(CodeCompletionRequest request, CodeCompletionResult result)
        Class clazz = request:clazz
        Action method = request:method
        Block block = request:block

        //we are in the field region, so work there
        if block = undefined and method = undefined
            AddFieldRegion(request, result)
        //if there is ever a case where the block is undefined and the method isn't, that's a compiler
        //bug. The method "has" a block, so it shouldn't happen ever.
        elseif block not= undefined and (method not= undefined or (clazz not= undefined and clazz:IsImplicitClass()))
            AddActionRegion(request, result)
        end
    end

    private action GetSortedActions(Class clazz) returns Array<Action> 
        Iterator<Action> iterator = clazz:GetActions()

        Array<Action> actions
        repeat while iterator:HasNext()
            actions:Add(iterator:Next())
        end

        
        actions:Sort(actionSorter)
        return actions
    end

    private action GetSortedBlocks(Action act) returns Array<Block>
        Array<Block> blocks
        Block block = act:GetBlock()
        

        if block not= undefined
            blocks:Add(block)

            Iterator<Block> actionBlocks = block:GetBlocks()
            repeat while actionBlocks:HasNext()
                block = actionBlocks:Next()
                blocks:Add(block)
                FillFromBlock(blocks, block)
            end
        end
        return blocks
    end

    private action FillFromBlock(Array<Block> blocks, Block block)
        Iterator<Block> iterator = block:GetBlocks()
        repeat while iterator:HasNext()
            Block next = iterator:Next()
            blocks:Add(next)
            FillFromBlock(blocks, next)
        end
    end

    private action IsInToken(integer index, Libraries.Language.Compile.Parsing.Token token) returns boolean
        if index >= token:startIndex// and index < token:endIndex
            return true
        end

        return false
    end

    private action CalculateScope(integer index, TokenIterator<Libraries.Language.Compile.Parsing.Token> iterator, CodeCompletionRequest request)
        if request = undefined or request:clazz = undefined or iterator = undefined or index < 0
            return now
        end

        Class clazz = request:clazz
        integer actionIndex = -1
        integer blockIndex = 0
        integer candidateBlock = -1
        Stack<Block> blockStack
        Array<Action> actions = GetSortedActions(clazz)
        Array<Block> blocks = undefined
        if clazz not= undefined and clazz:IsImplicitClass()
            Action main = actions:Get(0) //must be one
            blocks = GetSortedBlocks(main)
            request:block = main:GetBlock()
            blockStack:Push(request:block)
        end

        boolean inClass = false
        boolean inAction = false
        repeat while iterator:HasNext() 
            Libraries.Language.Compile.Parsing.Token token = iterator:Next()
            if token:category = constants:CLASS
                request:clazz = clazz
                inClass = true
            elseif token:category = constants:ACTION
                actionIndex = actionIndex + 1
                if IsInToken(index, token) and actionIndex < actions:GetSize() and actionIndex >= 0
                    request:method = actions:Get(actionIndex)
                    request:block = request:method:GetBlock()
                    blockStack:Push(request:block)
                    blocks = GetSortedBlocks(request:method)
                    blockIndex = 0
                end
            elseif token:category = constants:IF
                blockIndex = blockIndex + 1
                if IsInToken(index, token) and blockIndex < blocks:GetSize() and blockIndex >= 0
                    request:block = blocks:Get(blockIndex)
                    blockStack:Push(request:block)
                end
            elseif token:category = constants:ELSE_IF
                blockIndex = blockIndex + 1
                if IsInToken(index, token) and blockIndex < blocks:GetSize() and blockIndex >= 0
                    request:block = blocks:Get(blockIndex)
                    blockStack:Push(request:block)
                end
            elseif token:category = constants:ELSE
                blockIndex = blockIndex + 1
                if IsInToken(index, token) and blockIndex < blocks:GetSize() and blockIndex >= 0
                    request:block = blocks:Get(blockIndex)
                    blockStack:Push(request:block)
                end
            elseif token:category = constants:REPEAT
                blockIndex = blockIndex + 1
                if index > token:startIndex and blockIndex < blocks:GetSize() and blockIndex >= 0
                    request:block = blocks:Get(blockIndex)
                    blockStack:Push(request:block)
                end
            elseif token:category = constants:CHECK
                blockIndex = blockIndex + 1
                if IsInToken(index, token) and blockIndex < blocks:GetSize() and blockIndex > 0
                    request:block = blocks:Get(blockIndex)
                    blockStack:Push(request:block)
                end
            elseif token:category = constants:DETECT
                blockIndex = blockIndex + 1
                if IsInToken(index, token) and blockIndex < blocks:GetSize() and blockIndex > 0
                    request:block = blocks:Get(blockIndex)
                    blockStack:Push(request:block)
                end
            elseif token:category = constants:ALWAYS
                blockIndex = blockIndex + 1
                if IsInToken(index, token) and blockIndex < blocks:GetSize() and blockIndex >= 0
                    request:block = blocks:Get(blockIndex)
                    blockStack:Push(request:block)
                end
            elseif token:category = constants:END  
                //it's constrained. If we are in a block and it's before the end, we have a winner
                //if it's not, then just decrement the values, as this isn't the right candidate
                if index <= token:endIndex
                    return now
                else //if there's a block left, pop it off
                    if not blockStack:IsEmpty()
                        request:block = blockStack:Pop()
                    else
                        request:block = undefined
                        request:method = undefined
                    end

                    if actionIndex >= actions:GetSize() - 1
                        inClass = false
                    end
                end
            end
        end

        //This is an implicit class, so get the implicit Main and use it as a block
        if not inClass
            Action act = clazz:GetAction("Main")
            if act not= undefined
                request:method = act
                request:block = act:GetBlock()
            end
        end
    end

    private action SetFilter(CodeCompletionResult result, Array<text> split, text line)
        if split:GetSize() > 0 and not line:IsEmpty()
            text ch = line:GetCharacter(line:GetSize() - 1)
            if ch = ":"
                result:filter = ""
            else
                result:filter = split:Get(split:GetSize() - 1)
            end
        end
    end

    private action GetBestChoiceClass(CompilerResult last, CompilerResult compiled, text file) returns Class
        if compiled not= undefined and compiled:symbolTable not= undefined
            Class clazz = compiled:symbolTable:GetClassInFile(file)
            if clazz not= undefined
                return clazz
            end
        end

        if last not= undefined and last:symbolTable not= undefined
            Class clazz = last:symbolTable:GetClassInFile(file)
            if clazz not= undefined
                return clazz
            end
        end

        return undefined
    end

    private action GetBestChoiceSymbolTable(CompilerResult last, CompilerResult compiled) returns SymbolTable
        if compiled not= undefined and compiled:symbolTable not= undefined
            return compiled:symbolTable
        end

        if last not= undefined and last:symbolTable not= undefined
            return last:symbolTable
        end

        return undefined
    end

    private action GetBestChoiceTypeChecker(CompilerResult last, CompilerResult compiled) returns TypeChecker
        if compiled not= undefined and compiled:typeChecker not= undefined
            return compiled:typeChecker
        end

        if last not= undefined and last:typeChecker not= undefined
            return last:typeChecker
        end

        return undefined
    end

    /*
        This checks if the request is within bounds and that the class is valid
    */
    private action IsLegalCall(CodeCompletionRequest request, Class clazz, Array<text> split) returns boolean
        //now we have checked the cache. If this is still undefined, bail
        if clazz not= undefined
            integer start = clazz:GetIndex()
            integer finish = clazz:GetIndexEnd()

            //is it inside of this class? If not, kill the request, because no syntax is legal
            if not(request:caretLocation >= start and request:caretLocation <= finish)
                clazz = undefined
                return false
            end

            if split:IsEmpty()
                clazz = undefined
                return false
            end
        else 
            return false
        end
        //the class is defined and within bounds.
        return true
    end

    private action FindLocation(CodeCompletionRequest request, Class clazz)
        Action method = GetActionAtIndex(request:clazzCurrentParse, request:caretLocation)
            
        Block block = undefined
        if method not= undefined
            block = GetBlockAtIndex(method:GetBlock(), request:caretLocation)
        end

        request:method = method
        request:block = block
    end

    private action CheckIfVariableCall(CodeCompletionRequest request, CodeCompletionResult result, 
        Class clazz, Array<text> split)
        text left = Trim(split:Get(0):Trim(), split, result)
        if left = undefined
            return now //should never return undefined unless the request is invalid
        end
        request:left = left

        if request:block not= undefined
            Variable variable = request:block:GetVariable(left)
            request:variable = variable

            if variable not= undefined
                Type type = variable:GetType()
                SymbolTable table = request:table

                if type not= undefined and not type:IsPrimitive()
                    text key = type:GetStaticKey()
                    Class varClass = table:GetClass(key)
                    request:variableClass = varClass
                    //in this case, the class isn't in the cache, but it might be in the 
                    //standard library if this table knows what library it is using
                    if request:variableClass = undefined
                        //we did not get lucky. Let's see if this class has been resolved
                        Class potential = clazz:GuessBestUsage(table, key)
                        if potential not= undefined
                            request:variableClass = potential
                            return now
                        end
                    end
                else 
                    if type not= undefined
                        text key = type:ConvertToNonPrimitiveStaticKey()
                        Class varClass = table:GetClass(key)
                        request:variableClass = varClass
                        request:isPrimitiveConversion = true
                    end
                end
            end
        end
    end


    private action AddRegion(CodeCompletionRequest request, CodeCompletionResult result)
        Class clazz = request:clazz
        Action method = request:method
        Block block = request:block

        //we are in the field region, so work there
        if block = undefined and method = undefined
            AddFieldRegion(request, result)
        //if there is ever a case where the block is undefined and the method isn't, that's a compiler
        //bug. The method "has" a block, so it shouldn't happen ever.
        elseif block not= undefined and method not= undefined
            AddActionRegion(request, result)
        end
    end

    private action AddAvailableClasses(CodeCompletionRequest request, CodeCompletionResult result)
        SymbolTable table = request:table
        Iterator<Class> classes = table:GetClasses()

        if classes not= undefined
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                CodeCompletionItem item = GetClassCompletionItem(clazz)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
            end
        end
    end

    private action AddActionRegion(CodeCompletionRequest request, CodeCompletionResult result)
        if request:left = "me"
            AddClassVariables(request, result)
            AddParentVariables(request, result)
        elseif request:left:IsEmpty()
            AddClassVariables(request, result)
            AddParentVariables(request, result)

            AddActions(request, result)
            AddBlockVariables(request, result)
            AddPrimitives(request, result)
            AddControlStructures(request, result)
            AddAvailableClasses(request, result)
        else  //if it's something else, just parse it

            text value = request:left
            if value = undefined
                return now
            end
            CodeCompletionListener listener
            listener:SetRequest(request)

            //first check if it is a plain old variable. If it is, get its type and move on. Otherwise, try to parse
            if request:block not= undefined
                Variable var = request:block:GetVariable(value)
                if var not= undefined
                    Type type = var:GetType()
                    listener:SetCanCodeComplete(true)
                    AddFromType(request, result, listener, type)
                    return now
                end
            elseif request:method not= undefined
                Variable var = request:method:GetParameter(value)
                if var not= undefined
                    Type type = var:GetType()
                    listener:SetCanCodeComplete(true)
                    AddFromType(request, result, listener, type)
                    return now
                end
            end

            //if wasn't a raw variable. Next check 
            boolean emptyFilter = false
            //it's not a simple case. Perhaps it is a colon delimited set of interactions?
            //we need to detect the case where there is an empty filter, which is if the line
            //has a colon at the end
            if request:line not= undefined and not request:line:IsEmpty()
                text char = request:line:GetCharacter(request:line:GetSize() - 1)
                if char = ":"
                    emptyFilter = true
                end
            end

            text newLine = StripAndTrimRightHandSide(value)
            Array<text> values = newLine:Split(":", true)
            if values = undefined
                return now
            end

            Type current = undefined
            Class currentClass = undefined
            //this wasn't a simple case

            integer size = values:GetSize() - 1
            if emptyFilter
                size = size + 1
            end
            i = 0
            repeat while i < size
                text next = values:Get(i)
                if next = undefined
                    return now
                end
                
                if current = undefined
                    //first check if it's a variable in a block
                    Variable var = request:block:GetVariable(next)
                    if var not= undefined
                        current = var:GetType()
                    else 
                        current = ParseExpressionFromText(request, result, listener, request:clazz, next)
                    end
                    //it's not a variable in a block. Is it is an action call?

                    currentClass = GetClassFromType(request, current)
                    if currentClass = undefined //there's a type, but some kind of mismatch in the type system
                        return now
                    end

                else //there's a type in the list, which means we're in the middle of processing
                    

                    //this isn't the last one, so try to determine the type from the last type and the value
                    //is it a field in the class?
                    Variable field = currentClass:GetVariable(next)
                    if field not= undefined
                        current = field:GetType()
                    else 
                        current = ParseExpressionFromText(request, result, listener, currentClass, next)
                    end
                    //it's not a variable in a block. Is it is an action call?

                    currentClass = GetClassFromType(request, current)
                    if currentClass = undefined //there's a type, but some kind of mismatch in the type system
                        return now
                    end
                end
                i = i + 1
            end

            //if it's the last one, this is actually the filter
            if i = values:GetSize() - 1 and not emptyFilter
                result:filter = values:Get(i)
                listener:SetCanCodeComplete(true)
                if current not= undefined
                    AddFromType(request, result, listener, current)
                else 
                    //this is the case where there is 1 value, it doesn't match a variable, 
                    //and we cannot find anything by this name, so assume it is a filter
                    //on top of a blank line
                    AddClassVariables(request, result)
                    AddParentVariables(request, result)
        
                    AddActions(request, result)
                    AddBlockVariables(request, result)
                    AddPrimitives(request, result)
                    AddControlStructures(request, result)
                    AddAvailableClasses(request, result)
                end
            
            else 
                listener:SetCanCodeComplete(true)
                AddFromType(request, result, listener, current)
            end
        end
    end

    private action StripAndTrimRightHandSide(text value) returns text
        if value = undefined or value:IsEmpty()
            return value
        end

        QuorumLexer lexer
        QuorumLexerConstants constants
        lexer:Read(value)

        //this is a bit overkill, but there might be other cases lurking
        TokenIterator<Libraries.Language.Compile.Parsing.Token> iterator = lexer:GetIterator()
        repeat while iterator:HasNext()
            Libraries.Language.Compile.Parsing.Token token = iterator:Next()
            if token = undefined
                return value
            else 
                //token:category
                if token:category = constants:IF or token:category = constants:ELSE_IF//remove the if and move forward
                    return value:GetSubtext(token:endIndex + 1):Trim()
                elseif token:category = constants:REPEAT
                    //if the next is while or until, skip that too, otherwise send it back
                    Libraries.Language.Compile.Parsing.Token next = iterator:Next()
                    if next not= undefined and 
                        (next:category = constants:WHILE or 
                         next:category = constants:UNTIL)
                        return value:GetSubtext(next:endIndex + 1):Trim()
                    else 
                        return value:GetSubtext(token:endIndex + 1):Trim()
                    end
                //if it's an ID, 
                elseif token:category = constants:ID
                    Libraries.Language.Compile.Parsing.Token next = iterator:Next()
                    if next not= undefined and 
                        (next:category = constants:EQUALITY)
                        return value:GetSubtext(next:endIndex + 1):Trim()
                    else //any other case, just return the value if it's an ID at the front.
                        return value
                    end
                end
            end
        end
        return value
    end

    private action ParseExpressionFromText(CodeCompletionRequest request, CodeCompletionResult result, 
        CodeCompletionListener listener, Class from, text value) returns Type
        CompilerErrorManager manager
        QuorumLexer luthor
        luthor:SetCompilerErrorManager(manager)
        luthor:Read(value)
        QuorumParser parser
        parser:SetCompilerErrorManager(manager)
        parser:SetLexer(luthor)

        VariableFunctionCallContext expression = parser:VariableSoloActionCall()
        //if we can parse it, do so. If not, we bail with nothing returned
        if expression not= undefined
            //see if we can get a valid type checker from the system
            TypeChecker checker = GetBestChoiceTypeChecker(request:result, request:lastCompiledResult)
            listener:SetTypeChecker(checker)

            listener:SetRequest(request)
            listener:SetCurrentClass(from)
            expression:Traverse(listener)

            Type returnType = listener:PeekTypeStack()
            listener:Empty()
            if returnType not= undefined
                return returnType
            end
        end
        return undefined
    end

    private action GetClassFromType(CodeCompletionRequest request, Type type) returns Class
        if type = undefined
            return undefined
        end
        Class cl = undefined
        if type:IsPrimitive()
            cl = request:table:GetClass(type:ConvertToNonPrimitiveStaticKey())
        else
            cl = request:table:GetClass(type:GetStaticKey())
        end

        return cl
    end

    private action ParseExpression(CodeCompletionRequest request, CodeCompletionResult result, 
        CodeCompletionListener listener)
        text value = request:left
        QuorumLexer luthor
        luthor:Read(value)
        QuorumParser parser
        parser:SetLexer(luthor)

        ParseContext expression = parser:Expression()
        //if we can parse it, do so. If not, we bail with nothing returned
        if expression not= undefined
            expression:Traverse(listener)

            Stack<QuorumOpcode> opcodes = listener:GetOpcodeStack()
            if opcodes:IsEmpty()
                return now //empty
            else //otherwise get the type of the top and call it a day
                QuorumOpcode op = opcodes:Pop() //pop it off
                Type type = op:GetType()

                AddFromType(request, result, listener, type)
            end
        end
    end

    private action AddFromType(CodeCompletionRequest request, CodeCompletionResult result, 
        CodeCompletionListener listener, Type type)
        if type = undefined
            return now
        end

        if not listener:CanCodeComplete() //if it's not a valid code completion, return nothing
            return now
        end
        if type not= undefined
            Class cl = undefined
            if type:IsPrimitive()
                cl = request:table:GetClass(type:ConvertToNonPrimitiveStaticKey())
            else
                cl = request:table:GetClass(type:GetStaticKey())
            end

            if cl = undefined and request:clazz not= undefined
                return now
            else
                if cl:GetStaticKey() not= request:clazz:GetStaticKey() 
                    request:variableClass = cl
                end
                AddClassVariables(request, result)
                AddParentVariables(request, result)
    
                AddActions(request, result)
            end
            return now
        end
    end

    private action AddFieldRegion(CodeCompletionRequest request, CodeCompletionResult result)
        if request:left = "me"
            AddClassVariables(request, result)
            AddParentVariables(request, result)
        elseif request:left:IsEmpty()
            AddClassVariables(request, result)
            AddParentVariables(request, result)
            AddPrimitives(request, result)
            AddAvailableClasses(request, result)
        end
    end

    private action AddPrimitives(CodeCompletionRequest request, CodeCompletionResult result)
        text filter = result:filter
        integer size = filter:GetSize()
        

        CodeCompletionItem intItem
        intItem:SetType(intItem:PRIMITIVE)
        intItem:displayText = "integer"
        intItem:completionText = "integer value = 0"
        intItem:dotOffset = request:caretLocation - size
        result:Add(intItem)

        CodeCompletionItem numItem
        numItem:SetType(intItem:PRIMITIVE)
        numItem:displayText = "number"
        numItem:completionText = "number value = 0"
        numItem:dotOffset = request:caretLocation - size
        result:Add(numItem)

        CodeCompletionItem boolItem
        boolItem:SetType(intItem:PRIMITIVE)
        boolItem:displayText = "boolean"
        boolItem:completionText = "boolean value = false"
        boolItem:dotOffset = request:caretLocation - size
        result:Add(boolItem)

        CodeCompletionItem textItem
        textItem:SetType(intItem:PRIMITIVE)
        textItem:displayText = "text"
        text dq = ""
        dq = dq:GetDoubleQuote()
        textItem:completionText = "text value = " + dq + dq
        textItem:dotOffset = request:caretLocation - size
        result:Add(textItem)
    end

    private action AddControlStructures(CodeCompletionRequest request, CodeCompletionResult result)
        text filter = result:filter
        integer size = filter:GetSize()

        text left = request:unmodifiedLine
        text space = GetWhiteSpaceAmount(left)
        text lf = left:GetLineFeed()

        CodeCompletionItem ifItem
        ifItem:SetType(ifItem:CONTROL_STRUCTURE)
        ifItem:displayText = "if"
        ifItem:completionText = "if true" + lf + space + "end"
        ifItem:dotOffset = request:caretLocation - size
        result:Add(ifItem)

        CodeCompletionItem repeatItem
        repeatItem:SetType(ifItem:CONTROL_STRUCTURE)
        repeatItem:displayText = "repeat"
        repeatItem:completionText = "repeat while false" + lf + space + "end"
        repeatItem:dotOffset = request:caretLocation - size
        result:Add(repeatItem)

        CodeCompletionItem repeatItem2
        repeatItem2:SetType(ifItem:CONTROL_STRUCTURE)
        repeatItem2:displayText = "repeat while <condition>"
        repeatItem2:completionText = "integer i = 0" + lf + space + "repeat while i < 10" + lf + lf + space + "    i = i + 1" + lf + space + "end"
        repeatItem2:dotOffset = request:caretLocation - size
        result:Add(repeatItem2)
    end

    private action GetWhiteSpaceAmount(text left) returns text
        text result = ""
        
        i = 0
        repeat while i < left:GetSize()
            text value = left:GetCharacter(i)
            if value = " "
                result = result + value
            elseif value = "    "
                result = result + value
            elseif value = value:GetCarriageReturn() or value = value:GetLineFeed() //note that it exists, but ignore it.
            else
                i = left:GetSize()
            end
            i = i + 1
        end
        return result
    end

    private action AddActions(CodeCompletionRequest request, CodeCompletionResult result)
        Class clazzToProcess = request:clazz
        if request:variableClass not= undefined
            clazzToProcess = request:variableClass
            if clazzToProcess not= undefined and request:clazz not= undefined
               and clazzToProcess:GetStaticKey() not= request:clazz:GetStaticKey()
                request:isRequestInClass = false
            end
        end

        if clazzToProcess = undefined
            return now
        end

        //if this is the current class, load all methods, public or private
        //if this is a variable, load only its public methods.
        Iterator<Action> actions = clazzToProcess:GetVirtualTable()
        repeat while actions:HasNext()
            Action act = actions:Next()
            CodeCompletionItem item = undefined
            if request:variable not= undefined
                item = act:GetCodeCompletionItem(request:variable)
            else
                item = act:GetCodeCompletionItem()
            end
            text filter = result:filter
            integer size = filter:GetSize()
            item:dotOffset = request:caretLocation - size// + additionalDotOffset

            //is this action in the base class or the v-table?
            if request:clazz:HasAction(act:GetStaticKey())
                item:isBaseClassAction = true
            end

            boolean isPrimitive = request:isPrimitiveConversion
            if isPrimitive
                text value = act:GetName()
                if value not= "GetValue" and value not= "SetValue"
                    if request:isRequestInClass
                        result:Add(item)
                    else
                        if not act:IsPrivate()
                            result:Add(item)
                        end
                    end
                end
            else
                if request:isRequestInClass
                    result:Add(item)
                else
                    if not act:IsPrivate()
                        result:Add(item)
                    end
                end
            end
        end
    end

    private action Trim(text left, Array<text> split, CodeCompletionResult result) returns text
        text line2 = left
        text trimmedLeft = left:Trim()
        integer i = line2:GetSize() - 1
        repeat while i >= 0
            text ch = line2:GetCharacter(i)
            if ch = "(" or ch = ","
                or ch = "*" or ch = "/"
                or ch = "+" or ch = "-"
                or ch = " " or IsMod(line2, i) 
                //make this work for mod --- if it's a d, check backwards and ensure that it's not part of another word

                //split the line again
                line2 = line2:GetSubtext(i + 1, line2:GetSize())
                left = line2
                line2 = line2:Trim()
                split = line2:Split(":")
                if split:IsEmpty()
                    return undefined
                end

                if split:GetSize() > 1 or line2:Contains(":")
                    text ch2 = line2:GetCharacter(line2:GetSize() - 1)
                    if ch2 = ":"
                        result:filter = ""
                    else
                        result:filter = split:Get(split:GetSize() - 1)
                    end
                end
                trimmedLeft = line2
                i = -1
            end
            i = i - 1
        end
        return trimmedLeft
    end

    /* Add all of the fields from this class */
    private action AddClassVariables(CodeCompletionRequest request, CodeCompletionResult result)
        Class clazzToProcess = request:clazz
        if request:variableClass not= undefined
            clazzToProcess = request:variableClass
            if clazzToProcess not= undefined and request:clazz not= undefined
               and clazzToProcess:GetStaticKey() not= request:clazz:GetStaticKey()
                request:isRequestInClass = false
            end
        end

        if clazzToProcess = undefined
            return now
        end

        Iterator<Variable> variables = clazzToProcess:GetVariables()
        repeat while variables:HasNext()
            Variable variable2 = variables:Next()
            if variable2:GetType() not= undefined
                CodeCompletionItem item = variable2:GetCodeCompletionItem(clazzToProcess)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size// + additionalDotOffset
                if request:isRequestInClass
                    result:Add(item)
                else
                    if not variable2:IsPrivate()
                        result:Add(item)
                    end
                end
            end
        end
    end

    private action AddParentVariables(CodeCompletionRequest request, CodeCompletionResult result)
        //now add all of the parent fields from this class
        Iterator<Class> parents = request:clazz:GetParentClasses()
        repeat while parents:HasNext()
            Class par = parents:Next()
            Iterator<Variable> variables2 = par:GetVariables()
            repeat while variables2:HasNext()
                Variable variable2 = variables2:Next()
                if variable2:GetType() not= undefined
                    CodeCompletionItem item = variable2:GetCodeCompletionItem(request:clazz)
                    if item not= undefined and variable2:IsPrivate()
                        item:SetType(item:PARENT_FIELD_PRIVATE)
                    elseif item not= undefined and not variable2:IsPrivate()
                        item:SetType(item:PARENT_FIELD_PUBLIC)
                    end

                    text filter = "parent:"
                    integer size = filter:GetSize()
                    item:dotOffset = request:caretLocation - size
                    if request:isRequestInClass
                        result:Add(item)
                    else
                        if not variable2:IsPrivate()
                            result:Add(item)
                        end
                    end
                end
            end
        end
    end

    private action AddVariable(CodeCompletionRequest request, CodeCompletionResult result, Variable variable)
        if variable:GetType() not= undefined
            CodeCompletionItem item = variable:GetCodeCompletionItem(request:clazz)
            text filter = result:filter
            integer size = filter:GetSize()
            item:dotOffset = request:caretLocation - size// + additionalDotOffset
            if request:isRequestInClass
                result:Add(item)
            else
                if not variable:IsPrivate()
                    result:Add(item)
                end
            end
        end
    end

    private action AddBlockVariables(CodeCompletionRequest request, CodeCompletionResult result)
        Iterator<Variable> variables = request:block:GetVariablesAllBlocks()
        repeat while variables:HasNext()
            Variable variable = variables:Next()
            if variable not= undefined and variable:IsVisibleToDebugger()
                AddVariable(request, result, variable)
            end
        end

        Action method = request:method
        if method not= undefined
            Iterator<Variable> parameters = method:GetParameterIterator()
            repeat while parameters:HasNext()
                Variable variable = parameters:Next()
                if variable not= undefined and variable:IsVisibleToDebugger()
                    AddVariable(request, result, variable)
                end
            end
        end
    end

    private action IsMod(text partial, integer i) returns boolean
        if i - 3 < 0
            return false
        end

        if partial:GetCharacter(i) = "d"
            and partial:GetCharacter(i - 1) = "o"
            and partial:GetCharacter(i - 2) = "m"
            and partial:GetCharacter(i - 3) = " "
            return true
        end

        return false
    end

    private action GetLineBeforeCursor(integer loc, text source) returns text
        if loc - 1 <= source:GetSize()
            integer i = loc - 1
            text CR = source:GetLineFeed()

            integer start = 0
            repeat while i >=0 
                text ch = source:GetCharacter(i)
                if ch = CR //this is the end of the line
                    start = i
                    i = -1
                end
                i = i - 1
            end
            
            text sub = source:GetSubtext(start, loc)
            return sub
        end

        return undefined
    end
    
    private action GetCustomClassesInPackage(CodeCompletionRequest request, CodeCompletionResult result, text pack)
        returns HashTable<text, Class>

        SymbolTable sandboxSymbolTable = request:result:symbolTable
        HashTable<text, Class> results
        Iterator<Class> classes = sandboxSymbolTable:GetClassesInPackage(pack)
        if classes not= undefined
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                if not results:HasKey(clazz:GetStaticKey())
                    results:Add(clazz:GetStaticKey(), clazz)
                end
            end
        end

        Library library = FindStandardLibrary(request, result, sandboxSymbolTable)
        if library not= undefined
            SymbolTable table = library:GetSymbolTable()
            if table = undefined
                return results
            end
            classes = table:GetClassesInPackage(pack)
            if classes not= undefined
                repeat while classes:HasNext()
                    Class clazz = classes:Next()
                    if not results:HasKey(clazz:GetStaticKey())
                        results:Add(clazz:GetStaticKey(), clazz)
                    end
                end
            end
        end
        return results
    end

    private action AddCustomClasses(CodeCompletionRequest request, CodeCompletionResult result, text pack)
        SymbolTable sandboxSymbolTable = request:result:symbolTable
        Iterator<Class> classes = undefined

        HashTable<text, Class> results = GetCustomClassesInPackage(request, result, pack)
        classes = results:GetValueIterator()
        repeat while classes not= undefined and classes:HasNext()
            Class clazz = classes:Next()
            CodeCompletionItem item = GetClassCompletionItem(clazz)
            text filter = result:filter
            integer size = filter:GetSize()
            item:dotOffset = request:caretLocation - size
            result:Add(item)
        end
    end

    private action GetClassCompletionItem(Class clazz) returns CodeCompletionItem
        CodeCompletionItem item
        item:SetType(item:CLASS)

        text signature = clazz:GetStaticKey()
        text name = clazz:GetName()

        text description = ""
        description = description + "<h1>" + signature + "</h1>"

        item:displayText = name
        item:completionText = name
        item:documentationText = "Test"
        return item
    end

    private action GetPackageCompletionItem(text pack) returns CodeCompletionItem
        CodeCompletionItem item
        item:SetType(item:PACKAGE)

        text signature = pack
        text name = pack

        text description = "<h1>" + signature + "</h1>"

        item:displayText = name
        item:completionText = name
        item:documentationText = ""
        return item
    end

    private action FindStandardLibrary(CodeCompletionRequest request, CodeCompletionResult result, SymbolTable table)
        returns Library

        //the code completion system should tell us which standard library we're using.
        Library library = request:library
        if library not= undefined
            return library
        end

        //if it doesn't, ask the table
        library = table:GetLibrary()
        if library not= undefined
            return library
        end
        return library
    end

    private action GetValidNamesFromTable(CodeCompletionRequest request, CodeCompletionResult result, text name)
        returns HashTable<text, text>
        SymbolTable sandboxSymbolTable = request:table
        HashTable<text, text> names

        Iterator<text> packs = sandboxSymbolTable:GetSubpackageNames(name)
        repeat while packs:HasNext()
            text pack = packs:Next()
            names:Add(pack,pack)
        end

        Library library = FindStandardLibrary(request, result, sandboxSymbolTable)
        if library not= undefined
            SymbolTable table = library:GetSymbolTable()
            if table = undefined
                return names
            end
            packs = table:GetSubpackageNames(name)
            repeat while packs:HasNext()
                text pack = packs:Next()
                names:Add(pack,pack)
            end
        end
        return names
    end

    private action AddSubpackagesAndClasses(CodeCompletionRequest request, CodeCompletionResult result, text name)
        SymbolTable sandboxSymbolTable = request:table
        //first find all of the packages/sub-packages 
        HashTable<text,text> value = GetValidNamesFromTable(request, result, name)
        Iterator<text> packs = value:GetValueIterator()
        repeat while packs:HasNext()
            text pack = packs:Next()
            
            integer size = name:GetSize() + 1
            text subpackName = pack:GetSubtext(0, size)
            text filteredName = subpackName + result:filter
            subpackName = pack:GetSubtext(size, pack:GetSize())

            if pack:StartsWith(filteredName)
                CodeCompletionItem item = GetPackageCompletionItem(subpackName)
                text filter = result:filter
                integer size2 = filter:GetSize()
                item:dotOffset = request:caretLocation - size2
                result:Add(item)
            end
        end

        HashTable<text, Class> results = GetCustomClassesInPackage(request, result, name)

        //next find any classes on the system in the package
        Iterator<Class> classesInPackage = results:GetValueIterator()//sandboxSymbolTable:GetClassesInPackage(name)
        boolean hasAny = false
        if classesInPackage not= undefined
            hasAny = classesInPackage:HasNext()
            repeat while classesInPackage:HasNext()
                Class pack = classesInPackage:Next()
                text key = pack:GetStaticKey()
                CodeCompletionItem item = GetClassCompletionItem(pack)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
            end
        end
        
        //finally, remind the user they can use the "all" keyword
        if hasAny
            CodeCompletionItem item
            item:SetType(item:PACKAGE)
            text DQ = ""
            DQ = DQ:GetDoubleQuote()
            text signature = "Use all classes with the " + DQ + "all" + DQ + " keyword."
            text itemName = "all"

            text description = "<h1>" + signature + "</h1>"
                    + "<p align=" + DQ + "justify" + DQ + ">The word "
                    + "all indicates to quorum that we would like to"
                    + " have access to all classes in the package. For "
                    + "example, the phrase Libraries.Containers.all would indicate "
                    + "that we want to use any class in the Libraries.Containers "
                    + "package."
                    + "</p>"
            description = description + "<h2>" + "Code Example:" + "</h2>"
            description = description + "<PRE><CODE>"
                    + "use Libraries.Containers.all\n\n"
                    + "List&lt;integer&gt; list\n"
                    + "Array&lt;integer&gt; array"
                    + "</PRE></CODE>"

            item:displayText = itemName
            item:documentationText = description
            item:completionText = "all"
            text filter = result:filter
            integer size = filter:GetSize()
            item:dotOffset = request:caretLocation - size
            result:Add(item)
        end
    end

    /*
        Obtains the logical block located at this index. 
    */
    private action GetBlockAtIndex(Block block, integer index) returns Block
        Block bestBlock = undefined

        if block not= undefined
            boolean test = IsIndexInLocation(block, index)
            if test
                bestBlock = block
            end
            //get subblocks and try those
            //this call recursively calls to subblocks, thus no need
            //for going deeper in this loop exists
            Iterator<Block> blocks = block:GetBlocks()
            repeat while blocks:HasNext()
                Block b = blocks:Next()
                Block returnedBlock = GetBlockAtIndex(b, index)
                if returnedBlock not= undefined
                    if IsIndexInLocation(returnedBlock, index)
                        integer start = returnedBlock:GetIndex()
                        integer finish = returnedBlock:GetIndexEnd()
                        integer range = finish - start

                        if bestBlock = undefined
                            bestBlock = returnedBlock
                        else
                            integer bestStart = bestBlock:GetIndex()
                            integer bestFinish = bestBlock:GetIndexEnd()
                            integer bestRange = bestFinish - bestStart
                            //this block is nested 
                            if range < bestRange
                                bestBlock = returnedBlock
                            end
                        end
                    end
                end
            end
        end

        return bestBlock
    end

    private action IsIndexInLocation(Location location, integer index) returns boolean
        integer start = location:GetIndex()
        integer finish = location:GetIndexEnd()
        if index >= start and index <= finish
            return true
        end

        return false
    end

    private action GetActionAtIndex(Class clazz, integer index) returns Action
        Action act = undefined
        if clazz = undefined
            return undefined
        end
        File file = clazz:GetFile()
        text classPath = file:GetAbsolutePath()

        Iterator<Action> actions = clazz:GetActions()
        repeat while actions:HasNext()
            Action a = actions:Next()
            integer start = a:GetIndex()
            integer finish = a:GetIndexEnd()
            File f = a:GetFile()
            if f not= undefined
            text actionPath = f:GetAbsolutePath()
                if index >= start and index <= finish and classPath = actionPath
                    act = a
                    return act
                end
            end
        end
        //check the constructor
        if act = undefined
            Action constructor = clazz:GetConstructor()
            if constructor not= undefined
                integer start = constructor:GetIndex()
                integer finish = constructor:GetIndexEnd()
                File f = constructor:GetFile()
                if f not= undefined
                    text actionPath = f:GetAbsolutePath()
                    if index >= start and index <= finish and classPath = actionPath
                        act = constructor
                        return act
                    end
                end
            end
        end
        return act
    end
end