use Libraries.Compute.Statistics.DataFrame
use Libraries.Language.Compile.Parsing.QuorumLexer
use Libraries.Language.Compile.CompilerErrorManager
use Libraries.Language.Compile.Parsing.QuorumParser
use Libraries.Language.Compile.Context.ParseContext
use Libraries.Compute.Statistics.Transforms.DataFrameExpressionListener
use Libraries.Language.Compile.Interpreter.Runtime
use Libraries.Containers.Array
use Libraries.Containers.Stack
use Libraries.Language.Compile.Translate.QuorumOpcode
use Libraries.Language.Compile.Symbol.Type
use Libraries.Language.Compile.Interpreter.Result
use Libraries.Compute.Statistics.DataFrameColumn
use Libraries.Language.Compile.Interpreter.RuntimeBlock
use Libraries.Compute.Statistics.Columns.IntegerColumn

class DataFrame2 is DataFrame
    action Filter(text source)
        QuorumLexer luthor
        CompilerErrorManager errors
        luthor:SetCompilerErrorManager(errors)
        luthor:Read(source)

        if not errors:IsCompilationErrorFree()
            alert(errors:GetFirstMessageAsText())
        end

        QuorumParser parser
        parser:SetCompilerErrorManager(errors)
        parser:SetLexer(luthor)

        ParseContext expression = parser:Expression()

        if expression = undefined or not errors:IsCompilationErrorFree()
            alert(errors:GetFirstMessageAsText())
        end
    
        //Now do semantic analysis on the thing and get it setup for runtime processing
        DataFrameExpressionListener listener
        listener:SetCompilerErrorManager(errors)
        listener:SetDataFrame(me)
        expression:Traverse(listener)
        
        if not errors:IsCompilationErrorFree()
            alert(errors:GetFirstMessageAsText())
        end

        //the top-most item on the stack is the final expression
        Stack<QuorumOpcode> stack = listener:GetOpcodeStack()

        if stack:IsEmpty()
            alert("The expression contained an unidentified error and could not be evaluated.")
        end
        QuorumOpcode op = stack:Pop()

        Type result = op:GetType()
        if not result:IsBoolean()
            alert("The expression passed must evaluate to a boolean, but evaluated to a " + result:GetStaticKey() + ".")
        end

        Array<text> variables
        integer startingPosition = 0

        Array<integer> sizes
        integer change = 0
        repeat while change < me:GetSize()
            sizes:Add(startingPosition)
            change = change + 1
        end

        //if we still look good, then create a runtime context
        //and check it against every row, changing the value for every column
        Runtime runtime
        row = startingPosition
        integer skip = 0
        boolean done = false
        repeat while not done
            //first check that all the variables in the list are there
            //if there are zero variables, then just process the expression for now, even though technically it's a constant
            SetupRuntime(runtime, me, row)
            op:Evaluate(runtime)

            boolean markForRemoval = false
            Result value = runtime:PopFromStack()
            if value = undefined or not value:booleanValue //get rid of the row
                markForRemoval = true
                skip = skip + 1
            end

            //now move the row if necessary, possibly skipping along
            MoveRow(me, row, skip, sizes, markForRemoval)

            done = not HasAnotherRow(me, row)
            row = row + 1
        end

        i = 0
        repeat while i < sizes:GetSize()
            integer size = sizes:Get(i)
            DataFrameColumn col = me:GetColumn(i)
            col:SetSize(size)
            i = i + 1
        end

        output me:ToText()
    end

    private action SetupRuntime(Runtime runtime, DataFrame frame, integer row)
        integer column = 0
        RuntimeBlock block = runtime:GetCurrentBlock()

        //get the row for each column
        repeat while column < frame:GetSize()
            DataFrameColumn dc = frame:GetColumn(column)
            if row < dc:GetSize() //get the value at this point and put it in as a variable name
                text header = dc:GetHeader()
                Result result = GetResultFromColumn(dc, row)
                if result not= undefined
                    block:SetVariableResult(header, result)
                end
            end
            column = column + 1
        end
    end

    private action GetResultFromColumn(DataFrameColumn column, integer row) returns Result
        if column:IsUndefined(row)
            return undefined
        end

        Result result
        Type type
        result:type = type
        if column:IsIntegerColumn()
            type:SetToInteger()
            result:integerValue = column:GetAsInteger(row)
        elseif column:IsNumberColumn()
            type:SetToNumber()
            result:numberValue = column:GetAsNumber(row)
        elseif column:IsBooleanColumn()
            type:SetToBoolean()
            result:booleanValue = column:GetAsBoolean(row)
        elseif column:IsTextColumn()
            type:SetToText()
            result:textValue = column:GetAsText(row)
        end

        return result
    end

    private action GetTypeFromColumn(DataFrameColumn column) returns Type
        Type type
        if column:IsIntegerColumn()
            type:SetToInteger()
        elseif column:IsNumberColumn()
            type:SetToNumber()
        elseif column:IsBooleanColumn()
            type:SetToBoolean()
        elseif column:IsTextColumn()
            type:SetToText()
        end

        return type
    end

    private action HasAnotherRow(DataFrame frame, integer row) returns boolean
        integer column = 0
        //get the row for each column
        repeat while column < frame:GetSize()
            DataFrameColumn dc = frame:GetColumn(column)
            if row < dc:GetSize()
                return true
            end
            column = column + 1
        end
        return false
    end

    private action MoveRow(DataFrame frame, integer row, integer skip, Array<integer> sizes, boolean markForRemoval)
        if skip = 0
            i = 0
            repeat while i < sizes:GetSize()
                sizes:Set(i, sizes:Get(i) + 1)
                i = i + 1
            end
            return now
        end

        integer column = 0
        integer i = row
        repeat while column < frame:GetSize()
            DataFrameColumn col = frame:GetColumn(column)

            //make sure there are actually rows here
            if i + 1 < col:GetSize()
                col:Move(i+1, i + 1 - skip)
                if not markForRemoval
                    sizes:Set(column, sizes:Get(column) + 1)
                end
            elseif i = col:GetSize() - 1 //only move this if it's not removed
                if not markForRemoval
                    col:Move(i, i - skip)
                    sizes:Set(column, sizes:Get(column) + 1)
                end
            end
            column = column + 1
        end
    end

    action Main
        IntegerColumn column0
        IntegerColumn column1
        AddColumnOnLoad(0, column0)
        AddColumnOnLoad(1, column1)
        Load("files/Data.csv")

        //this is always true, so every row should be allowed
        Filter("Group > 0 and Result < -13")
        a = 5
    end
end