package Libraries.Language.Compile
use Libraries.Containers.Array
use Libraries.Containers.Iterator
use Libraries.Language.Compile.Symbol.Class
use Libraries.Language.Compile.Symbol.Action
use Libraries.Language.Compile.Symbol.Block
use Libraries.Language.Compile.Symbol.Variable
use Libraries.System.File
use Libraries.Language.Compile.Symbol.Type
use Libraries.Language.Compile.Symbol.SymbolTable
use Libraries.Containers.HashTable

class CodeCompletionHandler 
    constant text USE = "use"
    constant text PACKAGE = "package"
    //HashTable<text, Class> lastGoodCompileHash

    private action AddUseResults(CodeCompletionRequest request, CodeCompletionResult result, boolean isUse)
        text trim = request:line
        trim = trim:Trim()
        if isUse
            trim = trim:GetSubtext(USE:GetSize())
        else
            trim = trim:GetSubtext(PACKAGE:GetSize())
        end

        trim = trim:Trim()
        Array<text> values = trim:Split("\.")

        integer filterSize = 0
        if not values:IsEmpty() and not trim:IsEmpty()
            if trim:GetCharacter(trim:GetSize() - 1) = "."
                result:filter = ""
            else
                result:filter = values:Get(values:GetSize() - 1)
            end

            text filter = result:filter
            filterSize = filter:GetSize()
        end

        constant text root = "Libraries"
        if values:GetSize() = 1
            text left = values:Get(0)
            text leftTrimmed = left:Trim()
            if leftTrimmed:IsEmpty()
                CodeCompletionItem item
                item:SetType(item:PACKAGE)
                item:displayText = root
                item:completionText = root
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
                AddCustomClasses(request, result, root)
            elseif left = root
                AddSubpackagesAndClasses(request, result, root)
                AddCustomClasses(request, result, root)
            elseif root:StartsWith(left)
                CodeCompletionItem item
                item:SetType(item:PACKAGE)
                item:displayText = root
                item:completionText = root
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
                AddCustomClasses(request, result, root)
            end
        else 
            text valueNoFilter = trim:GetSubtext(0, trim:GetSize() - filterSize - 1)
            AddSubpackagesAndClasses(request, result, valueNoFilter)
        end
    end

    action Request(CodeCompletionRequest request) returns CodeCompletionResult
        CodeCompletionResult result
        if request:result = undefined or request:result:symbolTable = undefined
            return result
        end

        text source = request:source
        integer index = request:caretLocation
        text line = GetLineBeforeCursor(index, source)
        result:prefix = line
        text trimmed = line:Trim()
        request:line = trimmed
        boolean isUse = trimmed:StartsWith("use")
        boolean isPackage = trimmed:StartsWith("package")

        if isUse
            AddUseResults(request, result, true)
        elseif not isUse and isPackage
            AddUseResults(request, result, false)
        elseif not isUse and not isPackage
            AddExpressionResults(request, result)
        end

        return result
    end

    private action AddExpressionResults(CodeCompletionRequest request, CodeCompletionResult result)
        text line = request:line //this is already trimmed
        Array<text> split = line:Split(":")
        CompilerResult compilerResult = request:result
        CompilerResult lastCompiledResult = request:lastCompiledResult

        //now set the filer for this particular request
        if split:GetSize() > 0 and not line:IsEmpty()
            text ch = line:GetCharacter(line:GetSize() - 1)
            if ch = ":"
                result:filter = ""
            else
                result:filter = split:Get(split:GetSize() - 1)
            end
        end
        SymbolTable sandboxSymbolTable = request:result:symbolTable
        SymbolTable lastGoodCompileTable = undefined
        if lastCompiledResult not= undefined
            lastGoodCompileTable = lastCompiledResult:symbolTable
        end
        //the most recent compile may contain errors. Get the most recent
        //successful compile. Store the error compile as well, as it may
        //help us determine the right values for code completion.
        text file = request:fileKey
        Class clazz = sandboxSymbolTable:GetClassInFile(file)
        SymbolTable finalTable = undefined
        
        //we have tried to get the class from the sandbox. It this is undefined
        //then check the cache. If there is no cached version of the class,
        //then likely this class hasn't compiled in a while and there may
        //be little we can do to detect what the user is doing.
        Class clazzCached = undefined
        if lastGoodCompileTable not= undefined
            clazzCached = lastGoodCompileTable:GetClassInFile(file)
        end
        boolean classNotFound = false
        if clazz = undefined and clazzCached not= undefined
            clazz = clazzCached
            classNotFound = true
            finalTable = lastGoodCompileTable
        elseif clazz not= undefined and clazzCached = undefined
            clazzCached = clazz //better than nothing to check if there is no previous good cache
            finalTable = sandboxSymbolTable
        end

        //if the symbol table is still undefined, then set it to the last good compile table.
        if finalTable = undefined
            finalTable = lastGoodCompileTable
        end

        boolean lastCompileFailed = not compilerResult:compilerErrorManager:IsCompilationErrorFree()
        
        //now we have checked the cache. If this is still undefined, bail
        if clazz not= undefined
            integer start = clazz:GetIndex()
            integer finish = clazz:GetIndexEnd()

            //is it inside of this class? If not, kill the request, because no syntax is legal
            if not(request:caretLocation >= start and request:caretLocation <= finish)
                clazz = undefined
            end

            if split:IsEmpty()
                clazz = undefined
                return now
            end
        else 
            return now
        end

        text left = split:Get(0)
        text trimmedLeft = left:Trim()
        if clazz not= undefined
            text line2 = left
            integer i = line2:GetSize() - 1
            repeat while i >= 0
                text ch = line2:GetCharacter(i)
                if ch = "(" or ch = ","
                   or ch = "*" or ch = "/"
                   or ch = "+" or ch = "-"
                   or ch = " " or IsMod(line2, i) 
                    //make this work for mod --- if it's a d, check backwards and ensure that it's not part of another word

                    //split the line again
                    line2 = line2:GetSubtext(i + 1, line2:GetSize())
                    left = line2
                    line2 = line2:Trim()
                    split = line2:Split(":")
                    if split:IsEmpty()
                        return now
                    end

                    if split:GetSize() > 1 or line2:Contains(":")
                        text ch2 = line2:GetCharacter(line2:GetSize() - 1)
                        if ch2 = ":"
                            result:filter = ""
                        else
                            result:filter = split:Get(split:GetSize() - 1)
                        end
                    end
                    trimmedLeft = line2
                    i = -1
                end
                i = i - 1
            end

            Action method = GetActionAtIndex(clazz, request:caretLocation)
            if left = "me" or left:IsEmpty() or trimmedLeft:IsEmpty()
                AddClassToResult(undefined, request, result, clazz, true, method)
            elseif trimmedLeft = "return"
                AddClassToResult(undefined, request, result, clazz, true, method, 6)
            elseif left = "parent"
                //if this is a parent line, get all of the items on it, split
                //by colons and start chaining through.
                if split not= undefined and split:GetSize() > 1 and split:GetSize() < 4
                    text parentName = split:Get(1)
                    AddParentClassesToResult(parentName, request, result, clazz, true, method)
                else
                    AddParentClassesToResult(undefined, request, result, clazz, true, method)
                end
            else
                if method not= undefined
                    Block block = GetBlockAtIndex(method:GetBlock(), request:caretLocation)
                    if block not= undefined
                        Variable variable = block:GetVariable(trimmedLeft)
                        if variable not= undefined and not lastCompileFailed
                            AddVariableAsClass(variable, request, result, finalTable)
                        //in this case, we've found the variable, but the last compile
                        //failed. Use the cached version. This assumption needs 
                        //to be tested carefully to see how well it works in practice.
                        //It does appear to fix the case where types are being 
                        //inferred, but not recognized properly in the incomplete
                        //failed build.
                        elseif variable not= undefined and lastCompileFailed
                            Action methodCached = GetActionAtIndex(clazzCached, request:caretLocation)
                            if methodCached = undefined
                                AddVariableAsClass(variable, request, result, finalTable)
                                return now
                            end
                            Block blockCached = GetBlockAtIndex(methodCached:GetBlock(), request:caretLocation)
                            if blockCached = undefined
                                AddVariableAsClass(variable, request, result, finalTable)
                                return now
                            end
                            Variable variableCached = blockCached:GetVariable(trimmedLeft)
                            if variableCached = undefined
                                AddVariableAsClass(variable, request, result, finalTable)
                                return now
                            end

                            if variableCached:IsParameter()
                                GetUnresolvedVariableInformation(variableCached, method, request, result, finalTable)
                                return now
                            end
                            AddVariableAsClass(variableCached, request, result, finalTable)
                        //if we can't find the variable and the last compile
                        //failed, check the cache. Maybe it has some information
                        elseif variable = undefined and lastCompileFailed and classNotFound not= true
                            Action methodCached = GetActionAtIndex(clazzCached, request:caretLocation)
                            if methodCached = undefined
                                return now
                            end
                            Block blockCached = GetBlockAtIndex(methodCached:GetBlock(), request:caretLocation)
                            if blockCached = undefined
                                return now
                            end
                            Variable variableCached = blockCached:GetVariable(trimmedLeft)
                            if variableCached = undefined
                                return now
                            end
                            AddVariableAsClass(variableCached, request, result, finalTable)
                        end
                    end
                end
            end
        end
    end

    private action IsMod(text partial, integer i) returns boolean
        if i - 3 < 0
            return false
        end

        if partial:GetCharacter(i) = "d"
            and partial:GetCharacter(i - 1) = "o"
            and partial:GetCharacter(i - 2) = "m"
            and partial:GetCharacter(i - 3) = " "
            return true
        end

        return false
    end

    private action GetLineBeforeCursor(integer loc, text source) returns text
        if loc - 1 <= source:GetSize()
            integer i = loc - 1
            text CR = source:GetLineFeed()

            integer start = 0
            repeat while i >=0 
                text ch = source:GetCharacter(i)
                if ch = CR //this is the end of the line
                    start = i
                    i = -1
                end
                i = i - 1
            end

            text sub = source:GetSubtext(start, loc)
            return sub
        end

        return undefined
    end
    
    private action AddCustomClasses(CodeCompletionRequest request, CodeCompletionResult result, text pack)
        SymbolTable sandboxSymbolTable = request:result:symbolTable
        Iterator<Class> classes = sandboxSymbolTable:GetClassesInPackage(pack)

        if classes not= undefined
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                CodeCompletionItem item = GetClassCompletionItem(clazz)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
            end
        end
    end

    private action GetClassCompletionItem(Class clazz) returns CodeCompletionItem
        CodeCompletionItem item
        item:SetType(item:CLASS)

        text signature = clazz:GetStaticKey()
        text name = clazz:GetName()

        text description = ""
        description = description + "<h1>" + signature + "</h1>"

        item:displayText = name
        item:completionText = name
        item:documentationText = "Test"
        return item
    end

    private action GetPackageCompletionItem(text pack) returns CodeCompletionItem
        CodeCompletionItem item
        item:SetType(item:PACKAGE)

        text signature = pack
        text name = pack

        text description = "<h1>" + signature + "</h1>"

        item:displayText = name
        item:completionText = name
        item:documentationText = ""
        return item
    end

    private action AddSubpackagesAndClasses(CodeCompletionRequest request, CodeCompletionResult result, text name)
        SymbolTable sandboxSymbolTable = request:result:symbolTable
        //first find all of the packages/sub-packages 
        Iterator<text> packs = sandboxSymbolTable:GetSubpackageNames(name)
        repeat while packs:HasNext()
            text pack = packs:Next()
            integer size = name:GetSize() + 1
            text subpackName = pack:GetSubtext(0, size)
            text filteredName = subpackName + result:filter
            subpackName = pack:GetSubtext(size, pack:GetSize())

            if pack:StartsWith(filteredName)
                CodeCompletionItem item = GetPackageCompletionItem(subpackName)
                text filter = result:filter
                integer size2 = filter:GetSize()
                item:dotOffset = request:caretLocation - size2
                result:Add(item)
            end
        end

        //next find any classes on the system in the package
        Iterator<Class> classesInPackage = sandboxSymbolTable:GetClassesInPackage(name)
        boolean hasAny = false
        if classesInPackage not= undefined
            hasAny = classesInPackage:HasNext()
            repeat while classesInPackage:HasNext()
                Class pack = classesInPackage:Next()
                text key = pack:GetStaticKey()
                CodeCompletionItem item = GetClassCompletionItem(pack)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
            end
        end
        
        //finally, remind the user they can use the "all" keyword
        if hasAny
            CodeCompletionItem item
            item:SetType(item:PACKAGE)
            text DQ = ""
            DQ = DQ:GetDoubleQuote()
            text signature = "Use all classes with the " + DQ + "all" + DQ + " keyword."
            text itemName = "all"

            text description = "<h1>" + signature + "</h1>"
                    + "<p align=" + DQ + "justify" + DQ + ">The word "
                    + "all indicates to quorum that we would like to"
                    + " have access to all classes in the package. For "
                    + "example, the phrase Libraries.Containers.all would indicate "
                    + "that we want to use any class in the Libraries.Containers "
                    + "package."
                    + "</p>"
            description = description + "<h2>" + "Code Example:" + "</h2>"
            description = description + "<PRE><CODE>"
                    + "use Libraries.Containers.all\n\n"
                    + "List&lt;integer&gt; list\n"
                    + "Array&lt;integer&gt; array"
                    + "</PRE></CODE>"

            item:displayText = itemName
            item:documentationText = description
            item:completionText = "all"
            text filter = result:filter
            integer size = filter:GetSize()
            item:dotOffset = request:caretLocation - size
            result:Add(item)
        end
    end

    private action GetUnresolvedVariableInformation(Variable variable, Action act, CodeCompletionRequest request, CodeCompletionResult result, SymbolTable table)
        Type type = variable:GetType()
        if type not= undefined
            text key = type:GetStaticKey()
            Class varClass = table:GetClass(key)
            //perhaps it was not resolved in the case. Check use statements
            //for anything that looks reasonable.
            Class variablesClass = variable:GetParentClass()
            if variablesClass not= undefined and variablesClass:GetValidUseName(key) not= undefined
                varClass = variablesClass:GetValidUseName(key)
                AddClassToResult(variable, request, result, varClass, false, undefined)
            elseif variablesClass not= undefined
                Iterator<QualifiedName> iterator = variablesClass:GetUnresolvedUseStatements()
                Array<Class> classes
                repeat while iterator:HasNext()
                    QualifiedName value = iterator:Next()
                    if value:GetName() = key
                        Class value1 = table:GetClass(value:GetStaticKey())
                        if value1 not= undefined
                            classes:Add(value1)
                        end
                    end
                end

                if classes:GetSize() = 1
                    AddClassToResult(variable, request, result, classes:Get(0), false, undefined)
                end
            elseif variablesClass = undefined and act not= undefined
                variablesClass = act:GetParentClass()
                if variablesClass = undefined
                    return now
                end
                Iterator<QualifiedName> iterator = variablesClass:GetUnresolvedUseStatements()
                Array<Class> classes
                repeat while iterator:HasNext()
                    QualifiedName value = iterator:Next()
                    if value:GetName() = key
                        Class value1 = table:GetClass(value:GetStaticKey())
                        if value1 not= undefined
                            classes:Add(value1)
                        end
                    end
                end

                if classes:GetSize() = 1
                    AddClassToResult(variable, request, result, classes:Get(0), false, undefined)
                end
            end
        end
    end

    private action AddVariableAsClass(Variable variable, CodeCompletionRequest request, CodeCompletionResult result, SymbolTable table)
        Type type = variable:GetType()
        if type not= undefined
            text key = type:GetStaticKey()
            if table = undefined
                return now
            end
            Class varClass = table:GetClass(key)

            if varClass not= undefined
                AddClassToResult(variable, request, result, varClass, false, undefined)
            elseif not type:IsPrimitive() and varClass = undefined
                GetUnresolvedVariableInformation(variable, undefined, request, result, table)
            elseif type:IsPrimitive() and varClass = undefined
                Class clazz = undefined
                if type:IsInteger()
                    clazz = table:GetClass(type:INTEGER_OBJECT_KEY)
                elseif type:IsNumber()
                    clazz = table:GetClass(type:NUMBER_OBJECT_KEY)
                elseif type:IsBoolean()
                    clazz = table:GetClass(type:BOOLEAN_OBJECT_KEY)
                else type:IsText()
                    clazz = table:GetClass(type:TEXT_OBJECT_KEY)
                end

                //if this is the current class, load all methods, public or private
                //if this is a variable, load only its public methods.
                Iterator<Action> actions = clazz:GetVirtualTable()
                repeat while actions:HasNext()
                    Action act = actions:Next()
                    CodeCompletionItem item = act:GetCodeCompletionItem(variable)
                    text filter = result:filter
                    integer size = filter:GetSize()
                    item:dotOffset = request:caretLocation - size

                    //is this action in the base class or the v-table?
                    if clazz:HasAction(act:GetStaticKey())
                        item:isBaseClassAction = true
                    end

                    //unlike other locations, this cannot possibly be
                    //the "current" class.
                    if  not act:IsPrivate() and act:GetName() not= "GetValue" and act:GetName() not= "SetValue"
                        result:Add(item)
                    end
                end
            end
        end
    end

    private action GetVariableInBlock() returns Variable
        Variable variable = undefined
        

        return variable
    end

    /*
        Obtains the logical block located at this index. 
    */
    private action GetBlockAtIndex(Block block, integer index) returns Block
        Block bestBlock = undefined

        if block not= undefined
            boolean test = IsIndexInLocation(block, index)
            if test
                bestBlock = block
            end
            //get subblocks and try those
            //this call recursively calls to subblocks, thus no need
            //for going deeper in this loop exists
            Iterator<Block> blocks = block:GetBlocks()
            repeat while blocks:HasNext()
                Block b = blocks:Next()
                Block returnedBlock = GetBlockAtIndex(b, index)
                if returnedBlock not= undefined
                    if IsIndexInLocation(returnedBlock, index)
                        integer start = returnedBlock:GetIndex()
                        integer finish = returnedBlock:GetIndexEnd()
                        integer range = finish - start

                        if bestBlock = undefined
                            bestBlock = returnedBlock
                        else
                            integer bestStart = bestBlock:GetIndex()
                            integer bestFinish = bestBlock:GetIndexEnd()
                            integer bestRange = bestFinish - bestStart
                            //this block is nested 
                            if range < bestRange
                                bestBlock = returnedBlock
                            end
                        end
                    end
                end
            end
        end

        return bestBlock
    end

    private action IsIndexInLocation(Location location, integer index) returns boolean
        integer start = location:GetIndex()
        integer finish = location:GetIndexEnd()
        if index >= start and index <= finish
            return true
        end

        return false
    end

    private action GetActionAtIndex(Class clazz, integer index) returns Action
        Action act = undefined
        File file = clazz:GetFile()
        text classPath = file:GetAbsolutePath()

        Iterator<Action> actions = clazz:GetActions()
        repeat while actions:HasNext()
            Action a = actions:Next()
            integer start = a:GetIndex()
            integer finish = a:GetIndexEnd()
            File f = a:GetFile()
            text actionPath = f:GetAbsolutePath()
            if index >= start and index <= finish and classPath = actionPath
                act = a
                return act
            end
        end
        //check the constructor
        if act = undefined
            Action constructor = clazz:GetConstructor()
            if constructor not= undefined
                integer start = constructor:GetIndex()
                integer finish = constructor:GetIndexEnd()
                File f = constructor:GetFile()
                text actionPath = f:GetAbsolutePath()
                if index >= start and index <= finish and classPath = actionPath
                    act = constructor
                    return act
                end
            end
        end
        return act
    end

    private action AddParentClassesToResult(text parentName, 
        CodeCompletionRequest request, 
        CodeCompletionResult result, Class clazz, 
        boolean isCurrentClass, Action insideMethod)

        if clazz not= undefined

            if parentName = undefined
                Iterator<Class> value = clazz:GetParentClasses()
                repeat while value:HasNext()
                    Class theParent = value:Next()

                    CodeCompletionItem item

                    name = theParent:GetName()
                    key = theParent:GetStaticKey()
                    item:displayText = name
                    item:completionText = key

                    text filter = result:filter
                    integer size = filter:GetSize()
                    item:dotOffset = request:caretLocation - size
                    result:Add(item)
                end
            else //in this case, we have the parent name and are 
                 //looking for its operations
                 
                 //first check if they put in the full static key
                Class value = clazz:GetParentClass(parentName)

                if value not= undefined
                    AddParentClassToResult(undefined, request, result, value, insideMethod)
                else
                    value = clazz:GetValidUseName(parentName)
                    if value not= undefined
                        Class validParent = clazz:GetParentClass(value:GetStaticKey())
                        if validParent not= undefined
                            AddParentClassToResult(undefined, request, result, value, insideMethod)
                        end
                    end
                end

            end
        end
        
    end

    private action AddParentClassToResult(Variable variable, 
        CodeCompletionRequest request, 
        CodeCompletionResult result, Class clazz, Action insideMethod)

        if clazz not= undefined
            //add all of the fields from this class
            Iterator<Variable> variables = clazz:GetVariables()
            repeat while variables:HasNext()
                Variable variable2 = variables:Next()
                if variable2:GetType() not= undefined
                    CodeCompletionItem item = variable2:GetCodeCompletionItem(clazz)
                    text filter = result:filter
                    integer size = filter:GetSize()
                    item:dotOffset = request:caretLocation - size
                    result:Add(item)
                end
            end

            //there is no need to load parent information here, because this 
            //is the parent. Given then, load only the base methods.
            //if this is the current class, load all methods, public or private
            //if this is a variable, load only its public methods.
            Iterator<Action> actions = clazz:GetVirtualTable()
            repeat while actions:HasNext()
                Action act = actions:Next()
                CodeCompletionItem item = act:GetCodeCompletionItem(variable)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size

                //In this case, mark the methods in the base class, 
                //but still show anything in this parent's v-table.
                if clazz:HasAction(act:GetStaticKey())
                    item:isBaseClassAction = true
                end

                result:Add(item)
            end
        end
    end

    private action AddClassToResult(Variable variable, 
        CodeCompletionRequest request, 
        CodeCompletionResult result, Class clazz, 
        boolean isCurrentClass, Action insideMethod)
        AddClassToResult(variable, request, result, clazz, isCurrentClass, insideMethod, 0)
    end  

    private action AddClassToResult(Variable variable, 
        CodeCompletionRequest request, 
        CodeCompletionResult result, Class clazz, 
        boolean isCurrentClass, Action insideMethod, integer additionalDotOffset)

        if clazz not= undefined
            //add all of the fields from this class
            Iterator<Variable> variables = clazz:GetVariables()
            repeat while variables:HasNext()
                Variable variable2 = variables:Next()
                if variable2:GetType() not= undefined
                    CodeCompletionItem item = variable2:GetCodeCompletionItem(clazz)
                    text filter = result:filter
                    integer size = filter:GetSize()
                    item:dotOffset = request:caretLocation - size + additionalDotOffset
                    if isCurrentClass
                        result:Add(item)
                    else
                        if not variable2:IsPrivate()
                            result:Add(item)
                        end
                    end
                end
            end

            //now add all of the parent fields from this class
            Iterator<Class> parents = clazz:GetParentClasses()
            repeat while parents:HasNext()
                Class par = parents:Next()
                Iterator<Variable> variables2 = par:GetVariables()
                repeat while variables2:HasNext()
                    Variable variable2 = variables2:Next()
                    if variable2:GetType() not= undefined
                        CodeCompletionItem item = variable2:GetCodeCompletionItem(clazz)
                        text filter = result:filter
                        integer size = filter:GetSize()
                        item:dotOffset = request:caretLocation - size + additionalDotOffset
                        if isCurrentClass
                            result:Add(item)
                        else
                            if not variable2:IsPrivate()
                                result:Add(item)
                            end
                        end
                    end
                end
            end

            //if this is the current class, load all methods, public or private
            //if this is a variable, load only its public methods.
            Iterator<Action> actions = clazz:GetVirtualTable()
            repeat while actions:HasNext()
                Action act = actions:Next()
                CodeCompletionItem item = act:GetCodeCompletionItem(variable)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size + additionalDotOffset

                //is this action in the base class or the v-table?
                if clazz:HasAction(act:GetStaticKey())
                    item:isBaseClassAction = true
                end

                if isCurrentClass
                    result:Add(item)
                else
                    if not act:IsPrivate()
                        result:Add(item)
                    end
                end
            end
        end
    end
end