//package Libraries.Compute

use Libraries.Compute.all
//use Libraries.Compute.Vector2
use Libraries.Containers.Array

class Vector3 

    number x = 0
    number y = 0
    number z = 0

    public constant Vector3 X
    public constant Vector3 Y
    public constant Vector3 Z
    public constant Vector3 ZERO

    Matrix4 tempMat

    Math math
    public constant number ROUNDING_MARGIN = 0.000001

    on create
        X:Set(1, 0, 0)
        Y:Set(0, 1, 0)
        Z:Set(0, 0, 1)
        ZERO:Set(0, 0, 0)
    end

    action GetX () returns number
        return x
    end

    action GetY () returns number
        return y
    end

    action GetZ () returns number
        return z
    end

    action Set (number xValue, number yValue, number zValue) returns Vector3
        x = xValue
        y = yValue
        z = zValue
        return me
    end

    action Set (Vector3 vector) returns Vector3
        return Set(vector:GetX(), vector:GetY(), vector:GetZ())
    end

    action set (Array<number> array) returns Vector3
        return Set(array:Get(0), array:Get(1), array:Get(2))
    end

    action Set (Vector2 vector, number z) returns Vector3
        return Set(vector:GetX(), vector:GetY(), z)
    end

    action SetX(number newX)
        x = newX
    end

    action SetY(number newY)
        y = newY
    end

    action SetZ(number newZ)
        z = newZ
    end

    action Copy () returns Vector3
        Vector3 temp
        temp:Set(x, y, z)
        return temp
    end

    action Add (Vector3 vector) returns Vector3
        return Add(vector:GetX(), vector:GetY(), vector:GetZ())
    end

    action Add (number xValue, number yValue, number zValue) returns Vector3
        return Set(x + xValue, y + yValue, z + zValue)
    end

    action Add (number value) returns Vector3
        return Set(x + value, y + value, z + value)
    end

    action Subtract (Vector3 vector) returns Vector3
        return Subtract(vector:GetX(), vector:GetY(), vector:GetZ())
    end

    action Subtract (number xValue, number yValue, number zValue) returns Vector3
        return Set(x - xValue, y - yValue, z - zValue)        
    end

    action Subtract (number value) returns Vector3
        return Set(x - value, y - value, z - value)
    end

    action Scale (number scalar) returns Vector3
        return Set(x * scalar, y * scalar, z * scalar)
    end

    action Scale (Vector3 vector) returns Vector3
        return Set(x * vector:GetX(), y * vector:GetY(), z * vector:GetZ())
    end

    action Scale (number vx, number vy, number vz) returns Vector3
        return Set(x * vx, y * vy, z * vz)
    end

    action MultiplyAndAdd (Vector3 vec, number scalar) returns Vector3
        x = x + vec:GetX() * scalar
        y = y + vec:GetY() * scalar
        z = z + vec:GetZ() * scalar
        return me
    end

    action MultiplyAndAdd (Vector3 vec, Vector3 mulVec) returns Vector3
        x = x + vec:GetX() * mulVec:GetX()
        y = y + vec:GetY() * mulVec:GetY()
        z = z + vec:GetZ() * mulVec:GetZ()
        return me
    end

    action Length () returns number
        return math:SquareRoot(x * x + y * y + z * z)
    end

    action Length (number x, number y, number z) returns number
        return math:SquareRoot(x * x + y * y + z * z)
    end

    action LengthSquared (number x, number y, number z) returns number
        return x * x + y * y + z * z
    end

    action LengthSquared () returns number
        return x * x + y * y + z * z
    end

    action Equals (Vector3 vector) returns boolean
        return x = vector:GetX() and y = vector:GetY() and z = vector:GetZ()
    end

    action Distance (number x1, number y1, number z1, number x2, number y2, number z2) returns number
        number a = x2 - x1
        number b = y2 - y1
        number c = z2 - z1
        return math:SquareRoot(a * a + b * b + c * c)
    end
    
    action Distance (Vector3 vector) returns number
        number a = vector:GetX() - x
        number b = vector:GetY() - y
        number c = vector:GetZ() - z
        return math:SquareRoot(a * a + b * b + c * c)
    end

    action Distance (number xValue, number yValue, number zValue) returns number
        number a = xValue - x
        number b = yValue - y
        number c = zValue - z
        return math:SquareRoot(a * a + b * b + c * c)
    end

    action DistanceSquared (number x1, number y1, number z1, number x2, number y2, number z2)returns number
        number a = x2 - x1
        number b = y2 - y1
        number c = z2 - z1
        return a * a + b * b + c * c
    end

    action DistanceSquared (Vector3 vector) returns number
        number a = vector:GetX() - x
        number b = vector:GetY() - y
        number c = vector:GetZ() - z
        return a * a + b * b + c * c
    end

    action DistanceSquared (number xValue, number yValue, number zValue) returns number
        number a = xValue - x
        number b = yValue - y
        number c = zValue - z
        return a * a + b * b + c * c
    end

   action Normalize() returns Vector3
        number len2 = me:LengthSquared()
        if len2 = 0.0 or len2 = 1.0
            return me
        end

        return me:Scale(1.0 / math:SquareRoot(len2))
    end         

    action DotProduct (Vector3 vector) returns number
        return x * vector:GetX() + y * vector:GetY() + z * vector:GetZ()
    end

    action DotProduct (number xValue, number yValue, number zValue) returns number
        return x * xValue + y * yValue + z * zValue
    end

    action DotProduct (number x1, number y1, number z1, number x2, number y2, number z2) returns number
        return x1 * x2 + y1 * y2 + z1 * z2
    end

    /* Sets Vector3's variables to the cross product of the current variables of Vector3 and the parameters */
    action CrossProduct (Vector3 vector) returns Vector3
        return Set(y * vector:GetZ() - z * vector:GetY(), z * vector:GetX() - x * vector:GetZ(), x * vector:GetY() - y * vector:GetX())
    end

    action CrossProduct (number xVal, number yVal, number zVal) returns Vector3
        return Set(y * zVal - z * yVal, z * xVal - x * zVal, x * yVal - y * xVal)
    end

    action MultiplyBy4x3Matrix (Array<number> matrix) returns Vector3
        return Set(x * matrix:Get(0) + y * matrix:Get(3) + z * matrix:Get(6) + matrix:Get(9),
                   x * matrix:Get(1) + y * matrix:Get(4) + z * matrix:Get(7) + matrix:Get(10),
                   x * matrix:Get(2) + y * matrix:Get(5) + z * matrix:Get(8) + matrix:Get(11))
    end

    action Multiply(Matrix4 matrix) returns Vector3
        
        Array<number> l_mat = matrix:values

        return Set(x * l_mat:Get(matrix:M00) + y * l_mat:Get(matrix:M01) + z * l_mat:Get(matrix:M02) + l_mat:Get(matrix:M03),
                   x * l_mat:Get(matrix:M10) + y * l_mat:Get(matrix:M11) + z * l_mat:Get(matrix:M12) + l_mat:Get(matrix:M13),
                   x * l_mat:Get(matrix:M20) + y * l_mat:Get(matrix:M21) + z * l_mat:Get(matrix:M22) + l_mat:Get(matrix:M23))        
    end
        
    action MultiplyByTranspose (Matrix4 matrix) returns Vector3
        Array<number> l_mat = matrix:values

        return Set(x * l_mat:Get(matrix:M00) + y * l_mat:Get(matrix:M10) + z * l_mat:Get(matrix:M20) + l_mat:Get(matrix:M30),
                   x * l_mat:Get(matrix:M01) + y * l_mat:Get(matrix:M11) + z * l_mat:Get(matrix:M21) + l_mat:Get(matrix:M31),
                   x * l_mat:Get(matrix:M02) + y * l_mat:Get(matrix:M12) + z * l_mat:Get(matrix:M22) + l_mat:Get(matrix:M32))
    end
 
    action Multiply (Matrix3 matrix) returns Vector3
           constant Array<number> leftMatrix = matrix:values

           return Set(x * leftMatrix:Get(matrix:M00) + y * leftMatrix:Get(matrix:M01) + z * leftMatrix:Get(matrix:M02),
                      x * leftMatrix:Get(matrix:M10) + y * leftMatrix:Get(matrix:M11) + z * leftMatrix:Get(matrix:M12),
                      x * leftMatrix:Get(matrix:M20) + y * leftMatrix:Get(matrix:M21) + z * leftMatrix:Get(matrix:M22))

    end

    action MultiplyByTranspose (Matrix3 matrix) returns Vector3
        constant Array<number> leftMatrix = matrix:values
        
        return Set(x * leftMatrix:Get(matrix:M00) + y * leftMatrix:Get(matrix:M10) + z * leftMatrix:Get(matrix:M20),
                   x * leftMatrix:Get(matrix:M01) + y * leftMatrix:Get(matrix:M11) + z * leftMatrix:Get(matrix:M21),
                   x * leftMatrix:Get(matrix:M02) + y * leftMatrix:Get(matrix:M12) + z * leftMatrix:Get(matrix:M22))

    end

    action Multiply(Quaternion quaternion) returns Vector3
        return quaternion:Transform(me)
    end

    // multiple methods need Matrix4 here

    action IsUnit() returns boolean
        return IsUnit(0.000000001)
    end

    action IsUnit (number margin) returns boolean
        return math:AbsoluteValue(LengthSquared() - 1.0) < margin
    end

    action IsZero() returns boolean
        return x = 0 and y = 0 and z = 0
    end

    action IsZero (number margin) returns boolean
        return LengthSquared() < margin
    end

    action IsOnLine (Vector3 other, number epsilon) returns boolean
        return LengthSquared(y * other:GetZ() - z * other:GetY(), z * other:GetX() - x * other:GetZ(),
               x * other:GetY() - y * other:GetX()) <= epsilon
    end

    action IsOnLine (Vector3 other) returns boolean
        return LengthSquared(y * other:GetZ() - z * other:GetY(), z * other:GetX() - x * other:GetZ(), x * other:GetY() - y * other:GetX()) <= ROUNDING_MARGIN
    end
        
    action IsCollinearOpposite (Vector3 other, number epsilon) returns boolean
        if IsOnLine(other, epsilon)
            if HasOppositeDirection(other)
                return true
            end
        end
        return false
    end

    action IsCollinearOpposite (Vector3 other) returns boolean
        if IsOnLine(other)
            if HasOppositeDirection(other)
                return true
            end
        end
        return false
    end

    action IsCollinear (Vector3 other, number epsilon) returns boolean
        if IsOnLine(other, epsilon)
            if HasSameDirection(other)
                return true
            end
        end
        return false
    end

    action IsCollinear (Vector3 other) returns boolean
        if IsOnLine(other)
            if HasSameDirection(other)
                return true
            end
        end
        return false
    end

    action IsPerpendicular (Vector3 vector) returns boolean
        return math:AbsoluteValue(DotProduct(vector)) <= ROUNDING_MARGIN
    end

    action IsPerpendicular (Vector3 vector, number epsilon) returns boolean
        return math:AbsoluteValue(DotProduct(vector)) <= epsilon
    end

    action HasSameDirection (Vector3 vector) returns boolean
        return DotProduct(vector) > 0
    end

    action HasOppositeDirection (Vector3 vector) returns boolean
        return DotProduct(vector) < 0
    end

    action LinearInterpolation (Vector3 target, number alpha) returns Vector3
        Vector3 temp
        Scale(1.0 - alpha)
        Add(target:x * alpha, target:y * alpha, target:z * alpha)
        temp:Set(x, y, z)
        return temp
    end

    /* action interpolate (Vector3 target, number alpha, Interpolation interpolator) returns Vector3
            return lerp(target, interpolator:apply(0.0, 1.0, alpha)
       end */

    /* action SphericalLinearInterpolation (Vector3 target, number alpha)
        constant number dotProduct = DotProduct(target)

        if dotProduct > 0.9995
            LinearInterpolation(target, alpha)

        elseif dotProduct < -0.9995
            LinearInterpolation(target, alpha)

        end

            constant number theta0 = cast(number, math:acos(dotProduct))
            constant number theta = theta0 * alpha
            constant number st = cast(number, math:Sine(theta))
            constant number tx = target:x - x * dotProduct
            constant number ty = target:y - y * dotProduct
            constant number tz = target:z - z * dotProduct
            constant number l2 = tx * tx + ty * ty + tz * tz
            constant number dl = st 
       end */

       action ToText() returns text
            return "[" + x + "," + y + "," + z + "]"
       end

       action Limit (number limit) returns Vector3
            Vector3 temp
            temp = Copy()
            if LengthSquared() > (limit * limit)
                temp = Normalize()
                temp:Scale(limit)
            end
            return temp
       end
       
       action LimitPositionToArea (number min, number max)
            constant number lengthSquared = LengthSquared()
            if lengthSquared not= 0.0
                number maxSquared = max * max
                if lengthSquared > (maxSquared)
                    number temp = math:SquareRoot(maxSquared/lengthSquared)
                    Scale(temp)
                end
                number minSquared = min * min
                if lengthSquared < (minSquared)
                    number temp = math:SquareRoot(minSquared/lengthSquared)
                    Scale(temp)
                end
            end
        end

        /* action hashCode () returns integer
            constant integer prime = 31
            integer result = 1
            result = prime * result + numberUtils:floatToIntBits(x)
            result = prime * result + numberUtils:floatToIntBits(y)
            result = prime * result + numberUtils:floatToIntBits(z)
            return result
        end */

        /* action equals (Object obj) returns boolean
            Vector3 temp = cpy()
            if temp = obj
                return true
            end
            if obj = null
                return false
            end */
        
            action EqualAtPrecision (Vector3 other, number epsilon) returns boolean
                if other = undefined
                    return false
                end
                if math:AbsoluteValue(other:x - x) > epsilon
                    return false
                end
                if math:AbsoluteValue(other:y - y) > epsilon
                    return false
                end
                if math:AbsoluteValue(other:z - z) > epsilon
                    return false
                end
                return true
            end
            
            action EqualAtPrecision(number xVal, number yVal, number zVal, number epsilon) returns boolean  
                if math:AbsoluteValue(xVal - x) > epsilon
                    return false
                end
                if math:AbsoluteValue(yVal - y) > epsilon
                    return false
                end
                if math:AbsoluteValue(zVal - z) > epsilon
                    return false
                end
                return true
            end

end