package Libraries.Compute

use Libraries.Compute.all
use Libraries.Compute.Vector2
use Libraries.Containers.Array

class Vector3 

    number x = 0
    number y = 0
    number z = 0

    Math math
    public constant number ROUNDING_MARGIN = 0.000001

    action GetX () returns number
        return x
    end

    action GetY () returns number
        return y
    end

    action GetZ () returns number
        return z
    end

    action Set (number xValue, number yValue, number zValue) returns Vector3
        x = xValue
        y = yValue
        z = zValue
        return me
    end

    action Set (Vector3 vector) returns Vector3
        return Set(vector:GetX(), vector:GetY(), vector:GetZ())
    end

    action Set (Array<number> array) returns Vector3
        return Set(array:Get(0), array:Get(1), array:Get(2))
    end

    action Set (Vector2 vector, number z) returns Vector3
        return Set(vector:GetX(), vector:GetY(), z)
    end

    action SetX(number newX)
        x = newX
    end

    action SetY(number newY)
        y = newY
    end

    action SetZ(number newZ)
        z = newZ
    end

    action Copy () returns Vector3
        Vector3 temp
        temp:Set(x, y, z)
        return temp
    end

    action Add (Vector3 vector) returns Vector3
        return Add(vector:GetX(), vector:GetY(), vector:GetZ())
    end

    action Add (number xValue, number yValue, number zValue) returns Vector3
        return Set(x + xValue, y + yValue, z + zValue)
    end

    action Add (number value) returns Vector3
        return Set(x + value, y + value, z + value)
    end

    action Subtract (Vector3 vector) returns Vector3
        return Subtract(vector:GetX(), vector:GetY(), vector:GetZ())
    end

    action Subtract (number xValue, number yValue, number zValue) returns Vector3
        return Set(x - xValue, y - yValue, z - zValue)        
    end

    action Subtract (number value) returns Vector3
        return Set(x - value, y - value, z - value)
    end

    action Scale (number scalar) returns Vector3
        return Set(x * scalar, y * scalar, z * scalar)
    end

    action Scale (Vector3 vector) returns Vector3
        return Set(x * vector:GetX(), y * vector:GetY(), z * vector:GetZ())
    end

    action Scale (number vx, number vy, number vz) returns Vector3
        return Set(x * vx, y * vy, z * vz)
    end

    action MultiplyAndAdd (Vector3 vec, number scalar) returns Vector3
        x = x + vec:GetX() * scalar
        y = y + vec:GetY() * scalar
        z = z + vec:GetZ() * scalar
        return me
    end

    action MultiplyAndAdd (Vector3 vec, Vector3 mulVec) returns Vector3
        x = x + vec:GetX() * mulVec:GetX()
        y = y + vec:GetY() * mulVec:GetY()
        z = z + vec:GetZ() * mulVec:GetZ()
        return me
    end

    action Length () returns number
        return math:SquareRoot(x * x + y * y + z * z)
    end

    action Length (number x, number y, number z) returns number
        return math:SquareRoot(x * x + y * y + z * z)
    end

    action LengthSquared (number x, number y, number z) returns number
        return x * x + y * y + z * z
    end

    action LengthSquared () returns number
        return x * x + y * y + z * z
    end

    action Equals (Vector3 vector) returns boolean
        return x = vector:GetX() and y = vector:GetY() and z = vector:GetZ()
    end

    action Distance (number x1, number y1, number z1, number x2, number y2, number z2) returns number
        number a = x2 - x1
        number b = y2 - y1
        number c = z2 - z1
        return math:SquareRoot(a * a + b * b + c * c)
    end
    
    action Distance (Vector3 vector) returns number
        number a = vector:GetX() - x
        number b = vector:GetY() - y
        number c = vector:GetZ() - z
        return math:SquareRoot(a * a + b * b + c * c)
    end

    action Distance (number xValue, number yValue, number zValue) returns number
        number a = xValue - x
        number b = yValue - y
        number c = zValue - z
        return math:SquareRoot(a * a + b * b + c * c)
    end

    action DistanceSquared (number x1, number y1, number z1, number x2, number y2, number z2)returns number
        number a = x2 - x1
        number b = y2 - y1
        number c = z2 - z1
        return a * a + b * b + c * c
    end

    action DistanceSquared (Vector3 vector) returns number
        number a = vector:GetX() - x
        number b = vector:GetY() - y
        number c = vector:GetZ() - z
        return a * a + b * b + c * c
    end

    action DistanceSquared (number xValue, number yValue, number zValue) returns number
        number a = xValue - x
        number b = yValue - y
        number c = zValue - z
        return a * a + b * b + c * c
    end

   action Normalize() returns Vector3
        number len2 = me:LengthSquared()
        if len2 = 0.0 or len2 = 1.0
            return me
        end

        return me:Scale(1.0 / math:SquareRoot(len2))
    end         

    action DotProduct (Vector3 vector) returns number
        return x * vector:GetX() + y * vector:GetY() + z * vector:GetZ()
    end

    action DotProduct (number xValue, number yValue, number zValue) returns number
        return x * xValue + y * yValue + z * zValue
    end

    action DotProduct (number x1, number y1, number z1, number x2, number y2, number z2) returns number
        return x1 * x2 + y1 * y2 + z1 * z2
    end

    /* Sets Vector3's variables to the cross product of the current variables of Vector3 and the parameters */
    action CrossProduct (Vector3 vector) returns Vector3
        return Set(y * vector:GetZ() - z * vector:GetY(), z * vector:GetX() - x * vector:GetZ(), x * vector:GetY() - y * vector:GetX())
    end

    action CrossProduct (number xVal, number yVal, number zVal) returns Vector3
        return Set(y * zVal - z * yVal, z * xVal - x * zVal, x * yVal - y * xVal)
    end

    action MultiplyBy4x3Matrix (Array<number> matrix) returns Vector3
        return Set(x * matrix:Get(0) + y * matrix:Get(3) + z * matrix:Get(6) + matrix:Get(9),
                   x * matrix:Get(1) + y * matrix:Get(4) + z * matrix:Get(7) + matrix:Get(10),
                   x * matrix:Get(2) + y * matrix:Get(5) + z * matrix:Get(8) + matrix:Get(11))
    end

    action Multiply(Matrix4 matrix) returns Vector3
        
        Array<number> l_mat = matrix:values

        return Set(x * l_mat:Get(matrix:M00) + y * l_mat:Get(matrix:M01) + z * l_mat:Get(matrix:M02) + l_mat:Get(matrix:M03),
                   x * l_mat:Get(matrix:M10) + y * l_mat:Get(matrix:M11) + z * l_mat:Get(matrix:M12) + l_mat:Get(matrix:M13),
                   x * l_mat:Get(matrix:M20) + y * l_mat:Get(matrix:M21) + z * l_mat:Get(matrix:M22) + l_mat:Get(matrix:M23))        
    end
        
    action MultiplyByTranspose (Matrix4 matrix) returns Vector3
        Array<number> l_mat = matrix:values

        return Set(x * l_mat:Get(matrix:M00) + y * l_mat:Get(matrix:M10) + z * l_mat:Get(matrix:M20) + l_mat:Get(matrix:M30),
                   x * l_mat:Get(matrix:M01) + y * l_mat:Get(matrix:M11) + z * l_mat:Get(matrix:M21) + l_mat:Get(matrix:M31),
                   x * l_mat:Get(matrix:M02) + y * l_mat:Get(matrix:M12) + z * l_mat:Get(matrix:M22) + l_mat:Get(matrix:M32))
    end
 
    action Multiply (Matrix3 matrix) returns Vector3
           constant Array<number> leftMatrix = matrix:values

           return Set(x * leftMatrix:Get(matrix:M00) + y * leftMatrix:Get(matrix:M01) + z * leftMatrix:Get(matrix:M02),
                      x * leftMatrix:Get(matrix:M10) + y * leftMatrix:Get(matrix:M11) + z * leftMatrix:Get(matrix:M12),
                      x * leftMatrix:Get(matrix:M20) + y * leftMatrix:Get(matrix:M21) + z * leftMatrix:Get(matrix:M22))

    end

    action MultiplyByTranspose (Matrix3 matrix) returns Vector3
        constant Array<number> leftMatrix = matrix:values
        
        return Set(x * leftMatrix:Get(matrix:M00) + y * leftMatrix:Get(matrix:M10) + z * leftMatrix:Get(matrix:M20),
                   x * leftMatrix:Get(matrix:M01) + y * leftMatrix:Get(matrix:M11) + z * leftMatrix:Get(matrix:M21),
                   x * leftMatrix:Get(matrix:M02) + y * leftMatrix:Get(matrix:M12) + z * leftMatrix:Get(matrix:M22))

    end

    action Multiply(Quaternion quaternion) returns Vector3
        return quaternion:Transform(me)
    end

    action Project(Matrix4 matrix) returns Vector3
        Array<number> l_mat = matrix:values
        number l_w = 1.0 / (x * l_mat:Get(matrix:M30) + y * l_mat:Get(matrix:M31) + z * l_mat:Get(matrix:M32) + l_mat:Get(matrix:M33))
        return me:Set((x * l_mat:Get(matrix:M00) + y * l_mat:Get(matrix:M01) + z * l_mat:Get(matrix:M02) + l_mat:Get(matrix:M03)) * l_w,
                      (x * l_mat:Get(matrix:M10) + y * l_mat:Get(matrix:M11) + z * l_mat:Get(matrix:M12) + l_mat:Get(matrix:M13)) * l_w,
                      (x * l_mat:Get(matrix:M20) + y * l_mat:Get(matrix:M21) + z * l_mat:Get(matrix:M22) + l_mat:Get(matrix:M23)) * l_w)
    end
    
    action Rotate(Matrix4 matrix) returns Vector3
        Array<number> l_mat = matrix:values
        return me:Set(x * l_mat:Get(matrix:M00) + y * l_mat:Get(matrix:M01) + z * l_mat:Get(matrix:M02),
                      x * l_mat:Get(matrix:M10) + y * l_mat:Get(matrix:M11) + z * l_mat:Get(matrix:M12),
                      x * l_mat:Get(matrix:M20) + y * l_mat:Get(matrix:M21) + z * l_mat:Get(matrix:M22))
    end

    action Unrotate(Matrix4 matrix) returns Vector3
        Array<number> l_mat = matrix:values
        return me:Set(x * l_mat:Get(matrix:M00) + y * l_mat:Get(matrix:M10) + z * l_mat:Get(matrix:M20),
                      x * l_mat:Get(matrix:M01) + y * l_mat:Get(matrix:M11) + z * l_mat:Get(matrix:M21),
                      x * l_mat:Get(matrix:M02) + y * l_mat:Get(matrix:M12) + z * l_mat:Get(matrix:M22))
    end

    action Untransform(Matrix4 matrix) returns Vector3
        Array<number> l_mat = matrix:values
        x = x - l_mat:Get(matrix:M03)
        y = y - l_mat:Get(matrix:M03)
        z = z - l_mat:Get(matrix:M03)
        return me:Set(x * l_mat:Get(matrix:M00) + y * l_mat:Get(matrix:M10) + z * l_mat:Get(matrix:M20),
                      x * l_mat:Get(matrix:M01) + y * l_mat:Get(matrix:M11) + z * l_mat:Get(matrix:M21),
                      x * l_mat:Get(matrix:M02) + y * l_mat:Get(matrix:M12) + z * l_mat:Get(matrix:M22))
    end

//    action Rotate(number degrees, number axisX, number axisY, number axisZ) returns Vector3
//        return me:Multiply(tempMat:SetToRotation(axisX, axisY, axisZ, degrees))
//    end
//
//    action RotateRadians(number radians, number axisX, number axisY, number axisZ) returns Vector3
//        return me:Multiply(tempMat:SetToRotationRadians(axisX, axisY, axisZ, radians))
//    end
//
//    action Rotate(Vector3 axis, number degrees) returns Vector3
//        tempMat:SetToRotation(axis, degrees)
//        return me:Multiply(tempMat)
//    end
//
//    action RotateRadians(Vector3 axis, number radians) returns Vector3
//        tempMat:SetToRotationRadians(axis, radians)
//        return me:Multiply(tempMat)
//    end

    action IsUnit() returns boolean
        return IsUnit(0.000000001)
    end

    action IsUnit (number margin) returns boolean
        return math:AbsoluteValue(LengthSquared() - 1.0) < margin
    end

    action IsZero() returns boolean
        return x = 0 and y = 0 and z = 0
    end

    action IsZero (number margin) returns boolean
        return LengthSquared() < margin
    end

    action IsOnLine (Vector3 other, number epsilon) returns boolean
        return LengthSquared(y * other:GetZ() - z * other:GetY(), z * other:GetX() - x * other:GetZ(),
                             x * other:GetY() - y * other:GetX()) <= epsilon
    end

    action IsOnLine (Vector3 other) returns boolean
        return LengthSquared(y * other:GetZ() - z * other:GetY(), z * other:GetX() - x * other:GetZ(), 
                             x * other:GetY() - y * other:GetX()) <= ROUNDING_MARGIN
    end
        
    action IsCollinearOpposite (Vector3 other, number epsilon) returns boolean
        return IsOnLine(other, epsilon) and HasOppositeDirection(other)
    end

    action IsCollinearOpposite (Vector3 other) returns boolean
        return IsOnLine(other) and HasOppositeDirection(other)
    end

    action IsCollinear (Vector3 other, number epsilon) returns boolean
        return IsOnLine(other, epsilon) and HasSameDirection(other)
    end

    action IsCollinear (Vector3 other) returns boolean
        return IsOnLine(other) and HasSameDirection(other)
    end

    action IsPerpendicular (Vector3 vector) returns boolean
        return math:AbsoluteValue(DotProduct(vector)) <= ROUNDING_MARGIN
    end

    action IsPerpendicular (Vector3 vector, number epsilon) returns boolean
        return math:AbsoluteValue(DotProduct(vector)) <= epsilon
    end

    action HasSameDirection (Vector3 vector) returns boolean
        return DotProduct(vector) > 0
    end

    action HasOppositeDirection (Vector3 vector) returns boolean
        return DotProduct(vector) < 0
    end

    action LinearInterpolation (Vector3 target, number alpha) returns Vector3
        x = x + alpha * (target:GetX() - x)
        y = y + alpha * (target:GetY() - y)
        z = z + alpha * (target:GetZ() - z)
        return me
    end

    /* action interpolate (Vector3 target, number alpha, Interpolation interpolator) returns Vector3
            return lerp(target, interpolator:apply(0.0, 1.0, alpha)
       end */

    action SphericalLinearInterpolation (Vector3 target, number alpha) returns Vector3
        constant number dotProduct = DotProduct(target)

        if dotProduct > 0.9995 or dotProduct < -0.9995
            return LinearInterpolation(target, alpha)
        end

        constant number theta0 = math:InverseCosine(dotProduct)
        constant number theta = theta0 * alpha

        constant number st = math:Sine(theta)
        constant number tx = target:GetX() - x * dotProduct
        constant number ty = target:GetY() - y * dotProduct
        constant number tz = target:GetZ() - z * dotProduct
        constant number l2 = tx * tx + ty * ty + tz * tz
        number dl = 0

        if l2 < 0.0001
            dl = 1.0
        else
            dl = 1.0 / math:SquareRoot(l2)
        end

        return Scale(math:Cosine(theta)):Add(tx * dl, ty * dl, tz * dl):Normalize()
    end

    action ToText() returns text
        return "[" + x + "," + y + "," + z + "]"
    end

    action Limit(number limit) returns Vector3
        return Limit2(limit * limit)
    end

    action Limit2(number limit2) returns Vector3
        number len2 = LengthSquared()
        if len2 > limit2
            Scale(math:SquareRoot(limit2 / len2))
        end
        
        return me
    end

    action Clamp(number min, number max) returns Vector3
        number len2 = LengthSquared()
        if len2 = 0.0
            return me
        end
        
        number max2 = max * max
        if len2 > max2
            return Scale(math:SquareRoot(max2 / len2))
        end

        number min2 = min * min
        if len2 < min2
            return Scale(math:SquareRoot(min2 / len2))
        end

        return me
    end

    /* action hashCode () returns integer
        constant integer prime = 31
        integer result = 1
        result = prime * result + numberUtils:floatToIntBits(x)
        result = prime * result + numberUtils:floatToIntBits(y)
        result = prime * result + numberUtils:floatToIntBits(z)
        return result
    end */

    /* action equals (Object obj) returns boolean
        Vector3 temp = cpy()
        if temp = obj
            return true
        end
        if obj = null
            return false
        end */

    action EqualAtPrecision (Vector3 other, number epsilon) returns boolean
        if other = undefined
            return false
        end
        if math:AbsoluteValue(other:GetX() - x) > epsilon
            return false
        end
        if math:AbsoluteValue(other:GetY() - y) > epsilon
            return false
        end
        if math:AbsoluteValue(other:GetZ() - z) > epsilon
            return false
        end
        return true
    end

    action EqualAtPrecision(number xVal, number yVal, number zVal, number epsilon) returns boolean  
        if math:AbsoluteValue(xVal - x) > epsilon
            return false
        end
        if math:AbsoluteValue(yVal - y) > epsilon
            return false
        end
        if math:AbsoluteValue(zVal - z) > epsilon
            return false
        end
        return true
    end

    action SetToZero returns Vector3
        x = 0
        y = 0
        z = 0
        return me
    end

end