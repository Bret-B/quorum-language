package Libraries.Compute

use Libraries.Containers.Array
use Libraries.Compute.Math
use Libraries.Compute.Vector2
use Libraries.Compute.Vector3
use Libraries.Compute.Matrix3
use Libraries.Compute.Matrix4

class Affine2 
    
    public number M00 = 1.0
    public number M01 = 0.0
    public number M02 = 0.0
    public number M10 = 0.0
    public number M11 = 1.0
    public number M12 = 0.0
    Math math



    action PrintValues()
    
        output "M00 = " + M00 + " M01 = " + M01 + " M02 = " + M02 + " M10 = " + M10 + " M11 = " + M11 + " M12 = " + M12

    end

    action Identity returns Affine2
        M00 = 1
        M01 = 0
        M02 = 0
        M10 = 0
        M11 = 1
        M12 = 0

        return me
    end

    action Set(Affine2 other) returns Affine2

        M00 = other:M00
        M01 = other:M01
        M02 = other:M02
        M10 = other:M10
        M11 = other:M11
        M12 = other:M12

        return me
    end

    action Set(Matrix3 matrix) returns Affine2

        Array<number> matrixValues = matrix:values

        M00 = matrixValues:Get(matrix:M00)
        M01 = matrixValues:Get(matrix:M01)
        M02 = matrixValues:Get(matrix:M02)
        M10 = matrixValues:Get(matrix:M10)
        M11 = matrixValues:Get(matrix:M11)
        M12 = matrixValues:Get(matrix:M12)

        return me
    end

    action Set(Matrix4 matrix) returns Affine2

        Array<number> matrixValues = matrix:values

        M00 = matrixValues:Get(matrix:M00)
        M01 = matrixValues:Get(matrix:M01)
        M02 = matrixValues:Get(matrix:M03)
        M10 = matrixValues:Get(matrix:M10)
        M11 = matrixValues:Get(matrix:M11)
        M12 = matrixValues:Get(matrix:M13)

        return me
    end

    action SetToTranslation (number x, number y) returns Affine2

        M00 = 1
        M01 = 0
        M02 = x
        M10 = 0
        M11 = 1
        M12 = y
        
        return me
    end

    action SetToTranslation (Vector2 vector) returns Affine2

        return SetToTranslation(vector:GetX(), vector:GetY())
    
    end

    action SetToScaling (number scaleX, number scaleY) returns Affine2

        M00 = scaleX
        M01 = 0
        M02 = 0
        M10 = 0
        M11 = scaleY
        M12 = 0

        return me
    end

    action SetToScaling (Vector2 scale) returns Affine2
        
        return SetToScaling(scale:GetX(), scale:GetY())
     
    end

    action SetToRotation (number degrees) returns Affine2
        
        number cosine = math:Cosine(math:DegreesToRadians(degrees))
        number sine = math:Sine(math:DegreesToRadians(degrees))

        M00 = cosine
        M01 = sine * -1
        M02 = 0
        M10 = sine
        M11 = cosine
        M12 = 0

        return me
    end

    action SetToRotationInRadians (number radians) returns Affine2

        number cosine = math:Cosine(radians)
        number sine = math:Sine(radians)

        M00 = cosine
        M01 = sine * -1
        M02 = 0
        M10 = sine
        M11 = cosine
        M12 = 0

        return me
    end

    action SetToRotation (number cosine, number sine) returns Affine2

        M00 = cosine
        M01 = sine * -1
        M02 = 0
        M10 = sine
        M11 = cosine
        M12 = 0
        
        return me

    end

    action SetToShearing (number shearX, number shearY) returns Affine2
        
        M00 = 1
        M01 = shearX
        M02 = 0
        M10 = shearY
        M11 = 1
        M12 = 0

        return me
    end

    action SetToShearing (Vector2 vector) returns Affine2

        return SetToShearing (vector:GetX(), vector:GetY())
        
    end

    action SetToTranslationRotationScale(number x, number y, number degrees, number scaleX, number scaleY) returns Affine2
    
        M02 = x
        M12 = y

        if degrees = 0

            M00 = scaleX
            M01 = 0
            M10 = 0
            M11 = scaleY

        else
            
            number cosine = math:Cosine(math:DegreesToRadians(degrees))
	    number sine = math:Sine(math:DegreesToRadians(degrees))

            M00 = cosine * scaleX
            M01 = -1 * sine * scaleY
            M10 = sine * scaleX
            M11 = cosine * scaleY
            
        end

        return me
    end

    action SetToTranslationRotationScale(Vector2 translation, number degrees, Vector2 scale) returns Affine2
    
        return SetToTranslationRotationScale(translation:GetX(), translation:GetY(), degrees, scale:GetX(), scale:GetY())

    end

    action SetToTranslationRotationRadiansScale (number x, number y, number radians, number scaleX, number scaleY) returns Affine2
        
        M02 = x
        M12 = y

        if radians = 0

            M00 = scaleX
            M01 = 0
            M10 = 0
            M11 = scaleY

        else
            
            sine = math:Sine(radians)
            cosine = math:Cosine(radians)

            M00 = cosine * scaleX
            M01 = -1 * sine * scaleY
            M10 = sine * scaleX
            M11 = cosine * scaleY
            
        end
        
        return me
    end

    action SetToTranslationRotationRadiansScale(Vector2 translation, number radians, Vector2 scale) returns Affine2
    
        return SetToTranslationRotationRadiansScale(translation:GetX(), translation:GetY(), radians, scale:GetX(), scale:GetY())

    end

    action SetToTranslationScale (number x, number y, number scaleX, number scaleY) returns Affine2
        
        M00 = scaleX
        M01 = 0
        M02 = x
        M10 = 0
        M11 = scaleY
        M12 = y
        
        return me
    end

    action SetToTranslationScale (Vector2 translation, Vector2 scale) returns Affine2
        
        return SetToTranslationScale (translation:GetX(), translation:GetY(), scale:GetX(), scale:GetY())
       
    end

    action SetToProduct (Affine2 left, Affine2 right) returns Affine2

        M00 = left:M00 * right:M00 + left:M01 * right:M10
        M01 = left:M00 * right:M01 + left:M01 * right:M11
        M02 = left:M00 * right:M02 + left:M01 * right:M12 + left:M02
        M10 = left:M10 * right:M00 + left:M11 * right:M10
        M11 = left:M10 * right:M01 + left:M11 * right:M11
        M12 = left:M10 * right:M02 + left:M11 * right:M12 + left:M12

        return me
    end

    action Invert returns Affine2

        number determinant = Determinant()

        // if determinant = 0
        // throw exception
        // end

        number inverseDeterminant = 1.0 / determinant

        number tmp00 = M11
        number tmp01 = -1 * M01
        number tmp02 = M01 * M12 - M11 * M02
        number tmp10 = -1 * M10
        number tmp11 = M00
        number tmp12 = M10 * M02 - M00 * M12

        M00 = inverseDeterminant * tmp00
        M01 = inverseDeterminant * tmp01
        M02 = inverseDeterminant * tmp02
        M10 = inverseDeterminant * tmp10
        M11 = inverseDeterminant * tmp11
        M12 = inverseDeterminant * tmp12

        return me
    end

    action Multiply (Affine2 affine) returns Affine2
        
        number tmp00 = M00 * affine:M00 + M01 * affine:M10
        number tmp01 = M00 * affine:M01 + M01 * affine:M11
        number tmp02 = M00 * affine:M02 + M01 * affine:M12 + M02
        number tmp10 = M10 * affine:M00 + M11 * affine:M10
        number tmp11 = M10 * affine:M01 + M11 * affine:M11
        number tmp12 = M10 * affine:M02 + M11 * affine:M12 + M12

        M00 = tmp00
        M01 = tmp01
        M02 = tmp02
        M10 = tmp10
        M11 = tmp11
        M12 = tmp12

        return me
    end

    action PreMultiply (Affine2 affine) returns Affine2

        number tmp00 = affine:M00 * M00 + affine:M01 * M10
        number tmp01 = affine:M00 * M01 + affine:M01 * M11
        number tmp02 = affine:M00 * M02 + affine:M01 * M12 + affine:M02
        number tmp10 = affine:M10 * M00 + affine:M11 * M10
        number tmp11 = affine:M10 * M01 + affine:M11 * M11
        number tmp12 = affine:M10 * M02 + affine:M11 * M12 + affine:M12

        M00 = tmp00
        M01 = tmp01
        M02 = tmp02
        M10 = tmp10
        M11 = tmp11
        M12 = tmp12

        return me
    end

    action Translate (number x, number y) returns Affine2

        M02 = M02 + (M00 * x + M01 * y)
        M12 = M12 + (M10 * x + M11 * y)
        
        return me
    end

    action Translate (Vector2 translate) returns Affine2
        
        return Translate (translate:GetX(), translate:GetY())

    end

    action PreTranslate (number x, number y) returns Affine2

        M02 = M02 + x
        M12 = M12 + y
        
        return me
    end

    action PreTranslate (Vector2 translate) returns Affine2

        return PreTranslate (translate:GetX(), translate:GetY())

    end

    action Scale (number scaleX, number scaleY) returns Affine2

        M00 = M00 * scaleX
        M01 = M01 * scaleY
        M10 = M10 * scaleX
        M11 = M11 * scaleY

        return me
    end

    action Scale (Vector2 scale) returns Affine2

        return Scale(scale:GetX(), scale:GetY())
        
    end

    action PreScale (number scaleX, number scaleY) returns Affine2

        M00 = M00 * scaleX
        M01 = M01 * scaleX
        M02 = M02 * scaleX
        M10 = M10 * scaleY
        M11 = M11 * scaleY
        M12 = M12 * scaleY

        return me
   end

    action PreScale (Vector2 scale) returns Affine2
        
        return PreScale (scale:GetX(), scale:GetY())

    end

    action Rotate (number degrees) returns Affine2

        if degrees = 0
            return me
        end
            
        number cosine = math:Cosine(math:DegreesToRadians(degrees))
        number sine = math:Sine(math:DegreesToRadians(degrees))

        number tmp00 = M00 * cosine + M01 * sine
        number tmp01 = M00 * (-1 * sine) + M01 * cosine
        number tmp10 = M10 * cosine + M11 * sine
        number tmp11 = M10 * (-1 * sine) + M11 * cosine

        M00 = tmp00
        M01 = tmp01
        M10 = tmp10
        M11 = tmp11

        return me
   end

    action RotateInRadians (number radians) returns Affine2

        if radians = 0
            return me
        end
            
        number cosine = math:Cosine(radians)
        number sine = math:Sine(radians)

        number tmp00 = M00 * cosine + M01 * sine
        number tmp01 = M00 * (-1 * sine) + M01 * cosine
        number tmp10 = M10 * cosine + M11 * sine
        number tmp11 = M10 * (-1 * sine) + M11 * cosine

        M00 = tmp00
        M01 = tmp01
        M10 = tmp10
        M11 = tmp11

        return me
    end

    action PreRotate (number degrees) returns Affine2

        if degrees = 0
            return me
        end

        number cosine = math:Cosine(math:DegreesToRadians(degrees))
        number sine = math:Sine(math:DegreesToRadians(degrees))

        number tmp00 = cosine * M00 - sine * M10
        number tmp01 = cosine * M01 - sine * M11
        number tmp02 = cosine * M02 - sine * M12
        number tmp10 = sine * M00 + cosine * M10
        number tmp11 = sine * M01 + cosine * M11
        number tmp12 = sine * M02 + cosine * M12

        M00 = tmp00
        M01 = tmp01
        M02 = tmp02
        M10 = tmp10
        M11 = tmp11
        M12 = tmp12

        return me

    end

    action PreRotateInRadians (number radians) returns Affine2

        if radians = 0
            return me
        end

        number cosine = math:Cosine(radians)
        number sine = math:Sine(radians)

        number tmp00 = cosine * M00 - sine * M10
        number tmp01 = cosine * M01 - sine * M11
        number tmp02 = cosine * M02 - sine * M12
        number tmp10 = sine * M00 + cosine * M10
        number tmp11 = sine * M01 + cosine * M11
        number tmp12 = sine * M02 + cosine * M12

        M00 = tmp00
        M01 = tmp01
        M02 = tmp02
        M10 = tmp10
        M11 = tmp11
        M12 = tmp12

        return me

    end

    action Shear (number shearX, number shearY) returns Affine2

        number tmp0 = M00 + shearY * M01
        number tmp1 = M01 + shearX * M00
        M00 = tmp0
        M01 = tmp1

        tmp0 = M10 + shearY * M11
        tmp1 = M11 + shearX * M10
        M10 = tmp0
        M11 = tmp1

        return me
    end

    action Shear (Vector2 shear) returns Affine2

        return Shear (shear:GetX(), shear:GetY())

    end

    action PreShear (number shearX, number shearY) returns Affine2

        number tmp00 = M00 + shearX * M10
        number tmp01 = M01 + shearX * M11
        number tmp02 = M02 + shearX * M12
        number tmp10 = M10 + shearY * M00
        number tmp11 = M11 + shearY * M01
        number tmp12 = M12 + shearY * M02

        M00 = tmp00
        M01 = tmp01
        M02 = tmp02
        M10 = tmp10
        M11 = tmp11
        M12 = tmp12

        return me
    end

    action PreShear (Vector2 shear) returns Affine2

        return PreShear (shear:GetX(), shear:GetY())

    end

    action Determinant returns number

        return M00 * M11 - M01 * M10

    end

    action GetTranslation(Vector2 position) returns Vector2
        //Vector2 position

        position:Set(M02, M12)

        return position

    end

    action IsTranslation () returns boolean

        return M00 = 1 and M11 = 1 and M01 = 0 and M10 = 0

    end

    action IsIdentityMatrix () returns boolean

        return M00 = 1 and M02 = 0 and M12 = 0 and M11 = 1 and M01 = 0 and M10 = 0

    end

    action ApplyAffineTransformation (Vector2 point)
    
        number x = point:GetX()
        number y = point:GetY()

        point:Set(M00 * x + M01 * y + M02, M10 * x + M11 * y + M12)

    end

    action ToText () returns text

        return "[" + M00 + "|" + M01 + "|" + M02 + "]
                ["+ M10 + "|" + M11 + "|" + M12 + "]
                [0.0|0.0|0.1]"

    end    

end