package Libraries.Compute

use Libraries.Compute.Math
use Libraries.Containers.Array
use Libraries.Compute.Vector3

class Quaternion 
    
    number x = 0
    number y = 0
    number z = 0
    number w = 0

    constant number DECIMAL_ROUNDING_ERROR = 0.000001

    Math math

    action Set(number a, number b, number c, number d) returns Quaternion
	x = a
	y = b
	z = c
	w = d
        return me
    end

    action Set(Quaternion quad) returns Quaternion
        return Set(quad:GetX(), quad:GetY(), quad:GetZ(), quad:GetW())
    end

    action Set(Vector3 axis, number angle) returns Quaternion
        return SetFromAxis(axis:GetX(), axis:GetY(), axis:GetZ(), angle)
    end

    action Copy returns Quaternion
        Quaternion ret
        ret:Set(me)
        return ret
    end

    action GetX returns number
	return x
    end

    action GetY returns number
	return y
    end

    action GetZ returns number
	return z
    end

    action GetW returns number
	return w
    end

    action Length(number a, number b, number c, number d) returns number
        return math:SquareRoot(a * a + b * b + c * c + d * d)
    end

    action Length returns number
        return math:SquareRoot(x * x + y * y + z * z + w * w)
    end

    action ToText returns text
        return "[" + x + "|" + y + "|" + z + "|" + w + "]"
    end

    action SetEulerAngles(number yaw, number pitch, number roll) returns Quaternion
        return SetEulerAnglesRadians(yaw * math:pi / 180, pitch * math:pi / 180, roll * math:pi / 180)
    end

    action SetEulerAnglesRadians(number yaw, number pitch, number roll) returns Quaternion
        number hr = roll * 0.5
        number shr = math:Sine(hr)
        number chr = math:Cosine(hr)
        number hp = pitch * 0.5
        number shp = math:Sine(hp)
        number chp = math:Cosine(hp)
        number hy = yaw * 0.5
        number shy = math:Sine(hy)
        number chy = math:Cosine(hy)
        number chy_shp = chy * shp
        number shy_chp = shy * chp
        number chy_chp = chy * chp
        number shy_shp = shy * shp

        x = (chy_shp * chr) + (shy_chp * shr)
        y = (shy_chp * chr) - (chy_shp * shr)
        z = (chy_chp * shr) - (shy_shp * chr)
        w = (chy_chp * chr) + (shy_shp * shr)
        return me
    end

    action GetGimbalPole returns integer
        number t = y * x + z * w
        if t > 0.499
            return 1
        elseif t < -0.499
            return -1
        else
            return 0
        end
    end

    action GetRollRad returns number
        integer pole = GetGimbalPole()
        if pole = 0
            return math:InverseTangent(2.0 * (w * z + y * x), 1.0 - 2.0 *(x * x + z * z))
        else
            return pole * 2.0 * math:InverseTangent(y, w)
        end
    end

    action GetRoll returns number
        return GetRollRad() * 180 / math:pi
    end

    action GetPitchRad returns number
        integer pole = GetGimbalPole()
        if pole = 0
            return math:InverseSine(Clamp(2.0 * (w * x + z * y), -1.0, 1.0))
        else
            return pole * math:pi * 0.5
        end
    end

    action GetPitch returns number
        return GetPitchRad() * 180 / math:pi
    end

    action GetYawRad returns number
        if GetGimbalPole() = 0
            return math:InverseTangent(2.0 * (y * w + x * z), 1.0 - 2.0 * (y * y + x * x))
        else
            return 0.0
        end
    end

    action GetYaw returns number
        return GetYawRad() * 180 / math:pi
    end

    action LengthSquared(number a, number b, number c, number d) returns number
        return a * a + b * b + c * c + d * d
    end
    
    action LengthSquared returns number
        return x * x + y * y + z * z + w * w
    end

    action Normalize returns Quaternion
        number length = LengthSquared()
        if length not= 0.0 and not IsEqual(length, 1.0)
            length = math:SquareRoot(length)
            w = w / length
            x = x / length
            y = y / length
            z = z / length
        end
        return me
    end

    action Conjugate returns Quaternion
        x = -1 * x
        y = -1 * y
        z = -1 * z
        return me
    end

    action Transform(Vector3 vector) returns Vector3
        Quaternion temp2
        Quaternion temp1

        temp2:Set(me)
        temp2:Conjugate()
        temp2:MultiplyLeft(temp1:Set(vector:GetX(), vector:GetY(), vector:GetZ(), 0)):MultiplyLeft(me)

        vector:SetX(temp2:GetX())
        vector:SetY(temp2:GetY())
        vector:SetZ(temp2:GetZ())
        return vector
    end

    action Multiply(Quaternion other) returns Quaternion
        number newX = me:GetW() * other:GetX() + me:GetX() * other:GetW() + me:GetY() * other:GetZ() - me:GetZ() * other:GetY()
        number newY = me:GetW() * other:GetY() + me:GetY() * other:GetW() + me:GetZ() * other:GetX() - me:GetX() * other:GetZ()
        number newZ = me:GetW() * other:GetZ() + me:GetZ() * other:GetW() + me:GetX() * other:GetY() - me:GetY() * other:GetX()
        number newW = me:GetW() * other:GetW() - me:GetX() * other:GetX() - me:GetY() * other:GetY() - me:GetZ() * other:GetZ()
        me:Set(newX, newY, newZ, newW)
        return me
    end

    action Multiply(number a, number b, number c, number d) returns Quaternion
        number newX = me:GetW() * a + me:GetX() * d + me:GetY() * c - me:GetZ() * b
        number newY = me:GetW() * b + me:GetY() * d + me:GetZ() * a - me:GetX() * c
        number newZ = me:GetW() * c + me:GetZ() * d + me:GetX() * b - me:GetY() * a
        number newW = me:GetW() * d - me:GetX() * a - me:GetY() * b - me:GetZ() * c
        me:Set(newX, newY, newZ, newW)
        return me
    end

    action MultiplyLeft(Quaternion other) returns Quaternion
        number newX = other:GetW() * me:GetX() + other:GetX() * me:GetW() + other:GetY() * me:GetZ() - other:GetZ() * me:GetY()
        number newY = other:GetW() * me:GetY() + other:GetY() * me:GetW() + other:GetZ() * me:GetX() - other:GetX() * me:GetZ()
        number newZ = other:GetW() * me:GetZ() + other:GetZ() * me:GetW() + other:GetX() * me:GetY() - other:GetY() * me:GetX()
        number newW = other:GetW() * me:GetW() - other:GetX() * me:GetX() - other:GetY() * me:GetY() - other:GetZ() * me:GetZ()
        me:Set(newX, newY, newZ, newW)
        return me
    end

    action MultiplyLeft(number a, number b, number c, number d) returns Quaternion
        number newX = d * me:GetX() + a * me:GetW() + b * me:GetZ() - c * me:GetY()
        number newY = d * me:GetY() + b * me:GetW() + c * me:GetX() - a * me:GetZ()
        number newZ = d * me:GetZ() + c * me:GetW() + a * me:GetY() - b * me:GetX()
        number newW = d * me:GetW() - a * me:GetX() - b * me:GetY() - c * me:GetZ()
        me:Set(newX, newY, newZ, newW)
        return me
    end

    action Add(Quaternion quaternion) returns Quaternion
        me:x = me:x + quaternion:GetX()
        me:y = me:y + quaternion:GetY()
        me:z = me:z + quaternion:GetZ()
        me:w = me:w + quaternion:GetW()
        return me
    end

    action Add(number qx, number qy, number qz, number qw) returns Quaternion
        me:x = me:x + qx
        me:y = me:y + qy
        me:z = me:z + qz
        me:w = me:w + qw
        return me
    end

    action ToMatrix(Array<number> matrix)
        Matrix4 matrix4

        number xx = x * x
        number xy = x * y
        number xz = x * z
        number xw = x * w
        number yy = y * y
        number yz = y * z
        number yw = y * w
        number zz = z * z
        number zw = z * w

        matrix:Set(matrix4:M00, 1 - 2 * (yy + zz))
        matrix:Set(matrix4:M01, 2 * (xy - zw))
        matrix:Set(matrix4:M02, 2 * (xz + yw))
        matrix:Set(matrix4:M03, 0)
        matrix:Set(matrix4:M10, 2 * (xy + zw))
        matrix:Set(matrix4:M11, 1 - 2 * (xx + zz))
        matrix:Set(matrix4:M12, 2 * (yz - xw))
        matrix:Set(matrix4:M13, 0)
        matrix:Set(matrix4:M20, 2 * (xz - yw))
        matrix:Set(matrix4:M21, 2 * (yz + xw))
        matrix:Set(matrix4:M22, 1 - 2 * (xx + yy))
        matrix:Set(matrix4:M23, 0)
        matrix:Set(matrix4:M30, 0)
        matrix:Set(matrix4:M31, 0)
        matrix:Set(matrix4:M32, 0)
        matrix:Set(matrix4:M33, 1)        
    end

    action SetToIdentity returns Quaternion
        return me:Set(0, 0, 0, 1)
    end


    action IsIdentity returns boolean
        return IsZero(x) and IsZero(y) and IsZero(z) and IsEqual(w, 1.0)
    end

    action IsIdentity(number tolerance) returns boolean
        return IsZero(x, tolerance) and IsZero(y, tolerance) and IsZero(z, tolerance) and IsEqual(w, 1.0, tolerance)
    end

    action SetFromAxis(Vector3 axis, number degrees) returns Quaternion
        return SetFromAxis(axis:GetX(), axis:GetY(), axis:GetZ(), degrees)
    end

    action SetFromAxis(number x, number y, number z, number degrees) returns Quaternion
        return SetFromAxisRadians(x, y, z, degrees * math:pi / 180)
    end

    action SetFromAxisRadians(Vector3 axis, number radians) returns Quaternion
        return SetFromAxisRadians(axis:GetX(), axis:GetY(), axis:GetZ(), radians)
    end

    action SetFromAxisRadians(number x, number y, number z, number radians) returns Quaternion
        Vector3 temp
        number d = temp:Length(x, y, z)
        if d = 0.0
            return SetToIdentity()
        end
        d = 1.0 / d

        number l_angle = 0

        if radians < 0
            l_angle = (math:pi * 2) - (-1 * radians mod (math:pi * 2))
        else
            l_angle = radians mod (math:pi * 2)
        end

        number l_sin = math:Sine(l_angle / 2)
        number l_cos = math:Cosine(l_angle / 2)
        return me:Set(d * x * l_sin, d * y * l_sin, d * z * l_sin, l_cos):Normalize()
    end

    action SetFromMatrix(boolean normalizeAxes, Matrix4 matrix) returns Quaternion
        Matrix4 matrix4
        return SetFromAxes(normalizeAxes, matrix:values:Get(matrix4:M00), matrix:values:Get(matrix4:M01), matrix:values:Get(matrix4:M02),
                                          matrix:values:Get(matrix4:M10), matrix:values:Get(matrix4:M11), matrix:values:Get(matrix4:M12), 
                                          matrix:values:Get(matrix4:M20), matrix:values:Get(matrix4:M21), matrix:values:Get(matrix4:M22))
    end

    action SetFromMatrix(Matrix4 matrix) returns Quaternion
        return SetFromMatrix(false, matrix)
    end

    action SetFromMatrix(boolean normalizeAxes, Matrix3 matrix) returns Quaternion
        Matrix3 matrix3
        return SetFromAxes(normalizeAxes, matrix:a00, matrix:a01, matrix:a02,
                                          matrix:a10, matrix:a11, matrix:a12, 
                                          matrix:a20, matrix:a21, matrix:a22)
    end

    action SetFromMatrix(Matrix3 matrix) returns Quaternion
        return SetFromMatrix(false, matrix)
    end

    action SetFromAxes(number xx, number xy, number xz, number yx, number yy, number yz, number zx, number zy, number zz) returns Quaternion
        return SetFromAxes(false, xx, xy, xz, yx, yy, yz, zx, zy, zz)
    end

    action SetFromAxes(boolean normalizeAxes, number xx, number xy, number xz, number yx, number yy, number yz, number zx, number zy, number zz) returns Quaternion
        Vector3 temp

        if normalizeAxes
            number lx = 1.0 / temp:Length(xx, xy, xz)
            number ly = 1.0 / temp:Length(yx, yy, yz)
            number lz = 1.0 / temp:Length(zx, zy, zz)

            xx = xx * lx
            xy = xy * lx
            xz = xz * lx
            yx = yx * ly
            yy = yy * ly
            yz = yz * ly
            zx = zx * lz
            zy = zy * lz
            zz = zz * lz
        end

        number t = xx + yy + zz

        if t >= 0
            number s = math:SquareRoot(t + 1)
            w = 0.5 * s
            s = 0.5 / s
            x = (zy - yz) * s
            y = (xz - zx) * s
            z = (yx - xy) * s
        elseif xx > yy and xx > zz
            number s = math:SquareRoot(1.0 + xx - yy - zz)
            x = s * 0.5
            s = 0.5 / s
            y = (yx + xy) * s
            z = (xz + zx) * s
            w = (zy - yz) * s
        elseif yy > zz
            number s = math:SquareRoot(1.0 + yy - xx - zz)
            y = s * 0.5
            s = 0.5 / s
            x = (yx + xy) * s
            z = (zy + yz) * s
            w = (xz - zx) * s
        else
            number s = math:SquareRoot(1.0 + zz - xx - yy)
            z = s * 0.5
            s = 0.5 / s
            x = (xz + zx) * s
            y = (zy + yz) * s
            w = (yx - xy) * s
        end

        return me
    end

    action SetFromCross(Vector3 v1, Vector3 v2) returns Quaternion
        number dot = Clamp(v1:DotProduct(v2), -1, 1)
        number angle = math:InverseCosine(dot)
        return SetFromAxisRadians(v1:GetY() * v2:GetZ() - v1:GetZ() * v2:GetY(), v1:GetZ() * v2:GetX() - v1:GetX() * v2:GetZ(), v1:GetX() * v2:GetY() - v1:GetY() * v2:GetX(), angle)
    end

    action SetFromCross(number x1, number y1, number z1, number x2, number y2, number z2) returns Quaternion
        Vector3 temp
        number dot = Clamp(temp:DotProduct(x1, y1, z1, x2, y2, z2), -1, 1)
        number angle = math:InverseCosine(dot)
        return SetFromAxisRadians(y1 * z2 - z1 * y2, z1 * x2 - x1 * z2, x1 * y2 - y1 * x2, angle)
    end

    action SphericalLinearInterpolation(Quaternion endQuaternion, number alpha) returns Quaternion
        number d = me:x * endQuaternion:GetX() + me:y * endQuaternion:GetY() + me:z * endQuaternion:GetZ() + me:w * endQuaternion:GetW()
        number absDot = 0
        if d < 0.0
            absDot = -1 * d
        else
            absDot = d
        end

        number scale0 = 1.0 - alpha
        number scale1 = alpha

        if (1 - absDot) > 0.1
            number angle = math:InverseCosine(absDot)
            number invSinTheta = 1.0 / math:Sine(angle)
            
            scale0 = (math:Sine(1.0 - alpha) * angle) * invSinTheta
            scale1 = (math:Sine(alpha * angle)) * invSinTheta
        end

        if d < 0.0
            scale1 = -1 * scale1
        end

        x = (scale0 * x) + (scale1 * endQuaternion:GetX())
        y = (scale0 * y) + (scale1 * endQuaternion:GetY())
        z = (scale0 * z) + (scale1 * endQuaternion:GetZ())
        w = (scale0 * w) + (scale1 * endQuaternion:GetW())
        
        return me
    end

    action SphericalLinearInterpolation(Array<Quaternion> q) returns Quaternion
        Quaternion temp1

        number w = 1.0 / q:GetSize()
        Set(q:Get(0)):Exponent(w)
        
        integer i = 1        
        repeat while i < q:GetSize()
            Multiply(temp1:Set(q:Get(i)):Exponent(w))
            i = i + 1
        end

        Normalize()
        return me
    end

    action SphericalLinearInterpolation(Array<Quaternion> q, Array<number> w) returns Quaternion
        Quaternion temp1

        Set(q:Get(0)):Exponent(w:Get(0))

        integer i = 1
        repeat while i < q:GetSize()
            Multiply(temp1:Set(q:Get(i)):Exponent(w:Get(i)))
            i = i + 1
        end

        Normalize()
        return me
    end

    action Exponent(number alpha) returns Quaternion
        number normal = Length()
        number normalExp = math:RaiseToPower(normal, alpha)

        number theta = math:InverseCosine(w / normal)
        
        number coeff = 0
        if math:AbsoluteValue(theta) < 0.001
            coeff = normalExp * alpha / normal
        else
            coeff = normalExp * math:Sine(alpha * theta) / (normal * math:Sine(theta))
        end

        w = normalExp * math:Cosine(alpha * theta)
        x = x * coeff
        y = y * coeff
        z = z * coeff

        Normalize()
        return me
    end

    action DotProduct(number x1, number y1, number z1, number w1, number x2, number y2, number z2, number w2) returns number
        return x1 * x2 + y1 * y2 + z1 * z2 + w1 * w2
    end

    action DotProduct(Quaternion other) returns number
        return me:x * other:GetX() + me:y * other:GetY() + me:z * other:GetZ() + me:w * other:GetW()
    end
    
    action DotProduct(number x, number y, number z, number w) returns number
        return me:x * x + me:y * y + me:z * z + me:w * w
    end

    action Multiply(number scalar) returns Quaternion
        me:x = me:x * scalar
        me:y = me:y * scalar
        me:z = me:z * scalar
        me:w = me:w * scalar
        return me
    end

    action GetAxisAngle(Vector3 axis) returns number
        return GetAxisAngleRadians(axis) * 180 / math:pi
    end

    action GetAxisAngleRadians(Vector3 axis) returns number
        if me:w > 1
            me:Normalize()
        end
        
        number angle = 2.0 * math:InverseCosine(me:w)
        number s = math:SquareRoot(1 - me:w * me:w)
        if s < DECIMAL_ROUNDING_ERROR
            axis:SetX(me:x)
            axis:SetY(me:y)
            axis:SetZ(me:z)
        else
            axis:SetX(me:x / s)
            axis:SetY(me:y / s)
            axis:SetZ(me:z / s)
        end
        
        return angle
    end

    action GetAngleRadians returns number
        if me:w > 1
            return 2.0 * math:InverseCosine(me:w / Length())
        else
            return 2.0 * math:InverseCosine(me:w)
        end
    end

    action GetAngle returns number
        return GetAngleRadians() * 180 / math:pi
    end

    action GetSwingTwist(number axisX, number axisY, number axisZ, Quaternion swing, Quaternion twist)
        Vector3 temp

        number d = temp:DotProduct(me:x, me:y, me:z, axisX, axisY, axisZ)
        twist:Set(axisX * d, axisY * d, axisZ * d, me:w):Normalize()
        swing:Set(twist):Conjugate():MultiplyLeft(me)
    end

    action GetSwingTwist(Vector3 axis, Quaternion swing, Quaternion twist)
        GetSwingTwist(axis:GetX(), axis:GetY(), axis:GetZ(), swing, twist)
    end

    action GetAngleAroundRadians(number axisX, number axisY, number axisZ) returns number
        Vector3 temp
        number d = temp:DotProduct(me:x, me:y, me:z, axisX, axisY, axisZ)
        number l2 = LengthSquared(axisX * d, axisY * d, axisZ * d, me:w)
        if IsZero(l2)
            return 0.0
        else 
            return 2.0 * math:InverseCosine(Clamp(me:w / math:SquareRoot(l2), -1.0, 1.0))
        end
    end

    action GetAngleAroundRadians(Vector3 axis) returns number
        return GetAngleAroundRadians(axis:GetX(), axis:GetY(), axis:GetZ())
    end
    
    action GetAngleAround(number axisX, number axisY, number axisZ) returns number
        return GetAngleAroundRadians(axisX, axisY, axisZ) * 180 * math:pi
    end

    action GetAngleAround(Vector3 axis) returns number
        return GetAngleAround(axis:GetX(), axis:GetY(), axis:GetZ())
    end
    
    action Clamp(number value, number min, number max) returns number
        if value < min
            return min
        elseif value > max
            return max
        else
            return value
        end
    end

    action IsEqual(number value1, number value2) returns boolean
        return math:AbsoluteValue(value1 - value2) <= DECIMAL_ROUNDING_ERROR
    end

    action IsEqual(number value1, number value2, number tolerance) returns boolean
        return math:AbsoluteValue(value1 - value2) <= tolerance
    end

    action IsZero(number value) returns boolean
        return math:AbsoluteValue(value) <= DECIMAL_ROUNDING_ERROR
    end

    action IsZero(number value, number tolerance) returns boolean
        return math:AbsoluteValue(value) <= tolerance
    end

end