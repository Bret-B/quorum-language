package Libraries.Interface

use Libraries.Containers.List
use Libraries.Containers.Array
use Libraries.Containers.Blueprints.Iterator
use Libraries.Interface.Events.MouseListener
use Libraries.Interface.Events.MouseMovementListener
use Libraries.Interface.Events.MouseWheelListener
use Libraries.Interface.Events.MouseEvent
use Libraries.Interface.Events.KeyboardListener
use Libraries.Interface.Events.KeyboardEvent
use Libraries.Interface.Events.TouchListener
use Libraries.Interface.Events.TouchEvent
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Painter
use Libraries.Game.Shapes.Rectangle
use Libraries.Compute.Math


/*
    The Item class represents any object that has a position on the screen.
    They have X and Y coordinates, representing their horizontal and vertical
    position in 2D space, respectively. They also have corresponding width and
    height, which combine with the x, y coordinates to make a rectangle. Note
    that Items on their own can't be seen on the screen. To make an Item that
    can be drawn directly on the screen, use a Libraries.Game.Graphics.Drawable
    instead.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        
        myItem:SetPosition(20, 60)
        myItem:SetWidth(50)
        myItem:SetHeight(15)
*/
class Item 

    private number x = 0
    private number y = 0
    private number z = 0
    public number width = 0
    public number height = 0
    public number depth = 0
    private text name = "Unnamed"
    private boolean visible = true
    private boolean enabled = true

    private Item parentItem = undefined

    private Array<Item> children

    List<MouseListener> mouseListeners
    List<MouseMovementListener> mouseMoveListeners
    List<MouseWheelListener> mouseWheelListeners
    List<KeyboardListener> keyboardListeners
    List<TouchListener> touchListeners
    
    private number originX = 0.0
    private number originY = 0.0
    private number rotation = 0.0
    private number scaleX = 1
    private number scaleY = 1
    private number offsetX = 0
    private number offsetY = 0
    private boolean flipX = false
    private boolean flipY = false
    private boolean flipZ = false

    private boolean verticesChanged = true
    private Rectangle bounds

    constant integer VERTEX_SIZE = 5
    constant integer DRAWABLE_SIZE = 4 * VERTEX_SIZE

    Array<number> vertices

    on create
        vertices:SetSize(20)
    end

    // These constants represent certain aspects of each vertex. For example,
    // X1 and Y2 represent the x value of the first vertex and the y value of
    // the second vertex, respectively.
    constant integer X1 = 0
    constant integer Y1 = 1
    constant integer C1 = 2
    constant integer U1 = 3
    constant integer V1 = 4
    constant integer X2 = 5
    constant integer Y2 = 6
    constant integer C2 = 7
    constant integer U2 = 8
    constant integer V2 = 9
    constant integer X3 = 10
    constant integer Y3 = 11
    constant integer C3 = 12
    constant integer U3 = 13
    constant integer V3 = 14
    constant integer X4 = 15
    constant integer Y4 = 16
    constant integer C4 = 17
    constant integer U4 = 18
    constant integer V4 = 19

    
    /*
    This action sets the X coordinate of the Item.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetX(35.0)
    */
    action SetX(number setX)
        TranslateX(setX - x)
    end

    /*
    This action sets the Y coordinate of the Item.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetY(210.0)
    */
    action SetY(number setY)
        TranslateY(setY - y)
    end

    /* An Item can also represent an object in three dimensional space, but 
    currently this functionality is not supported. When it is, this action will
    set the Z coordinate of the Item. */
    action SetZ(number newZ)
        z = newZ
    end

    /*
    This action returns the currently set X coordinate of the Item.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        number value = myItem:GetX()
    */
    action GetX returns number
        return x
    end

    /*
    This action returns the currently set Y coordinate of the Item.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        number value = myItem:GetY()
    */
    action GetY returns number
        return y
    end

    /* An Item can also represent an object in three dimensional space, but 
    currently this functionality is not supported. When it is, this action will
    return the Z coordinate of the Item. */
    action GetZ returns number
        return z
    end

    /*
    This action will set both the X coordinate and the Y coordinate of the Item,
    in that order.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetPosition(30, 70)
    */
    action SetPosition(number setX, number setY)
        Translate(setX - GetX(), setY - GetY())
    end

    /* An Item can also represent an object in three dimensional space, but 
    currently this functionality is not supported. When it is, this action will
    set the X, Y, and Z coordinates of the Item. */
    action SetPosition(number newX, number newY, number newZ)
        SetPosition(newX, newY)
        z = newZ
    end

    /*
    This action will set the width of the Item.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetWidth(50)
    */
    action SetWidth(number newWidth)
        width = newWidth
    end

    /*
    This action will set the height of the Item.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetHeight(70)
    */
    action SetHeight(number newHeight)
        height = newHeight
    end

    /* An Item can also represent an object in three dimensional space, but 
    currently this functionality is not supported. When it is, this action will
    set the depth of the Item. */
    action SetDepth(number newDepth)
        depth = newDepth
    end

    /*
    This action will set the X coordinate of the Item so that the center of the
    Item is aligned with the given X coordinate value.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetCenterX(70)
    */
    action SetCenterX(number setX)
        SetX(setX - width / 2.0)
    end

    /*
    This action will set the Y coordinate of the Item so that the center of the
    Item is aligned with the given Y coordinate value.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetCenterY(65)
    */
    action SetCenterY(number setY)
        SetY(setY - height / 2.0)
    end

    /*
    This action will set the X and Y coordinates of the Item so that the center
    of the Item is located at the given X, Y coordinates.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetCenter(70)
    */
    action SetCenter(number setX, number setY)
        SetCenterX(setX)
        SetCenterY(setY)
    end
    
    /*
    This action will return the currently set width of the Item.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        number width = myItem:GetWidth()
    */
    action GetWidth returns number
        return width
    end

    /*
    This action will return the currently set height of the Item.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        number height = myItem:GetHeight()
    */
    action GetHeight returns number
        return height
    end

    /* An Item can also represent an object in three dimensional space, but 
    currently this functionality is not supported. When it is, this action will
    return the currently set depth of the Item. */
    action GetDepth returns number
        return depth
    end

    /* This action sets the X offset of the item. The offset tells the Item
    where to relate its X position to. In other words, the X offset is where an
    X coordinate of 0 is for this Item. 

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetOffsetX(100)
    */
    action SetOffsetX(number xAmount)
        if xAmount not= offsetX and verticesChanged = false
            number adjust = xAmount - offsetX

            vertices:Set(X1, vertices:Get(X1) + adjust)
            vertices:Set(X2, vertices:Get(X2) + adjust)
            vertices:Set(X3, vertices:Get(X3) + adjust)
            vertices:Set(X4, vertices:Get(X4) + adjust)

            offsetX = xAmount
        end

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetOffsetX(x + xAmount)
        end
    end

    /* This action sets the Y offset of the item. The offset tells the Item
    where to relate its Y position to. In other words, the Y offset is where an
    Y coordinate of 0 is for this Item. 

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetOffsetY(75)
    */
    action SetOffsetY(number yAmount)
        if yAmount not= offsetY and verticesChanged = false
            number adjust = yAmount - offsetY
        
            vertices:Set(Y1, vertices:Get(Y1) + adjust)
            vertices:Set(Y2, vertices:Get(Y2) + adjust)
            vertices:Set(Y3, vertices:Get(Y3) + adjust)
            vertices:Set(Y4, vertices:Get(Y4) + adjust)
        
            offsetY = yAmount
        end

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetOffsetY(y + yAmount)
        end
    end

    /* This action will set both the X and Y offsets of the Item, respectively.

    Attribute: Example

        use Libraries.Interface.Item
        Item myItem
        myItem:SetOffset(100, 75)
    */
    action SetOffset(number xAmount, number yAmount)
        if (xAmount not= offsetX or yAmount not= offsetY) and verticesChanged = false
            Array<number> vertices = GetVertices()
            number adjustX = xAmount - offsetX
            number adjustY = yAmount - offsetY
            
            vertices:Set(X1, vertices:Get(X1) + adjustX)
            vertices:Set(Y1, vertices:Get(Y1) + adjustY)

            vertices:Set(X2, vertices:Get(X2) + adjustX)
            vertices:Set(Y2, vertices:Get(Y2) + adjustY)

            vertices:Set(X3, vertices:Get(X3) + adjustX)
            vertices:Set(Y3, vertices:Get(Y3) + adjustY)

            vertices:Set(X4, vertices:Get(X4) + adjustX)
            vertices:Set(Y4, vertices:Get(Y4) + adjustY)
        
            offsetX = xAmount
            offsetY = yAmount
        end
        

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetOffset(x + xAmount, y + yAmount)
        end
    end

    /* This action adds a MouseListener to the Item. If the Item ever receives
    a MouseEvent due to a mouse click, the mouse listener will be notified.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.MouseListener
        Item myItem
        MouseListener listener
        myItem:AddMouseListener(listener)
    */
    action AddMouseListener(MouseListener listener)
        mouseListeners:Add(listener)
    end

    /* This action removes a MouseListener from the Item. The listener will no
    longer receive notification if the Item gets a mouse click event.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.MouseListener
        Item myItem
        MouseListener listener
        myItem:AddMouseListener(listener)
        myItem:RemoveMouseListener(listener)
    */
    action RemoveMouseListener(MouseListener listener)
        mouseListeners:Remove(listener)
    end

    /* This action adds a MouseMovementListener to the Item. If the Item ever 
    receives a MouseEvent due to mouse movement, the listener will be notified.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.MouseMovementListener
        Item myItem
        MouseMovementListener listener
        myItem:AddMouseMovementListener(listener)
    */
    action AddMouseMovementListener(MouseMovementListener listener)
        mouseMoveListeners:Add(listener)
    end

    /* This action removes a MouseMovementListener from the Item. The listener 
    will no longer receive notification if the Item gets a mouse movement event.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.MouseMovementListener
        Item myItem
        MouseMovementListener listener
        myItem:AddMouseMovementListener(listener)
        myItem:RemoveMouseMovementListener(listener)
    */
    action RemoveMouseMovementListener(MouseMovementListener listener)
        mouseMoveListeners:Remove(listener)
    end

    /* This action adds a MouseWheelListener to the Item. If the Item ever 
    receives a MouseEvent due to the mouse wheel being scrolled, the listener
    will be notified.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.MouseWheelListener
        Item myItem
        MouseWheelListener listener
        myItem:AddMouseWheelListener(listener)
    */
    action AddMouseWheelListener(MouseWheelListener listener)
        mouseWheelListeners:Add(listener)
    end

    /* This action removes a MouseWheelListener from the Item. The listener 
    will no longer receive notification if the Item gets a mouse wheel event.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.MouseWheelListener
        Item myItem
        MouseWheelListener listener
        myItem:AddMouseWheelListener(listener)
        myItem:RemoveMouseWheelListener(listener)
    */
    action RemoveMouseWheelListener(MouseWheelListener listener)
        mouseWheelListeners:Remove(listener)
    end

    /* This action adds a KeyboardListener to the Item. Any time this Item
    receives a KeyboardEvent, all of the KeyboardListeners will be notified.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.KeyboardListener
        Item myItem
        KeyboardListener listener
        myItem:AddKeyboardListener(listener)
    */
    action AddKeyboardListener(KeyboardListener listener)
        keyboardListeners:Add(listener)
    end

    /* This action removes a KeyboardListener from the Item. The listener will
    no longer receive any notification if the Item gets a KeyboardEvent.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.KeyboardListener
        Item myItem
        KeyboardListener listener
        myItem:AddKeyboardListener(listener)
    */
    action RemoveKeyboardListener(KeyboardListener listener)
        keyboardListeners:Remove(listener)
    end

    /* In the future, Items will support touch functionality, but this is not
    currently supported. When it is, this will add a TouchListener to the Item. */
    action AddTouchListener(TouchListener listener)
        touchListeners:Add(listener)
    end

    /* In the future, Items will support touch functionality, but this is not
    currently supported. When it is, this will remove a TouchListener from the
    Item. */
    action RemoveTouchListener(TouchListener listener)
        touchListeners:Remove(listener)
    end

    /*  This action takes a mouse event and handles it. It will look first to
    see if any of the items that were added to this Item contain the coordinates
    of the mouse event, and if one does, it will let that Item process it. If no
    child Item is found that contains it, it will send the event to the
    appropriate mouse event listeners that have been added to this Item.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.MouseEvent
        use Libraries.Interface.Events.MouseListener
        Item myItem
        MouseListener listener
        myItem:AddMouseListener(listener)
        MouseEvent event
        event:eventType = event:CLICKED_MOUSE
        myItem:ProcessMouseEvent(event)
    
    */
    action ProcessMouseEvent(MouseEvent event)

        if not Contains(event:GetX(), event:GetY())
            if parentItem not= undefined
                parentItem:ProcessMouseEvent(event)
            end
            
            return now
        end

        if event:eventType = event:MOVED_MOUSE
            Iterator<MouseMovementListener> iterator = mouseMoveListeners:GetIterator()
            if iterator:HasNext()
                event:SetEventHandled(true)
            end

            repeat while iterator:HasNext()
                iterator:Next():MovedMouse(event)
            end

        elseif event:eventType = event:DRAGGED_MOUSE
            Iterator<MouseMovementListener> iterator = mouseMoveListeners:GetIterator()
            if iterator:HasNext()
                event:SetEventHandled(true)
            end

            repeat while iterator:HasNext()
                iterator:Next():DraggedMouse(event)
            end

        elseif event:eventType = event:CLICKED_MOUSE
            Iterator<MouseListener> iterator = mouseListeners:GetIterator()
            if iterator:HasNext()
                event:SetEventHandled(true)
            end

            repeat while iterator:HasNext()
                iterator:Next():ClickedMouse(event)
            end

        elseif event:eventType = event:RELEASED_MOUSE
            Iterator<MouseListener> iterator = mouseListeners:GetIterator()
            if iterator:HasNext()
                event:SetEventHandled(true)
            end

            repeat while iterator:HasNext()
                iterator:Next():ReleasedMouse(event)
            end

        elseif event:eventType = event:SCROLLED_MOUSE
            Iterator<MouseWheelListener> iterator = mouseWheelListeners:GetIterator()
            if iterator:HasNext()
                event:SetEventHandled(true)
            end

            repeat while iterator:HasNext()
                iterator:Next():ScrolledMouse(event)
            end
        end

        if not event:WasEventHandled() and parentItem not= undefined
            parentItem:ProcessMouseEvent(event)
        end
    end

    /*  This action takes a keyboard event and passes it to all KeyboardListeners
    that were added to this Item. 

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Interface.Events.KeyboardEvent
        use Libraries.Interface.Events.KeyboardListener
        Item myItem
        KeyboardListener listener
        myItem:AddKeyboardListener(listener)
        KeyboardEvent event
        event:eventType = event:PRESSED_KEY
        myItem:ProcessKeyboardEvent(event)
    
    */
    action ProcessKeyboardEvent(KeyboardEvent event)
        
        Iterator<KeyboardListener> iterator = keyboardListeners:GetIterator()

        if event:eventType = event:PRESSED_KEY
            repeat while iterator:HasNext()
                iterator:Next():PressedKey(event)
            end

        elseif event:eventType = event:RELEASED_KEY
            repeat while iterator:HasNext()
                iterator:Next():ReleasedKey(event)
            end
        end

    end

    /* In the future, Items will support touch functionality, but this is not
    currently supported. When it is, this will send a TouchEvent to all of the
    TouchListeners that have been added to this Item. */
    action ProcessTouchEvent(TouchEvent event)
        // NOT YET IMPLEMENTED
    end

    /*  This action updates the item. It takes a number parameter that should
    indicate how many seconds have passed since the last time this action was
    called. This action does nothing in the Item class, but any class that
    inherits from Item may override it.

    Attribute: Parameter secondsSinceUpdate The number of seconds that have passed since the last time Update was called.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.System.DateTime
        
        class Main is Item

            action Main
                // We'll use a DateTime object to count seconds.
                DateTime time
                number currentTime = time:GetEpochTime()
                number newTime = 0

                repeat while GetX() < 300
                    // Check what the time is now.
                    newTime = time:GetEpochTime()

                    // Calculate how many seconds have passed, then call Update.
                    Update( (newTime - currentTime)/1000 )

                    // Store the old time.
                    currentTime = newTime
                end
            end

            // Our update action will move our Item to the right at 200 units a second.
            action Update(number secondsSinceUpdate)
                SetX(GetX() + 200 * secondsSinceUpdate)
                output "Our item is now at " + GetX()
            end
        end
    
    */
    action Update(number secondsSinceUpdate)

    end

    /*  This action calls the Update action on this Item and all Items that have
    been added to this item with the Add action.

    Attribute: Parameter secondsSinceUpdate The number of seconds that have passed since the last time Update was called.

    Attribute: Example

        use Libraries.Interface.Item
        
        Item parent
        Item child1
        Item child2
        parent:Add(child1)
        parent:Add(child2)
        parent:UpdateAll(0)
    */
    action UpdateAll(number secondsSinceUpdate)
        Update(secondsSinceUpdate)

        Iterator<Item> itemIterator = GetItems()
        Item temp = undefined

        repeat while itemIterator:HasNext()
            itemIterator:Next():UpdateAll(secondsSinceUpdate)
        end
    end

    /*  This action is used to indicate that two items have just begun colliding.
    When two Items collide, the BeginCollision action should be called on both
    of them, with the other item passed as a parameter to the action. Note that 
    this action does nothing by default, but classes that inherit from Item may 
    override it.

    Attribute: Parameter item The other Item involved in the collision.

    Attribute: Example

        use Libraries.Interface.Item

        Item collider1
        Item collider2
        collider1:BeginCollision(collider2)
        collider2:BeginCollision(collider1)
    */
    action BeginCollision(Item item)
        
    end

    /*  This action is used to indicate that two items that were previously
    colliding no longer are. The FinishCollision action should be called on both
    Items involved, with the other item passed as a parameter to the action. 
    Note that this action does nothing by default, but classes that inherit from
    Item may override it.

    Attribute: Parameter item The other Item involved in the collision.

    Attribute: Example

        use Libraries.Interface.Item

        Item collider1
        Item collider2
        collider1:FinishCollision(collider2)
        collider2:FinishCollision(collider1)
    */
    action FinishCollision(Item item)

    end

    /*  This action is used to indicate that an Item and all Items that were
    added to it should be visible on the screen. Note that the Item class on its
    own cannot be drawn on the screen, but classes that inherit from it such as
    Libraries.Game.Graphics.Drawable can be. By default, Items are considered
    visible.

    Attribute: Example

        use Libraries.Interface.Item

        Item item
        item:Show()
    */
    action Show
        visible = true
    end

    /*  This action is used to indicate that an Item and all Items that were
    added to it should not be visible on the screen. Note that the Item class on
    its own cannot be drawn on the screen, but classes that inherit from it such
    as Libraries.Game.Graphics.Drawable can be. By default, Items are considered
    visible.

    Attribute: Example

        use Libraries.Interface.Item

        Item item
        item:Hide()
    */
    action Hide
        visible = false
    end

    /*  This action returns whether the Item is currently set to be visible on
    the screen.

    Attribute: Returns A boolean representing whether or not the Item is currently visible.

    Attribute: Example

        use Libraries.Interface.Item

        Item item
        item:Hide()
        boolean visible = item:IsShowing()
    */
    action IsShowing returns boolean
        return visible
    end

    /*  This action indicates that an Item should currently be active. Items are
    set to enabled by default.

    Attribute: Example

        use Libraries.Interface.Item

        Item item
        item:Enable()
    */
    action Enable
        enabled = true
    end

    /*  This action indicates that an Item should currently be inactive. Items
    are set to enabled by default.

    Attribute: Example

        use Libraries.Interface.Item

        Item item
        item:Disable()
    */
    action Disable
        enabled = false
    end

    /*  This action returns whether or not the Item is currently enabled.

    Attribute: Example

        use Libraries.Interface.Item

        Item item
        item:Disable()
        boolean active = item:IsEnabled()
    */
    action IsEnabled returns boolean
        return enabled
    end

    /*  This action sets the internal name of the Item.

    Attribute: Example

        use Libraries.Interface.Item

        Item item
        item:SetName("My Item")
    */
    action SetName(text newName)
        name = newName
    end

    /*  This action returns the current internal name of the Item.

    Attribute: Example

        use Libraries.Interface.Item

        Item item
        item:SetName("My Item")
        output "My item's name is " + item:GetName()
    */
    action GetName returns text
        return name
    end

    action SetParent(Item newItem)
        parentItem = newItem
    end

    /*  This action returns the parent of this Item. An Item gets a parent when
    it is added to another Item using the Add action.

    Attribute: Example

        use Libraries.Interface.Item

        Item parent
        Item child
        parent:Add(child)
        Item item = child:GetParent()
        
    */
    action GetParent returns Item
        return parentItem
    end

    /*  This action adds a different Item into this one. This makes a few things happen.
        1. The added item will get this item as its parent.
        2. The added item's x and y coordinates will become relative to this Item.
        3. Most actions on this Item will also effect the added Item.

    Attribute: Example

        use Libraries.Interface.Item

        Item parent
        Item child
        parent:Add(child)
        
    */
    action Add(Item newItem)
        children:Add(newItem)
        newItem:SetParent(me)
        newItem:PrepareVertices()
        newItem:SetOffset(x + offsetX, y + offsetY)
    end

    /*  This action adds a different Item into this one, storing the added Item
    at a specific index in the internal array.

    Attribute: Example

        use Libraries.Interface.Item

        Item parent
        Item child
        parent:Add(child, 0)
        
    */
    action Add(Item newItem, integer index)
        children:Add(index, newItem)
        newItem:SetParent(me)
        newItem:PrepareVertices()
        newItem:SetOffset(x + offsetX, y + offsetY)
    end

    /*  This action removes an Item that was previously added to this Item. 

    Attribute: Returns Whether or not the Item was found and removed.

    Attribute: Example

        use Libraries.Interface.Item

        Item parent
        Item child1
        Item child2
        parent:Add(child1)
        parent:Add(child2)
        parent:Remove(child1)
    */
    action Remove(Item removed) returns boolean
        boolean success = children:Remove(removed)
        removed:SetParent(undefined)
        return success
    end

    /*  This action removes an Item that was previously added to this Item by
    finding it at the given index in the internal array of children Items.

    Attribute: Returns The Item that was removed.

    Attribute: Example

        use Libraries.Interface.Item

        Item parent
        Item child1
        Item child2
        parent:Add(child1)
        parent:Add(child2)
        parent:Remove(0)
    */
    action Remove(integer index) returns Item
        Item temp = children:RemoveAt(index)
        temp:SetParent(undefined)
        return temp
    end

    /*  This action returns an Item that was previously added to this Item by
    finding it at the given index in the internal array of children Items.

    Attribute: Example

        use Libraries.Interface.Item

        Item parent
        Item child1
        Item child2
        parent:Add(child1)
        parent:Add(child2)
        Item temp = parent:GetItem(0)
    */
    action GetItem(integer index) returns Item
        return children:Get(index)
    end

    /*  This action returns an iterator containing all the items contained in
    this Item.

    Attribute: Example

        use Libraries.Interface.Item
        use Libraries.Containers.Blueprints.Iterator

        Item parent
        Item child1
        Item child2
        parent:Add(child1)
        parent:Add(child2)
        Iterator<Item> iterator = parent:GetItems()
    */
    action GetItems returns Iterator<Item>
        return children:GetIterator()
    end

    /*  This action returns the number of items contained in this Item.

    Attribute: Example

        use Libraries.Interface.Item

        Item parent
        Item child1
        Item child2
        parent:Add(child1)
        parent:Add(child2)
        integer size = parent:GetItemCount()
    */
    action GetItemCount returns integer
        return children:GetSize()
    end

    /*  This action sets a value inside the internal item array of this Item.

    Attribute: Example

        use Libraries.Interface.Item

        Item parent
        Item child1
        Item child2
        parent:Add(child1)
        parent:SetItem(0, child2)
    */
    action SetItem(integer index, Item newItem)
        children:Set(index, newItem)
    end

    /*  This action returns whether or not any items are contained in this Item.

    Attribute: Example

        use Libraries.Interface.Item

        Item parent
        Item child1
        parent:Add(child1)
        boolean wasEmpty = parent:IsEmpty()
    */
    action IsEmpty returns boolean
        return children:IsEmpty()
    end

    /*  This action tests if a point in global x,y coordinates is contained
    inside this Item. The global coordinates are considered to be the x and y
    coordinates of this Item plus its offsetX and offsetY values.

    Attribute: Returns Whether or not the point is contained in this Item.

    Attribute: Example

        use Libraries.Interface.Item

        Item item
        item:SetPosition(50, 50)
        item:SetWidth(100)
        item:SetHeight(50)
        boolean value = item:Contains(125, 70)
    */
    action Contains(number containsX, number containsY) returns boolean
        number testX = containsX - offsetX
        number testY = containsY - offsetY
        return testX >= x and testX <= x + width and testY >= y and testY <= y + height
    end

    /*
    action Contains(number x, number y, number z) returns boolean
        // TO BE IMPLEMENTED
        return false
    end*/

    action GetItemAt(number x, number y) returns Item
        integer counter = children:GetSize()
        Item temp = undefined
        boolean found = false
        repeat while counter > 0 and not found
            counter = counter - 1
            temp = children:Get(counter)
            temp = temp:GetItemAt(x, y)
            if temp not= undefined
                found = true
            end
        end

        if not found and Contains(x, y)
            return me
        else
            return temp
        end
    end

//    action GetItemAt(number x, number y, number z) returns Item
//        integer counter = children:GetSize()
//        Item temp = undefined
//        boolean found = false
//        repeat while counter > 0 and not found
//            counter = counter - 1
//            temp = children:Get(counter)
//            temp = temp:GetItemAt(x, y, z)
//            if temp not= undefined
//                found = true
//            end
//        end
//
//        if not found and Contains(x, y, z)
//            return me
//        else
//            return temp
//        end
//    end

    action Dispose
        
    end

    action DisposeChildren
        Iterator<Item> childIterator = GetItems()
        Item temp = undefined
        repeat while childIterator:HasNext()
            temp = childIterator:Next()
            temp:DisposeAll()
        end
    end

    action DisposeAll
        DisposeChildren()
        Dispose()
    end

    action Empty
        children:Empty()
    end

    action SetBoundingBox(number newX, number newY, number newWidth, number newHeight)
        SetX(newX)
        SetY(newY)
        width = newWidth
        height = newHeight

        number parentX = GetX()
        number parentY = GetY()

        number x2 = parentX + width
        number y2 = parentY + height

        vertices:Set(X1, parentX)
        vertices:Set(Y1, parentY)
        
        vertices:Set(X2, parentX)
        vertices:Set(Y2, y2)
        
        vertices:Set(X3, x2)
        vertices:Set(Y3, y2)
       
        vertices:Set(X4, x2)
        vertices:Set(Y4, parentY)

        if rotation not= 0 or scaleX not= 1 or scaleY not= 1
            verticesChanged = true
        end

    end

    action SetBoundingBox(number newX, number newY, number newZ, number newWidth, number newHeight, number newDepth)
        // NOT YET IMPLEMENTED
    end

    action SetSize(integer newWidth, integer newHeight)
        width = newWidth
        height = newHeight

        if verticesChanged = false
            number parentX = GetX()
            number parentY = GetY()
            number x2 = parentX + width
            number y2 = parentY + height

            vertices:Set(X1, parentX)
            vertices:Set(Y1, parentY)

            vertices:Set(X2, parentX)
            vertices:Set(Y2, y2)

            vertices:Set(X3, x2)
            vertices:Set(Y3, y2)

            vertices:Set(X4, x2)
            vertices:Set(Y4, parentY)

            if rotation not= 0 or scaleX not= 1 or scaleY not= 1
                verticesChanged = true
            end
        end

    end

    action TranslateX(number xAmount)
        x = x + xAmount
        if verticesChanged = false
            vertices:Set(X1, vertices:Get(X1) + xAmount)
            vertices:Set(X2, vertices:Get(X2) + xAmount)
            vertices:Set(X3, vertices:Get(X3) + xAmount)
            vertices:Set(X4, vertices:Get(X4) + xAmount)
        end
        SetOffsetX(offsetX)
    end

    action TranslateY(number yAmount)
        y = y + yAmount
        if verticesChanged = false
            vertices:Set(Y1, vertices:Get(Y1) + yAmount)
            vertices:Set(Y2, vertices:Get(Y2) + yAmount)
            vertices:Set(Y3, vertices:Get(Y3) + yAmount)
            vertices:Set(Y4, vertices:Get(Y4) + yAmount)
        end
        SetOffsetY(offsetY)
    end

    action Translate(number xAmount, number yAmount)
        x = x + xAmount
        y = y + yAmount
        if verticesChanged = false
            
            vertices:Set(X1, vertices:Get(X1) + xAmount)
            vertices:Set(Y1, vertices:Get(Y1) + yAmount)

            vertices:Set(X2, vertices:Get(X2) + xAmount)
            vertices:Set(Y2, vertices:Get(Y2) + yAmount)

            vertices:Set(X3, vertices:Get(X3) + xAmount)
            vertices:Set(Y3, vertices:Get(Y3) + yAmount)

            vertices:Set(X4, vertices:Get(X4) + xAmount)
            vertices:Set(Y4, vertices:Get(Y4) + yAmount)
        end
        SetOffset(offsetX, offsetY)
    end

    action SetOrigin(number setX, number setY)
        originX = setX
        originY = setY
        verticesChanged = true
    end

    action SetOriginCenter
        originX = width / 2.0
        originY = height / 2.0
        verticesChanged = true
    end

    action SetRotation(number degrees)
        rotation = degrees
        verticesChanged = true

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetRotation(degrees)
        end
    end

    action GetRotation returns number
        return rotation
    end

    action Rotate(number degrees)
        rotation = rotation + degrees
        if degrees not= 0
            verticesChanged = true
        end

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():Rotate(degrees)
        end
    end

    action PrepareVertices

        if verticesChanged
            verticesChanged = false

            number localX = 0 - originX
            number localY = 0 - originY
            number localX2 = localX + width
            number localY2 = localY + height
            number worldOriginX = x - localX + offsetX
            number worldOriginY = y - localY + offsetY

            if (scaleX not= 1 or scaleY not= 1)
                localX = localX * scaleX
                localY = localY * scaleY
                localX2 = localX2 * scaleX
                localY2 = localY2 * scaleY
            end

            if rotation not= 0
                Math math
                number radians = math:DegreesToRadians(-1 * rotation)
                number cos = math:Cosine(radians)
                number sin = math:Sine(radians)
                number localXCos = localX * cos
                number localXSin = localX * sin
                number localYCos = localY * cos
                number localYSin = localY * sin
                number localX2Cos = localX2 * cos
                number localX2Sin = localX2 * sin
                number localY2Cos = localY2 * cos
                number localY2Sin = localY2 * sin
                
                number x1 = localXCos - localYSin + worldOriginX
                number y1 = localYCos + localXSin + worldOriginY
                
                vertices:Set(X1, x1)
                vertices:Set(Y1, y1)

                number x2 = localXCos - localY2Sin + worldOriginX
                number y2 = localY2Cos + localXSin + worldOriginY

                vertices:Set(X2, x2)
                vertices:Set(Y2, y2)

                number x3 = localX2Cos - localY2Sin + worldOriginX
                number y3 = localY2Cos + localX2Sin + worldOriginY

                vertices:Set(X3, x3)
                vertices:Set(Y3, y3)

                vertices:Set(X4, x1 + x3 - x2)
                vertices:Set(Y4, y3 - (y2 - y1))
            else
                number x1 = localX + worldOriginX
                number y1 = localY + worldOriginY
                number x2 = localX2 + worldOriginX
                number y2 = localY2 + worldOriginY

                vertices:Set(X1, x1)
                vertices:Set(Y1, y1)

                vertices:Set(X2, x1)
                vertices:Set(Y2, y2)

                vertices:Set(X3, x2)
                vertices:Set(Y3, y2)

                vertices:Set(X4, x2)
                vertices:Set(Y4, y1)
            end
        end
 
    end

    // Convenience function to make it easier to get items from Java plugins.
    action GetVertex(integer index) returns number
        return vertices:Get(index)
    end

    action SetVertex(integer index, number value)
        vertices:Set(index, value)
    end

    action GetVertices returns Array<number>
        return vertices
    end

    action SetScale(number scale)
        scaleX = scale
        scaleY = scale
        verticesChanged = true

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetScale(scale)
        end
    end

    action SetScale(number newX, number newY)
        scaleX = newX
        scaleY = newY
        verticesChanged = true

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetScale(newX, newY)
        end
    end

    action SetScale(number newX, number newY, number newZ)
        // NOT YET IMPLEMENTED
    end

    action Scale(number amount)
        scaleX = scaleX + amount
        scaleY = scaleY + amount
        verticesChanged = true

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():Scale(amount)
        end
    end

    action GetOriginX returns number
        return originX
    end

    action GetOriginY returns number
        return originY
    end

    action GetScaleX returns number
        return scaleX
    end

    action GetScaleY returns number
        return scaleY
    end

    action GetBoundingRectangle returns Rectangle
        
        number minX = vertices:Get(X1)
        number minY = vertices:Get(Y1)
        number maxX = vertices:Get(X1)
        number maxY = vertices:Get(Y1)

        if minX > vertices:Get(X2)
            minX  = vertices:Get(X2)
        end
        if minX > vertices:Get(X3)
            minX  = vertices:Get(X3)
        end
        if minX > vertices:Get(X4)
            minX  = vertices:Get(X4)
        end

        if maxX < vertices:Get(X2)
            maxX  = vertices:Get(X2)
        end
        if maxX < vertices:Get(X3)
            maxX  = vertices:Get(X3)
        end
        if maxX < vertices:Get(X4)
            maxX  = vertices:Get(X4)
        end

        if minY > vertices:Get(Y2)
            minY  = vertices:Get(Y2)
        end
        if minY > vertices:Get(Y3)
            minY  = vertices:Get(Y3)
        end
        if minY > vertices:Get(Y4)
            minY  = vertices:Get(Y4)
        end

        if maxY < vertices:Get(Y2)
            maxY  = vertices:Get(Y2)
        end
        if maxY < vertices:Get(Y3)
            maxY  = vertices:Get(Y3)
        end
        if maxY < vertices:Get(Y4)
            maxY  = vertices:Get(Y4)
        end

        if bounds = undefined
            Rectangle newRectangle
            bounds = newRectangle
        end
        
        bounds:SetX(minX)
        bounds:SetY(minY)
        bounds:SetWidth(maxX - minX)
        bounds:SetHeight(maxY - minY)
        return bounds
    end

    action Draw(Painter painter)
        PrepareVertices()
    
        if not IsShowing()
            return now
        end

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():Draw(painter)
        end
    end

    action SetFlipX(boolean flip)
        if IsFlippedX() not= flip
            FlipX()
        end
    end

    action SetFlipY(boolean flip)
        if IsFlippedY() not= flip
            FlipY()
        end
    end

    action FlipX
        flipX = not flipX

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():FlipX()
        end
    end

    action FlipY
        flipY = not flipY

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():FlipY()
        end
    end

    action FlipZ
        flipZ = not flipZ

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():FlipZ()
        end
    end

    action IsFlippedX returns boolean
        return flipX
    end

    action IsFlippedY returns boolean
        return flipY
    end

    action IsFlippedZ returns boolean
        return flipZ
    end

end