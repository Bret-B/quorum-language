package Libraries.Interface

use Libraries.Containers.List
use Libraries.Containers.Array
use Libraries.Containers.Blueprints.Iterator
use Libraries.Interface.Events.MouseListener
use Libraries.Interface.Events.MouseMovementListener
use Libraries.Interface.Events.MouseWheelListener
use Libraries.Interface.Events.MouseEvent
use Libraries.Interface.Events.KeyboardListener
use Libraries.Interface.Events.KeyboardEvent
use Libraries.Interface.Events.TouchListener
use Libraries.Interface.Events.TouchEvent
use Libraries.Game.Graphics.Drawable
use Libraries.Game.Graphics.Painter
use Libraries.Game.Shapes.Rectangle
use Libraries.Compute.Math

class Item 

    private number x = 0
    private number y = 0
    private number z = 0
    public number width = 0
    public number height = 0
    public number depth = 0
    private text name = "Unnamed"
    private boolean visible = true
    private boolean enabled = true

    private Item parentItem = undefined

    private Array<Item> children

    List<MouseListener> mouseListeners
    List<MouseMovementListener> mouseMoveListeners
    List<MouseWheelListener> mouseWheelListeners
    List<KeyboardListener> keyboardListeners
    List<TouchListener> touchListeners
    
    private number originX = 0.0
    private number originY = 0.0
    private number rotation = 0.0
    private number scaleX = 1
    private number scaleY = 1
    private number offsetX = 0
    private number offsetY = 0
    private boolean flipX = false
    private boolean flipY = false
    private boolean flipZ = false

    private boolean verticesChanged = true
    private Rectangle bounds

    constant integer VERTEX_SIZE = 5
    constant integer DRAWABLE_SIZE = 4 * VERTEX_SIZE

    Array<number> vertices

    on create
        vertices:SetSize(20)
    end

    // These constants represent certain aspects of each vertex. For example,
    // X1 and Y2 represent the x value of the first vertex and the y value of
    // the second vertex, respectively.
    constant integer X1 = 0
    constant integer Y1 = 1
    constant integer C1 = 2
    constant integer U1 = 3
    constant integer V1 = 4
    constant integer X2 = 5
    constant integer Y2 = 6
    constant integer C2 = 7
    constant integer U2 = 8
    constant integer V2 = 9
    constant integer X3 = 10
    constant integer Y3 = 11
    constant integer C3 = 12
    constant integer U3 = 13
    constant integer V3 = 14
    constant integer X4 = 15
    constant integer Y4 = 16
    constant integer C4 = 17
    constant integer U4 = 18
    constant integer V4 = 19

    

    action SetX(number setX)
        TranslateX(setX - x)
    end

    action SetY(number setY)
        TranslateY(setY - y)
    end

    action SetZ(number newZ)
        z = newZ
    end

    action GetX returns number
        return x
    end

    action GetY returns number
        return y
    end

    action GetZ returns number
        return z
    end

    action SetPosition(number setX, number setY)
        Translate(setX - GetX(), setY - GetY())
    end

    action SetPosition(number newX, number newY, number newZ)
        SetPosition(newX, newY)
        z = newZ
    end

    action SetWidth(number newWidth)
        width = newWidth
    end

    action SetHeight(number newHeight)
        height = newHeight
    end

    action SetDepth(number newDepth)
        depth = newDepth
    end

    action SetCenterX(number setX)
        SetX(setX - width / 2.0)
    end

    action SetCenterY(number setY)
        SetY(setY - height / 2.0)
    end

    action SetCenter(number setX, number setY)
        SetCenterX(setX)
        SetCenterY(setY)
    end
    
    action GetWidth returns number
        return width
    end

    action GetHeight returns number
        return height
    end

    action GetDepth returns number
        return depth
    end

    action SetOffsetX(number xAmount)
        if xAmount not= offsetX and verticesChanged = false
            number adjust = xAmount - offsetX

            vertices:Set(X1, vertices:Get(X1) + adjust)
            vertices:Set(X2, vertices:Get(X2) + adjust)
            vertices:Set(X3, vertices:Get(X3) + adjust)
            vertices:Set(X4, vertices:Get(X4) + adjust)

            offsetX = xAmount
        end

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetOffsetX(x + xAmount)
        end
    end

    action SetOffsetY(number yAmount)
        if yAmount not= offsetY and verticesChanged = false
            number adjust = yAmount - offsetY
        
            vertices:Set(Y1, vertices:Get(Y1) + adjust)
            vertices:Set(Y2, vertices:Get(Y2) + adjust)
            vertices:Set(Y3, vertices:Get(Y3) + adjust)
            vertices:Set(Y4, vertices:Get(Y4) + adjust)
        
            offsetY = yAmount
        end

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetOffsetY(y + yAmount)
        end
    end

    action SetOffset(number xAmount, number yAmount)
        if (xAmount not= offsetX or yAmount not= offsetY) and verticesChanged = false
            Array<number> vertices = GetVertices()
            number adjustX = xAmount - offsetX
            number adjustY = yAmount - offsetY
            
            vertices:Set(X1, vertices:Get(X1) + adjustX)
            vertices:Set(Y1, vertices:Get(Y1) + adjustY)

            vertices:Set(X2, vertices:Get(X2) + adjustX)
            vertices:Set(Y2, vertices:Get(Y2) + adjustY)

            vertices:Set(X3, vertices:Get(X3) + adjustX)
            vertices:Set(Y3, vertices:Get(Y3) + adjustY)

            vertices:Set(X4, vertices:Get(X4) + adjustX)
            vertices:Set(Y4, vertices:Get(Y4) + adjustY)
        
            offsetX = xAmount
            offsetY = yAmount
        end
        

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetOffset(x + xAmount, y + yAmount)
        end
    end

    action AddMouseListener(MouseListener listener)
        mouseListeners:Add(listener)
    end

    action RemoveMouseListener(MouseListener listener)
        mouseListeners:Remove(listener)
    end

    action AddMouseMovementListener(MouseMovementListener listener)
        mouseMoveListeners:Add(listener)
    end

    action RemoveMouseMovementListener(MouseMovementListener listener)
        mouseMoveListeners:Remove(listener)
    end

    action AddMouseWheelListener(MouseWheelListener listener)
        mouseWheelListeners:Add(listener)
    end

    action RemoveMouseWheelListener(MouseWheelListener listener)
        mouseWheelListeners:Remove(listener)
    end

    action AddKeyboardListener(KeyboardListener listener)
        keyboardListeners:Add(listener)
    end

    action RemoveKeyboardListener(KeyboardListener listener)
        keyboardListeners:Remove(listener)
    end

    action AddTouchListener(TouchListener listener)
        touchListeners:Add(listener)
    end

    action RemoveTouchListener(TouchListener listener)
        touchListeners:Remove(listener)
    end

    action ProcessMouseEvent(MouseEvent event)
        
        Item temp = GetItemAt(event:GetX(), event:GetY())
        if temp not= undefined and temp not= me
            temp:ProcessMouseEvent(event)
        
            if event:WasEventHandled()
                return now
            end
        end

        if event:eventType = event:MOVED_MOUSE
            Iterator<MouseMovementListener> iterator = mouseMoveListeners:GetIterator()
            repeat while iterator:HasNext()
                iterator:Next():MovedMouse(event)
            end

        elseif event:eventType = event:DRAGGED_MOUSE
            Iterator<MouseMovementListener> iterator = mouseMoveListeners:GetIterator()
            repeat while iterator:HasNext()
                iterator:Next():DraggedMouse(event)
            end

        elseif event:eventType = event:CLICKED_MOUSE
            Iterator<MouseListener> iterator = mouseListeners:GetIterator()
            repeat while iterator:HasNext()
                iterator:Next():ClickedMouse(event)
            end

        elseif event:eventType = event:RELEASED_MOUSE
            Iterator<MouseListener> iterator = mouseListeners:GetIterator()
            repeat while iterator:HasNext()
                iterator:Next():ReleasedMouse(event)
            end

        elseif event:eventType = event:SCROLLED_MOUSE
            Iterator<MouseWheelListener> iterator = mouseWheelListeners:GetIterator()
            repeat while iterator:HasNext()
                iterator:Next():ScrolledMouse(event)
            end
        end
    end

    action ProcessKeyboardEvent(KeyboardEvent event)
        
        Iterator<KeyboardListener> iterator = keyboardListeners:GetIterator()

        if event:eventType = event:PRESSED_KEY
            repeat while iterator:HasNext()
                iterator:Next():PressedKey(event)
            end

        elseif event:eventType = event:RELEASED_KEY
            repeat while iterator:HasNext()
                iterator:Next():ReleasedKey(event)
            end
        end

    end

    action ProcessTouchEvent(TouchEvent event)
        // NOT YET IMPLEMENTED
    end

    action Update(number secondsSinceUpdate)

    end

    action UpdateAll(number secondsSinceUpdate)
        Update(secondsSinceUpdate)

        Iterator<Item> itemIterator = GetItems()
        Item temp = undefined

        repeat while itemIterator:HasNext()
            itemIterator:Next():UpdateAll(secondsSinceUpdate)
        end
    end

    action BeginCollision(Item item)
        
    end

    action FinishCollision(Item item)

    end

    action Show
        visible = true
    end

    action Hide
        visible = false
    end

    action IsShowing returns boolean
        return visible
    end

    action Enable
        enabled = true
    end

    action Disable
        enabled = false
    end

    action IsEnabled returns boolean
        return enabled
    end

    action SetName(text newName)
        name = newName
    end

    action GetName returns text
        return name
    end

    action SetParent(Item newItem)
        parentItem = newItem
    end

    action GetParent returns Item
        return parentItem
    end

    action Add(Item newItem)
        children:Add(newItem)
        newItem:SetParent(me)
        newItem:PrepareVertices()
        newItem:SetOffset(x + offsetX, y + offsetY)
    end

    action Add(Item newItem, integer index)
        children:Add(index, newItem)
        newItem:SetParent(me)
        newItem:PrepareVertices()
        newItem:SetOffset(x + offsetX, y + offsetY)
    end

    action Remove(Item removed) returns boolean
        boolean success = children:Remove(removed)
        return success
    end

    action Remove(integer index) returns Item
        Item temp = children:RemoveAt(index)
        return temp
    end

    action GetItem(integer index) returns Item
        return children:Get(index)
    end

    action GetItems returns Iterator<Item>
        return children:GetIterator()
    end

    action GetItemCount returns integer
        return children:GetSize()
    end

    action IsEmpty returns boolean
        return children:IsEmpty()
    end

    // NOTE: This simple implementation of Contains uses the UNROTATED Item box!
    action Contains(number testX, number testY) returns boolean
        return testX >= x and testX <= x + width and testY >= y and testY <= y + height
    end

    action Contains(number x, number y, number z) returns boolean
        // TO BE IMPLEMENTED
        return false
    end

    action GetItemAt(number x, number y) returns Item
        integer counter = children:GetSize()
        Item temp = undefined
        boolean found = false
        repeat while counter > 0 and not found
            counter = counter - 1
            temp = children:Get(counter)
            temp = temp:GetItemAt(x, y)
            if temp not= undefined
                found = true
            end
        end

        if not found and Contains(x, y)
            return me
        else
            return temp
        end
    end

    action GetItemAt(number x, number y, number z) returns Item
        integer counter = children:GetSize()
        Item temp = undefined
        boolean found = false
        repeat while counter > 0 and not found
            counter = counter - 1
            temp = children:Get(counter)
            temp = temp:GetItemAt(x, y, z)
            if temp not= undefined
                found = true
            end
        end

        if not found and Contains(x, y, z)
            return me
        else
            return temp
        end
    end

    action Dispose
        
    end

    action DisposeChildren
        Iterator<Item> childIterator = GetItems()
        Item temp = undefined
        repeat while childIterator:HasNext()
            temp = childIterator:Next()
            temp:DisposeAll()
        end
    end

    action DisposeAll
        DisposeChildren()
        Dispose()
    end

    action Empty
        children:Empty()
    end

    action SetBoundingBox(number newX, number newY, number newWidth, number newHeight)
        SetX(newX)
        SetY(newY)
        width = newWidth
        height = newHeight

        number parentX = GetX()
        number parentY = GetY()

        number x2 = parentX + width
        number y2 = parentY + height

        vertices:Set(X1, parentX)
        vertices:Set(Y1, parentY)
        
        vertices:Set(X2, parentX)
        vertices:Set(Y2, y2)
        
        vertices:Set(X3, x2)
        vertices:Set(Y3, y2)
       
        vertices:Set(X4, x2)
        vertices:Set(Y4, parentY)

        if rotation not= 0 or scaleX not= 1 or scaleY not= 1
            verticesChanged = true
        end

    end

    action SetBoundingBox(number newX, number newY, number newZ, number newWidth, number newHeight, number newDepth)
        // NOT YET IMPLEMENTED
    end

    action SetSize(integer newWidth, integer newHeight)
        width = newWidth
        height = newHeight

        if verticesChanged = false
            number parentX = GetX()
            number parentY = GetY()
            number x2 = parentX + width
            number y2 = parentY + height

            vertices:Set(X1, parentX)
            vertices:Set(Y1, parentY)

            vertices:Set(X2, parentX)
            vertices:Set(Y2, y2)

            vertices:Set(X3, x2)
            vertices:Set(Y3, y2)

            vertices:Set(X4, x2)
            vertices:Set(Y4, parentY)

            if rotation not= 0 or scaleX not= 1 or scaleY not= 1
                verticesChanged = true
            end
        end

    end

    action TranslateX(number xAmount)
        x = x + xAmount
        if verticesChanged = false
            vertices:Set(X1, vertices:Get(X1) + xAmount)
            vertices:Set(X2, vertices:Get(X2) + xAmount)
            vertices:Set(X3, vertices:Get(X3) + xAmount)
            vertices:Set(X4, vertices:Get(X4) + xAmount)
        end
        SetOffsetX(offsetX)
    end

    action TranslateY(number yAmount)
        y = y + yAmount
        if verticesChanged = false
            vertices:Set(Y1, vertices:Get(Y1) + yAmount)
            vertices:Set(Y2, vertices:Get(Y2) + yAmount)
            vertices:Set(Y3, vertices:Get(Y3) + yAmount)
            vertices:Set(Y4, vertices:Get(Y4) + yAmount)
        end
        SetOffsetY(offsetY)
    end

    action Translate(number xAmount, number yAmount)
        x = x + xAmount
        y = y + yAmount
        if verticesChanged = false
            
            vertices:Set(X1, vertices:Get(X1) + xAmount)
            vertices:Set(Y1, vertices:Get(Y1) + yAmount)

            vertices:Set(X2, vertices:Get(X2) + xAmount)
            vertices:Set(Y2, vertices:Get(Y2) + yAmount)

            vertices:Set(X3, vertices:Get(X3) + xAmount)
            vertices:Set(Y3, vertices:Get(Y3) + yAmount)

            vertices:Set(X4, vertices:Get(X4) + xAmount)
            vertices:Set(Y4, vertices:Get(Y4) + yAmount)
        end
        SetOffset(offsetX, offsetY)
    end

    action SetOrigin(number setX, number setY)
        originX = setX
        originY = setY
        verticesChanged = true
    end

    action SetOriginCenter
        originX = width / 2.0
        originY = height / 2.0
        verticesChanged = true
    end

    action SetRotation(number degrees)
        rotation = degrees
        verticesChanged = true

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetRotation(degrees)
        end
    end

    action GetRotation returns number
        return rotation
    end

    action Rotate(number degrees)
        rotation = rotation + degrees
        if degrees not= 0
            verticesChanged = true
        end

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():Rotate(degrees)
        end
    end

    action PrepareVertices

        if verticesChanged
            verticesChanged = false

            number localX = 0 - originX
            number localY = 0 - originY
            number localX2 = localX + width
            number localY2 = localY + height
            number worldOriginX = x - localX + offsetX
            number worldOriginY = y - localY + offsetY

            if (scaleX not= 1 or scaleY not= 1)
                localX = localX * scaleX
                localY = localY * scaleY
                localX2 = localX2 * scaleX
                localY2 = localY2 * scaleY
            end

            if rotation not= 0
                Math math
                number radians = math:DegreesToRadians(-1 * rotation)
                number cos = math:Cosine(radians)
                number sin = math:Sine(radians)
                number localXCos = localX * cos
                number localXSin = localX * sin
                number localYCos = localY * cos
                number localYSin = localY * sin
                number localX2Cos = localX2 * cos
                number localX2Sin = localX2 * sin
                number localY2Cos = localY2 * cos
                number localY2Sin = localY2 * sin
                
                number x1 = localXCos - localYSin + worldOriginX
                number y1 = localYCos + localXSin + worldOriginY
                
                vertices:Set(X1, x1)
                vertices:Set(Y1, y1)

                number x2 = localXCos - localY2Sin + worldOriginX
                number y2 = localY2Cos + localXSin + worldOriginY

                vertices:Set(X2, x2)
                vertices:Set(Y2, y2)

                number x3 = localX2Cos - localY2Sin + worldOriginX
                number y3 = localY2Cos + localX2Sin + worldOriginY

                vertices:Set(X3, x3)
                vertices:Set(Y3, y3)

                vertices:Set(X4, x1 + x3 - x2)
                vertices:Set(Y4, y3 - (y2 - y1))
            else
                number x1 = localX + worldOriginX
                number y1 = localY + worldOriginY
                number x2 = localX2 + worldOriginX
                number y2 = localY2 + worldOriginY

                vertices:Set(X1, x1)
                vertices:Set(Y1, y1)

                vertices:Set(X2, x1)
                vertices:Set(Y2, y2)

                vertices:Set(X3, x2)
                vertices:Set(Y3, y2)

                vertices:Set(X4, x2)
                vertices:Set(Y4, y1)
            end
        end
 
    end

    // Convenience function to make it easier to get items from Java plugins.
    action GetVertex(integer index) returns number
        return vertices:Get(index)
    end

    action SetVertex(integer index, number value)
        vertices:Set(index, value)
    end

    action GetVertices returns Array<number>
        return vertices
    end

    action SetScale(number scale)
        scaleX = scale
        scaleY = scale
        verticesChanged = true

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetScale(scale)
        end
    end

    action SetScale(number newX, number newY)
        scaleX = newX
        scaleY = newY
        verticesChanged = true

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():SetScale(newX, newY)
        end
    end

    action SetScale(number newX, number newY, number newZ)
        // NOT YET IMPLEMENTED
    end

    action Scale(number amount)
        scaleX = scaleX + amount
        scaleY = scaleY + amount
        verticesChanged = true

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():Scale(amount)
        end
    end

    action GetOriginX returns number
        return originX
    end

    action GetOriginY returns number
        return originY
    end

    action GetScaleX returns number
        return scaleX
    end

    action GetScaleY returns number
        return scaleY
    end

    action GetBoundingRectangle returns Rectangle
        
        number minX = vertices:Get(X1)
        number minY = vertices:Get(Y1)
        number maxX = vertices:Get(X1)
        number maxY = vertices:Get(Y1)

        if minX > vertices:Get(X2)
            minX  = vertices:Get(X2)
        end
        if minX > vertices:Get(X3)
            minX  = vertices:Get(X3)
        end
        if minX > vertices:Get(X4)
            minX  = vertices:Get(X4)
        end

        if maxX < vertices:Get(X2)
            maxX  = vertices:Get(X2)
        end
        if maxX < vertices:Get(X3)
            maxX  = vertices:Get(X3)
        end
        if maxX < vertices:Get(X4)
            maxX  = vertices:Get(X4)
        end

        if minY > vertices:Get(Y2)
            minY  = vertices:Get(Y2)
        end
        if minY > vertices:Get(Y3)
            minY  = vertices:Get(Y3)
        end
        if minY > vertices:Get(Y4)
            minY  = vertices:Get(Y4)
        end

        if maxY < vertices:Get(Y2)
            maxY  = vertices:Get(Y2)
        end
        if maxY < vertices:Get(Y3)
            maxY  = vertices:Get(Y3)
        end
        if maxY < vertices:Get(Y4)
            maxY  = vertices:Get(Y4)
        end

        if bounds = undefined
            Rectangle newRectangle
            bounds = newRectangle
        end
        
        bounds:SetX(minX)
        bounds:SetY(minY)
        bounds:SetWidth(maxX - minX)
        bounds:SetHeight(maxY - minY)
        return bounds
    end

    action Draw(Painter painter)
        PrepareVertices()
    
        if not IsShowing()
            return now
        end

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():Draw(painter)
        end
    end

    action SetFlipX(boolean flip)
        if IsFlippedX() not= flip
            FlipX()
        end
    end

    action SetFlipY(boolean flip)
        if IsFlippedY() not= flip
            FlipY()
        end
    end

    action FlipX
        flipX = not flipX

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():FlipX()
        end
    end

    action FlipY
        flipY = not flipY

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():FlipY()
        end
    end

    action FlipZ
        flipZ = not flipZ

        Iterator<Item> childIterator = GetItems()
        repeat while childIterator:HasNext()
            childIterator:Next():FlipZ()
        end
    end

    action IsFlippedX returns boolean
        return flipX
    end

    action IsFlippedY returns boolean
        return flipY
    end

    action IsFlippedZ returns boolean
        return flipZ
    end

end