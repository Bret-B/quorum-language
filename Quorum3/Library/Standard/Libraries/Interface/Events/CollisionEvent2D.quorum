use Libraries.Interface.Item2D
use Libraries.Compute.Math
use Libraries.Compute.Vector2
use Libraries.Containers.Array
use Libraries.Game.Collision.ContactEdge2D
use Libraries.Game.Collision.ContactManifold2D
use Libraries.Game.Collision.Transform2D
use Libraries.Game.Collision.Shapes.CollisionShape2D
use Libraries.Game.Collision.Shapes.Circle
use Libraries.Game.Collision.Shapes.Polygon
use Libraries.Game.Collision.ManifoldPoint2D

package Libraries.Interface.Events

class CollisionEvent2D
    public constant number EPSILON = 0.00000011920928955078125

    Item2D itemA = undefined
    Item2D itemB = undefined

    integer indexA = -1
    integer indexB = -1

    boolean touchingFlag = true
    boolean enabledFlag = false

//    // physics fields for later
//    number friction = 0
//    number restitution = 1
//    number tangentSpeed = 0

    Math math

    private CollisionEvent2D next = undefined
    private CollisionEvent2D previous = undefined

    public ContactEdge2D nodeA = undefined
    public ContactEdge2D nodeB = undefined

    ContactManifold2D manifold

    private number separation1 = 0
    private integer edgeIndex1 = 0
    private number separation2 = 0
    private integer edgeIndex2 = 0

    action Initialize(Item2D itemA, integer indexA, Item2D itemB, integer indexB)
        enabledFlag = true
        
        me:itemA = itemA
        me:indexA = indexA
        
        me:itemB = itemB
        me:indexB = indexB

        manifold:pointCount = 0

        previous = undefined
        next = undefined

        ContactEdge2D node1
        nodeA = node1

        ContactEdge2D node2
        nodeB = node2

        nodeA:collision = undefined
        nodeA:previous = undefined
        nodeA:next = undefined
        nodeA:other = undefined

        nodeB:collision = undefined
        nodeB:previous = undefined
        nodeB:next = undefined
        nodeA:other = undefined

//        friction = CalculateFriction(itemA:GetFriction(), itemB:GetFriction())
//        restitution = CalculateRestitution(itemA:GetRestitution(), itemB:GetRestitution())
        
    end

    action GetPrevious returns CollisionEvent2D
        return previous
    end

    action SetPrevious(CollisionEvent2D event)
        previous = event
    end

    action GetNext returns CollisionEvent2D
        return next
    end

    action SetNext(CollisionEvent2D event)
        next = event
    end

    action IsTouching returns boolean
        return touchingFlag
    end

    action SetEnabled(boolean enabled)
        enabledFlag = enabled
    end

    action IsEnabled returns boolean
        return enabledFlag
    end

    action GetItemA returns Item2D
        return itemA
    end

    action GetChildIndexA returns integer
        return indexA
    end

    action GetItemB returns Item2D
        return itemB
    end
    
    action GetChildIndexB returns integer
        return indexB
    end

//    action SetFriction(number friction)
//        me:friction = friction
//    end
//
//    action GetFriction returns number
//        return friction
//    end
//
//    action ResetFriction
////        friction = CalculateTotalFriction(itemA:GetFriction(), itemB:GetFriction())
//    end
//
//    action SetRestitution(number restitution)
//        me:restitution = restitution
//    end
//
//    action GetRestitution returns number
//        return restitution
//    end
//
//    action ResetRestitution
////        restitution = CalculateTotalRestitution(itemA:GetRestitution(), itemB:GetRestitution())
//    end
//
//    action SetTangentSpeed(number speed)
//        me:tangentSpeed = speed
//    end
//
//    action GetTangentSpeed returns number
//        return tangentSpeed
//    end

    ContactManifold2D oldManifold

    action DispatchCollision(Array<CollisionListener2D> listeners)
        oldManifold:Set(manifold)

        enabledFlag = true

        boolean touching = false
        boolean wasTouching = touchingFlag

        Transform2D transformA = itemA:GetTransform()
        Transform2D transformB = itemB:GetTransform()

        NarrowphaseEvaluation(manifold, transformA, transformB)
        touching = manifold:pointCount > 0

        touchingFlag = touching

        integer i = 0
        repeat while i < listeners:GetSize()
            CollisionListener2D listener = listeners:Get(i)
            if not wasTouching and touching
                listener:BeginCollision(me)
            end

            if wasTouching and not touching
                listener:FinishCollision(me)
            end

            i = i + 1
        end
    end

    action GetNodeA returns ContactEdge2D
        return nodeA
    end

    action GetNodeB returns ContactEdge2D
        return nodeB
    end

//    action CalculateTotalFriction(number friction1, number friction2) returns number
//        return math:SquareRoot(friction1 * friction2)
//    end
//
//    action CalculateTotalRestitution(number restitution1, number restitution2) returns number
//        if restitution1 > restitution2
//            return restitution1
//        else
//            return restitution2
//        end
//    end

    private action NarrowphaseEvaluation(ContactManifold2D manifold, Transform2D transformA, Transform2D transformB)
        CollisionShape2D shapeA = itemA:GetShape()
        CollisionShape2D shapeB = itemB:GetShape()

        // call appropriate collision action based on shapes of items
        if shapeA is Polygon and shapeB is Polygon
            CollidePolygons(manifold, cast(Polygon, shapeA), transformA, cast(Polygon, shapeB), transformB)
        elseif shapeA is Circle and shapeB is Circle
            CollideCircles(manifold, cast(Circle, shapeA), transformA, cast(Circle, shapeB), transformB)
        elseif shapeA is Polygon and shapeB is Circle
            CollidePolygonAndCircle(manifold, cast(Polygon, shapeA), transformA, cast(Circle, shapeB), transformB)
        elseif shapeB is Polygon and shapeA is Circle
            CollidePolygonAndCircle(manifold, cast(Polygon, shapeB), transformB, cast(Circle, shapeA), transformA)
        end
    end

    private action CollidePolygons(ContactManifold2D manifold, Polygon polygonA, Transform2D transformA, Polygon polygonB, Transform2D transformB)
        manifold:pointCount = 0

        number totalRadius = polygonA:GetRadius() + polygonB:GetRadius()

        FindMaxSeparation(polygonA, transformA, polygonB, transformB, true)
        if separation1 > totalRadius
            return now
        end

        FindMaxSeparation(polygonB, transformB, polygonA, transformA, false)
        if separation2 > totalRadius
            return now
        end

        Polygon poly1
        Polygon poly2
        Transform2D xf1
        Transform2D xf2
        integer edge1 = 0
        number k_tol = 0.1 * 0.005

        if separation2 > separation1 + k_tol
            poly1 = polygonB
            poly2 = polygonA
            xf1 = transformB
            xf2 = transformA
            edge1 = edgeIndex2
            manifold:type = manifold:FACE_B
        else
            poly1 = polygonA
            poly2 = polygonB
            xf1 = transformA
            xf2 = transformB
            edge1 = edgeIndex1
            manifold:type = manifold:FACE_A
        end
        number xf1qs = xf1:GetSine()
        number xf1qc = xf1:GetCosine()

        Array<Vector2> incidentEdge
        repeat 2 times
            Vector2 vector
            incidentEdge:Add(vector)
        end

        FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2)

        integer count1 = poly1:GetVertexCount()
        Array<Vector2> vertices1 = poly1:GetVertices()

        Vector2 localTangent
        Vector2 localNormal
        Vector2 planePoint
        Vector2 tangent
        Vector2 v11
        Vector2 v12

        integer iv1 = edge1
        integer iv2 = 0
        if edge1 + 1 < count1
            iv2 = edge1 + 1
        end

        v11:Set(vertices1:Get(iv1))
        v12:Set(vertices1:Get(iv2))
        localTangent:SetX(v12:GetX() - v11:GetX())
        localTangent:SetY(v12:GetY() - v11:GetY())
        localTangent:Normalize()

        localNormal:SetX(1 * localTangent:GetY())
        localNormal:SetY(-1 * localTangent:GetX())

        planePoint:SetX((v11:GetX() + v12:GetX()) * 0.5)
        planePoint:SetY((v11:GetY() + v12:GetY()) * 0.5)

        tangent:SetX(xf1qc * localTangent:GetX() - xf1qs * localTangent:GetY())
        tangent:SetY(xf1qs * localTangent:GetX() + xf1qc * localTangent:GetY())

        number normalx = 1.0 * tangent:GetY()
        number normaly = -1.0 *  tangent:GetX()

        xf1:MultiplyToOut(xf1, v11, v11)
        xf1:MultiplyToOut(xf1, v12, v12)

        number frontOffset = normalx * v11:GetX() + normaly * v11:GetY()

        number sideOffset1 = -1 * (tangent:GetX() * v11:GetX() + tangent:GetY() * v11:GetY()) + totalRadius
        number sideOffset2 = tangent:GetX() * v12:GetX() + tangent:GetY() * v12:GetY() + totalRadius

        integer np = 0
        
        Array<Vector2> clipPoints1
        Array<Vector2> clipPoints2
        repeat 2 times
            Vector2 v1
            Vector2 v2
            clipPoints1:Add(v1)
            clipPoints2:Add(v2)
        end

        tangent:Scale(-1)
        np = ClipSegmentToLine(clipPoints1, incidentEdge, tangent, sideOffset1, iv1)
        tangent:Scale(-1)

        if np < 2
            return now
        end

        np = ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2)

        if np < 2
            return now
        end

        manifold:localNormal:Set(localNormal)
        manifold:localPoint:Set(planePoint)

        integer pointCount = 0
        integer i = 0
        repeat while i < manifold:MAX_MANIFOLD_POINTS
            number separation = normalx * clipPoints2:Get(i):GetX() + normaly * clipPoints2:Get(i):GetY() - frontOffset

            if separation <= totalRadius
                ManifoldPoint2D cp = manifold:points:Get(pointCount)
                Vector2 out = cp:localPoint
                number px = clipPoints2:Get(i):GetX() - xf2:GetPosition():GetX()
                number py = clipPoints2:Get(i):GetY() - xf2:GetPosition():GetY()
                out:SetX((xf2:GetCosine() * px + xf2:GetSine() * py))
                out:SetY((-1 * xf2:GetSine() * px + xf2:GetCosine() * py))

                pointCount = pointCount + 1
            end

            i = i + 1
        end

        manifold:pointCount = pointCount

    end

    private action CollideCircles(ContactManifold2D manifold, Circle circleA, Transform2D transformA, Circle circleB, Transform2D transformB)
        manifold:pointCount = 0

        Vector2 circle1p = circleA:GetSupportVertex()
        Vector2 circle2p = circleB:GetSupportVertex()

        number pAx = (transformA:GetCosine() * circle1p:GetX() - transformA:GetSine() * circle1p:GetY()) + transformA:GetPosition():GetX()
        number pAy = (transformA:GetSine() * circle1p:GetX() + transformA:GetCosine() * circle1p:GetY()) + transformA:GetPosition():GetY()
        number pBx = (transformB:GetCosine() * circle2p:GetX() - transformB:GetSine() * circle2p:GetY()) + transformB:GetPosition():GetX()
        number pBy = (transformB:GetSine() * circle2p:GetX() + transformB:GetCosine() * circle2p:GetY()) + transformB:GetPosition():GetY()
        number dx = pBx - pAx
        number dy = pBy - pAy
        number distSquared = dx * dx + dy * dy

        number radius = circleA:GetRadius() + circleB:GetRadius()
        if distSquared > radius * radius
            return now
        end

        manifold:type = manifold:CIRCLES
        manifold:localPoint:Set(circle1p)
        manifold:localNormal:SetZero()
        manifold:pointCount = 1
        
        manifold:points:Get(0):localPoint:Set(circle2p)
    end

    private action CollidePolygonAndCircle(ContactManifold2D manifold, Polygon polygon, Transform2D transformA, Circle circle, Transform2D transformB)
        manifold:pointCount = 0
        
        Vector2 circle1p = circle:GetSupportVertex()
        number cx = (transformB:GetCosine() * circle1p:GetX() - transformB:GetSine() * circle1p:GetY()) + transformB:GetPosition():GetX()
        number cy = (transformB:GetSine() * circle1p:GetX() + transformB:GetCosine() * circle1p:GetY()) + transformB:GetPosition():GetY()
        number px = cx - transformA:GetPosition():GetX()
        number py = cy - transformA:GetPosition():GetY()
        number cLocalx = (transformA:GetCosine() * px + transformA:GetSine() * py)
        number cLocaly = (-1 * transformA:GetSine() * px + transformA:GetCosine() * py)

        integer normalIndex = 0
        number separation = cx:GetMinimumValue()
        number radius = polygon:GetRadius() + circle:GetRadius()
        number vertexCount = polygon:GetVertexCount()
        number s = 0
        Array<Vector2> vertices = polygon:GetVertices()
        Array<Vector2> normals = polygon:GetNormals()

        integer i = 0
        repeat while i < vertexCount
            Vector2 vertex = vertices:Get(i)
            number tempx = cLocalx - vertex:GetX()
            number tempy = cLocaly - vertex:GetY()
            s = normals:Get(i):GetX() * tempx + normals:Get(i):GetY() * tempy

            if s > radius
                return now
            end

            if s > separation
                separation = s
                normalIndex = i
            end
            i = i + 1
        end

        integer vertIndex1 = normalIndex
        integer vertIndex2 = 0
        if vertIndex1 + 1 < vertexCount
            vertIndex2 = vertIndex1 + 1
        end
        Vector2 v1 = vertices:Get(vertIndex1)
        Vector2 v2 = vertices:Get(vertIndex2)

        if separation < EPSILON
            manifold:pointCount = 1
            manifold:type = manifold:FACE_A
            
            Vector2 normal = normals:Get(normalIndex)
            manifold:localNormal:SetX(normal:GetX())
            manifold:localNormal:SetY(normal:GetY())
            manifold:localPoint:SetX((v1:GetX() + v2:GetX()) * 0.5)
            manifold:localPoint:SetY((v1:GetY() + v2:GetY()) * 0.5)
            ManifoldPoint2D mpoint = manifold:points:Get(0)
            mpoint:localPoint:SetX(circle1p:GetX())
            mpoint:localPoint:SetY(circle1p:GetY())

            return now
        end

        number tempX = cLocalx - v1:GetX()
        number tempY = cLocaly - v1:GetY()
        number temp2X = v2:GetX() - v1:GetX()
        number temp2Y = v2:GetY() - v1:GetY()
        number u1 = tempX * temp2X + tempY * temp2Y

        number temp3X = cLocalx - v2:GetX()
        number temp3Y = cLocaly - v2:GetY()
        number temp4X = v1:GetX() - v2:GetX()
        number temp4Y = v1:GetY() - v2:GetY()
        number u2 = temp3X * temp4X + temp3Y * temp4Y

        if u1 <= 0
            number dx = cLocalx - v1:GetX()
            number dy = cLocaly - v1:GetY()

            if dx * dx + dy * dy > radius * radius
                return now
            end

            manifold:pointCount = 1
            manifold:type = manifold:FACE_A
            manifold:localNormal:SetX(cLocalx - v1:GetX())
            manifold:localNormal:SetY(cLocaly - v1:GetY())
            manifold:localNormal:Normalize()
            manifold:localPoint:Set(v1)
            manifold:points:Get(0):localPoint:Set(circle1p)
        elseif u2 <= 0
            number dx = cLocalx - v2:GetX()
            number dy = cLocaly - v2:GetY()
            
            if dx * dx + dy * dy > radius * radius
                return now
            end

            manifold:pointCount = 1
            manifold:type = manifold:FACE_A
            manifold:localNormal:SetX(cLocalx - v2:GetX())
            manifold:localNormal:SetY(cLocaly - v2:GetY())
            manifold:localNormal:Normalize()
            manifold:localPoint:Set(v2)
            manifold:points:Get(0):localPoint:Set(circle1p)
        else
            number fcx = (v1:GetX() + v2:GetX()) * 0.5
            number fcy = (v1:GetY() + v2:GetY()) * 0.5

            number tx = cLocalx - fcx
            number ty = cLocaly - fcy
            Vector2 normal = normals:Get(vertIndex1)
            separation = tx * normal:GetX() + ty * normal:GetY()

            if separation > radius
                return now
            end

            manifold:pointCount = 1
            manifold:type = manifold:FACE_A
            manifold:localNormal:Set(normals:Get(vertIndex1))
            manifold:localPoint:SetX(fcx)
            manifold:localPoint:SetY(fcy)
            manifold:points:Get(0):localPoint:Set(circle1p)
        end        
    end

    private action FindMaxSeparation(Polygon poly1, Transform2D xf1, Polygon poly2, Transform2D xf2, boolean one)
        integer count1 = poly1:GetVertexCount()
        integer count2 = poly2:GetVertexCount()
        Array<Vector2> n1s = poly1:GetNormals()
        Array<Vector2> v1s = poly1:GetVertices()
        Array<Vector2> v2s = poly2:GetVertices()

        Transform2D xf
        Transform2D A = xf2
        Transform2D B = xf1
        Vector2 pool
        xf:sine = A:GetCosine() * B:GetSine() - A:GetSine() * B:GetCosine()
        xf:cosine = A:GetCosine() * B:GetCosine() + A:GetSine() * B:GetSine()
        pool:Set(B:GetPosition()):Subtract(A:GetPosition())
        xf:GetPosition():SetX(A:GetCosine() * pool:GetX() + A:GetSine() * pool:GetY())
        xf:GetPosition():SetY(-1 * A:GetSine() * pool:GetX() + A:GetCosine() * pool:GetY())
        
        integer bestIndex = 0
        number maxSeparation = EPSILON:GetMinimumValue()

        Vector2 v1
        Vector2 n

        integer i = 0
        repeat while i < count1
            n:SetX(xf:GetCosine() * n1s:Get(i):GetX() - xf:GetSine() * n1s:Get(i):GetY())
            n:SetY(xf:GetSine() * n1s:Get(i):GetX() + xf:GetCosine() * n1s:Get(i):GetY())
            v1:SetX(xf:GetCosine() * v1s:Get(i):GetX() - xf:GetSine() * v1s:Get(i):GetY() + xf:GetPosition():GetX())
            v1:SetY(xf:GetSine() * v1s:Get(i):GetX() + xf:GetCosine() * v1s:Get(i):GetY() + xf:GetPosition():GetY())

            number si = EPSILON:GetMaximumValue()
            integer j = 0
            repeat while j < count2
                Vector2 v2sj = v2s:Get(j)
                number sij = n:GetX() * (v2sj:GetX() - v1:GetX()) + n:GetY() * (v2sj:GetY() - v1:GetY())
                if sij < si
                    si = sij
                end

                 j = j + 1
            end

            if si > maxSeparation
                maxSeparation = si
                bestIndex = i
            end

            i = i + 1
        end

        if one
            edgeIndex1 = bestIndex
            separation1 = maxSeparation
        else
            edgeIndex2 = bestIndex
            separation2 = maxSeparation
        end
    end

    private action FindIncidentEdge(Array<Vector2> c, Polygon poly1, Transform2D xf1, integer edge1, Polygon poly2, Transform2D xf2)
        integer count1 = poly1:GetVertexCount()
        Array<Vector2> normals1 = poly1:GetNormals()

        integer count2 = poly2:GetVertexCount()
        Array<Vector2> vertices2 = poly2:GetVertices()
        Array<Vector2> normals2 = poly2:GetNormals()

        Vector2 c0 = c:Get(0)
        Vector2 c1 = c:Get(1)

        Vector2 v = normals1:Get(edge1)
        number tempx = xf1:GetCosine() * v:GetX() - xf1:GetSine() * v:GetY()
        number tempy = xf1:GetSine() * v:GetX() + xf1:GetCosine() * v:GetY()
        number normals1x = xf2:GetCosine() * tempx + xf2:GetSine() * tempy
        number normals1y = -1 * xf2:GetSine() * tempx + xf2:GetCosine() * tempy

        integer index = 0
        number minDot = EPSILON:GetMaximumValue()
        integer i = 0
        repeat while i < count2
            Vector2 b = normals2:Get(i)
            number dot = normals1x * b:GetX() + normals1y * b:GetY()
            if dot < minDot
                minDot = dot
                index = i
            end

            i = i + 1
        end

        integer i1 = index
        integer i2 = 0
        if i1 + 1 < count2
            i2 = i1 + 1
        end

        Vector2 v1 = vertices2:Get(i1)
        Vector2 out = c0
        out:SetX((xf2:GetCosine() * v1:GetX() - xf2:GetSine() * v1:GetY()) + xf2:GetPosition():GetX())
        out:SetY((xf2:GetSine() * v1:GetX() + xf2:GetCosine() * v1:GetY()) + xf2:GetPosition():GetY())

        Vector2 v2 = vertices2:Get(i2)
        Vector2 out1 = c1
        out1:SetX((xf2:GetCosine() * v2:GetX() - xf2:GetSine() * v2:GetY()) + xf2:GetPosition():GetX())
        out1:SetY((xf2:GetSine() * v2:GetX() + xf2:GetCosine() * v2:GetY()) + xf2:GetPosition():GetY())        
    end

    action ClipSegmentToLine(Array<Vector2> vOut, Array<Vector2> vIn, Vector2 normal, number offset, integer vertexIndexA) returns integer
        integer numOut = 0
        Vector2 vIn0 = vIn:Get(0)
        Vector2 vIn1 = vIn:Get(1)
        
        number distance0 = normal:DotProduct(vIn0) - offset
        number distance1 = normal:DotProduct(vIn1) - offset

        if distance0 <= 0
            vOut:Get(numOut):Set(vIn0)
            numOut = numOut + 1
        end

        if distance1 <= 0
            vOut:Get(numOut):Set(vIn1)
            numOut = numOut + 1
        end

        if distance0 * distance1 < 0
            number interp = distance0 / (distance0 - distance1)

            Vector2 vOutNO = vOut:Get(numOut)
            vOutNO:SetX(vIn0:GetX() + interp * (vIn1:GetX() - vIn0:GetX()))
            vOutNO:SetY(vIn0:GetY() + interp * (vIn1:GetY() - vIn0:GetY()))

            numOut = numOut + 1
        end

        return numOut
    end
end