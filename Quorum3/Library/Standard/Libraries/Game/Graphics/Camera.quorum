package Libraries.Game.Graphics

use Libraries.Compute.Frustum
use Libraries.Compute.Matrix4
use Libraries.Compute.Quaternion
use Libraries.Compute.Vector3
use Libraries.Compute.Ray
use Libraries.Compute.Math

class Camera 
    
    /*
    The position of the camera.
    */
    public Vector3 position

    /*
    The unit length direction vector of the camera.
    */
    public Vector3 direction

    /*
    The unit length up vector of the camera.
    */
    public Vector3 up


    /*
    The projection matrix of the camera.
    */
    public Matrix4 projection

    /*
    The view matrix of the camera.
    */
    public Matrix4 view

    /*
    The combined projection and view matrix of the camera.
    */
    public Matrix4 combined

    /*
    The inverse of the combined projection and view matrix.
    */
    public Matrix4 inverseProjectionView


    /*
    The distance to the near clipping plane. Must be positive.
    */
    public number near = 1

    /*
    The distance to the far clipping plane. Must be positive.
    */
    public number far = 100


    /*
    The width of the camera viewport.
    */
    public number viewportWidth = 0

    /*
    The height of the camera viewport.
    */
    public number viewportHeight = 0


    /*
    The frustum containing the area which can be viewed by the camera.
    */
    public Frustum frustum


    private Vector3 calcVector
    private Ray ray

    on create
        direction:Set(0, 0, -1)
        up:Set(0, 1, 0)
    end

    blueprint action Update

    /*
    This action will angle the camera to look at the given point in 3D space.
    */
    action LookAt(number x, number y, number z)
        calcVector:Set(x, y, z):Subtract(position):Normalize()
        if not calcVector:IsZero()
            Math math

            // up and direction must ALWAYS be orthonormal vectors
            number dot = calcVector:DotProduct(up)
            if math:AbsoluteValue(dot - 1) < 0.000000001
                // Collinear
                up:Set(direction):Scale(-1)
            elseif math:AbsoluteValue(dot + 1) < 0.000000001
                // Collinear opposite
                up:Set(direction)
            end
            direction:Set(calcVector)
            NormalizeUp()
        end
    end

    // Is this ever needed as a public action?
    private action NormalizeUp
        calcVector:Set(direction):CrossProduct(up):Normalize()
        up:Set(calcVector):CrossProduct(direction):Normalize()
    end

    /*
    This action will angle the camera to look at the given point in 3D space.
    */
    action LookAt(Vector3 target)
        LookAt(target:GetX(), target:GetY(), target:GetZ())
    end

    /*
    This action rotates the camera the given number of degrees around the axis
    given as a 3D vector.
    */
    action Rotate(number degrees, number axisX, number axisY, number axisZ)
        direction:Rotate(degrees, axisX, axisY, axisZ)
        up:Rotate(degrees, axisX, axisY, axisZ)
    end

    /*
    This action rotates the camera the given number of degrees around the axis
    given as a 3D vector.
    */
    action Rotate(Vector3 axis, number degrees)
        direction:Rotate(axis, degrees)
        up:Rotate(axis, degrees)
    end

    /*
    This action rotates the camera the given number of degrees around the axis
    given as a 3D vector.
    */
    action Rotate(Matrix4 transform)
        direction:Rotate(transform)
        up:Rotate(transform)
    end

    /*
    This action rotates the camera the given number of degrees around the axis
    given as a 3D vector.
    */
    action Rotate(Quaternion quaternion)
        quaternion:Transform(direction)
        quaternion:Transform(up)
    end

    /*
    This action will rotate the camera around the given point, with the camera's
    rotation being about the given axis. The camera is rotated by the given
    number of degrees.
    */  
    action RotateAround(Vector3 point, Vector3 axis, number degrees)
        calcVector:Set(point)
        calcVector:Subtract(position)
        Translate(calcVector)
        Rotate(axis, degrees)
        calcVector:Rotate(axis, degrees)
        Translate(-calcVector:GetX(), -calcVector:GetY(), -calcVector:GetZ())
    end

    /*
    This action will transform the position, direction, and up vector of this
    camera by the given matrix.
    */
    action Transform(Matrix4 transform)
        position:Multiply(transform)
        Rotate(transform)
    end

    /*
    This action moves the camera by the given amount on each axis.
    */
    action Translate(number x, number y, number z)
        position:Add(x, y, z)
    end
    
    /*
    This action moves the camera by the given vector.
    */
    action Translate(Vector3 vector)
        position:Add(vector)
    end

    

    /*

	/** Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject, but does not
	 * rely on OpenGL. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left corner, y
	 * pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0 will return a
	 * point on the near plane, a z-coordinate of 1 will return a point on the far plane. This method allows you to specify the
	 * viewport position and dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the
	 * origin in the bottom left corner of the screen.
	 * @param screenCoords the point in screen coordinates (origin top left)
	 * @param viewportX the coordinate of the bottom left corner of the viewport in glViewport coordinates.
	 * @param viewportY the coordinate of the bottom left corner of the viewport in glViewport coordinates.
	 * @param viewportWidth the width of the viewport in pixels
	 * @param viewportHeight the height of the viewport in pixels *-
	public Vector3 unproject (Vector3 screenCoords, float viewportX, float viewportY, float viewportWidth, float viewportHeight) {
		float x = screenCoords.x, y = screenCoords.y;
		x = x - viewportX;
		y = Gdx.graphics.getHeight() - y - 1;
		y = y - viewportY;
		screenCoords.x = (2 * x) / viewportWidth - 1;
		screenCoords.y = (2 * y) / viewportHeight - 1;
		screenCoords.z = 2 * screenCoords.z - 1;
		screenCoords.prj(invProjectionView);
		return screenCoords;
	}

	/** Function to translate a point given in screen coordinates to world space. It's the same as GLU gluUnProject but does not
	 * rely on OpenGL. The viewport is assumed to span the whole screen and is fetched from {@link Graphics#getWidth()} and
	 * {@link Graphics#getHeight()}. The x- and y-coordinate of vec are assumed to be in screen coordinates (origin is the top left
	 * corner, y pointing down, x pointing to the right) as reported by the touch methods in {@link Input}. A z-coordinate of 0
	 * will return a point on the near plane, a z-coordinate of 1 will return a point on the far plane.
	 * @param screenCoords the point in screen coordinates *-
	public Vector3 unproject (Vector3 screenCoords) {
		unproject(screenCoords, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
		return screenCoords;
	}

	/** Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small
	 * deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the
	 * <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily
	 * useable in conjunction with {@link Batch} and similar classes. *-
	public Vector3 project (Vector3 worldCoords) {
		project(worldCoords, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
		return worldCoords;
	}

	/** Projects the {@link Vector3} given in world space to screen coordinates. It's the same as GLU gluProject with one small
	 * deviation: The viewport is assumed to span the whole screen. The screen coordinate system has its origin in the
	 * <b>bottom</b> left, with the y-axis pointing <b>upwards</b> and the x-axis pointing to the right. This makes it easily
	 * useable in conjunction with {@link Batch} and similar classes. This method allows you to specify the viewport position and
	 * dimensions in the coordinate system expected by {@link GL20#glViewport(int, int, int, int)}, with the origin in the bottom
	 * left corner of the screen.
	 * @param viewportX the coordinate of the bottom left corner of the viewport in glViewport coordinates.
	 * @param viewportY the coordinate of the bottom left corner of the viewport in glViewport coordinates.
	 * @param viewportWidth the width of the viewport in pixels
	 * @param viewportHeight the height of the viewport in pixels *-
	public Vector3 project (Vector3 worldCoords, float viewportX, float viewportY, float viewportWidth, float viewportHeight) {
		worldCoords.prj(combined);
		worldCoords.x = viewportWidth * (worldCoords.x + 1) / 2 + viewportX;
		worldCoords.y = viewportHeight * (worldCoords.y + 1) / 2 + viewportY;
		worldCoords.z = (worldCoords.z + 1) / 2;
		return worldCoords;
	}

	/** Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the
	 * whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis
	 * pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.
	 * @param viewportX the coordinate of the bottom left corner of the viewport in glViewport coordinates.
	 * @param viewportY the coordinate of the bottom left corner of the viewport in glViewport coordinates.
	 * @param viewportWidth the width of the viewport in pixels
	 * @param viewportHeight the height of the viewport in pixels
	 * @return the picking Ray. *-
	public Ray getPickRay (float screenX, float screenY, float viewportX, float viewportY, float viewportWidth,
		float viewportHeight) {
		unproject(ray.origin.set(screenX, screenY, 0), viewportX, viewportY, viewportWidth, viewportHeight);
		unproject(ray.direction.set(screenX, screenY, 1), viewportX, viewportY, viewportWidth, viewportHeight);
		ray.direction.sub(ray.origin).nor();
		return ray;
	}

	/** Creates a picking {@link Ray} from the coordinates given in screen coordinates. It is assumed that the viewport spans the
	 * whole screen. The screen coordinates origin is assumed to be in the top left corner, its y-axis pointing down, the x-axis
	 * pointing to the right. The returned instance is not a new instance but an internal member only accessible via this function.
	 * @return the picking Ray. *-
	public Ray getPickRay (float screenX, float screenY) {
		return getPickRay(screenX, screenY, 0, 0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
	}
        */
end