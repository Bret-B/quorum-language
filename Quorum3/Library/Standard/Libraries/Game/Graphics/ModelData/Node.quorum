package Libraries.Game.Graphics.ModelData

use Libraries.Containers.Array
use Libraries.Containers.Blueprints.Iterator
use Libraries.Compute.Vector3
use Libraries.Compute.Matrix4
use Libraries.Compute.Quaternion

class Node 
    
    text id = ""

    private Node parentNode = undefined
    private Array<Node> children
    boolean inheritTransform = true

    boolean isAnimated = false

    Vector3 translation
    Quaternion rotation
    Vector3 scale
    Matrix4 localTransform
    Matrix4 globalTransform

    // Array<NodePart> parts

    on create

	rotation:Set(0, 0, 0, 1)
	scale:Set(1, 1, 1)
	// parts:SetSize(2)

    end

    /*
    This action will calculate the node's local transform based on its
    translation, scale, and rotation. It then returns the local transform.
    */
    action CalculateLocalTransform returns Matrix4
	if not isAnimated
	    localTransform:Set(translation, rotation, scale)
	end
        return localTransform
    end

    /*
    This action will calculate the node's world transform, which is the product
    of its local transform and its parent's world transform. It then returns the
    world transform. In the case that this node has no parent, the local
    transform will be returned.
    */
    action CalculateWorldTransform returns Matrix4
	if inheritTransform and parentNode not= undefined
	    globalTransform:Set(parentNode:globalTransform)
	    globalTransform:Multiply(localTransform)
	else
	    globalTransform:Set(localTransform)
	end
        return globalTransform
    end

    /*
    This action calculates the local and world transforms for this node.
    */
    action CalculateTransforms
	CalculateLocalTransform()
	CalculateWorldTransform()
    end

    /*
    This action calculates the local and world transforms of the entire children
    hierarchy of this node.
    */
    action CalculateChildrenTransforms
	Node child
	integer index = 0
	repeat while index < children:GetSize()
	    child = children:Get(index)
	    child:CalculateAllTransforms()
	    index = index + 1
	end
    end

    /*
    This action calculates the local and world transforms of this node and for 
    its entire children hiearchy.
    */
    action CalculateAllTransforms
        CalculateTransforms()
        CalculateChildrenTransforms()
    end

    /*
    This action will add a new node to this node's children hierarchy.
    */
    action Add(Node node)
       Add(-1, node) 
    end

    /*
    This action will insert a new node in this node's children hierarchy at the
    given index.
    */
    action Add(integer index, Node node)
        Node temp = me
        integer counter = 0
        repeat while temp not= undefined
            if temp = node
                alert("Can't add a parent node as a child!")
            end
            temp = temp:GetParent()
        end

        temp = node:GetParent()
        if temp not= undefined and not temp:Remove(node)
            alert("Couldn't remove the new child from its current parent!")
        end
        if index < 0 or index >= children:GetSize()
            index = children:GetSize()
            children:Add(node)
        else
            children:Add(index, node)
        end
        node:SetParent(me)
    end

    /*
    This action removes a node from the children hierarchy.
    */
    action Remove(Node node) returns boolean
        if not children:Remove(node) 
            return false
        end
        node:SetParent(undefined)
        return true
    end

    /*
    This action returns this node's parent node.
    */
    action GetParent returns Node
        return undefined
    end

    /*
    This action will set the parent of this node. This information is
    automatically set when the node is added to another node.
    */
    action SetParent(Node node)
        parentNode = node
    end

    /*
    This action returns whether or not this node has a parent node.
    */
    action HasParent returns boolean
        return parentNode not= undefined
    end
    
    /*
    This action returns whether or not this node has any children nodes that
    have been added to it.
    */
    action HasChildren returns boolean
        return children:IsEmpty()
    end

    /*
    This action will return the number of nodes that are direct children of this
    node, i.e., they have been specifically added to this node.
    */
    action GetChildrenCount returns integer
        return children:GetSize()
    end

    /*
    This action returns the child stored at the given index in this node's
    children hierarchy.
    */
    action GetChild(integer index) returns Node
        return children:Get(index)
    end

    /*
    This action returns an iterator containing all of the direct children of
    this node, i.e., they have been specifically added to this node.
    */
    action GetChildren returns Iterator<Node>
        return children:GetIterator()
    end

    /*
    public void calculateBoneTransforms (boolean recursive) {
		for (final NodePart part : parts) {
			if (part.invBoneBindTransforms == null || part.bones == null || part.invBoneBindTransforms.size != part.bones.length)
				continue;
			final int n = part.invBoneBindTransforms.size;
			for (int i = 0; i < n; i++)
				part.bones[i].set(part.invBoneBindTransforms.keys[i].globalTransform).mul(part.invBoneBindTransforms.values[i]);
		}
		if (recursive) {
			for (Node child : children) {
				child.calculateBoneTransforms(true);
			}
		}
	}
    */

end

/*
/** 

	/** Calculate the bounding box of this Node. This is a potential slow operation, it is advised to cache the result. *-
	public BoundingBox calculateBoundingBox (final BoundingBox out) {
		out.inf();
		return extendBoundingBox(out);
	}

	/** Calculate the bounding box of this Node. This is a potential slow operation, it is advised to cache the result. *-
	public BoundingBox calculateBoundingBox (final BoundingBox out, boolean transform) {
		out.inf();
		return extendBoundingBox(out, transform);
	}

	/** Extends the bounding box with the bounds of this Node. This is a potential slow operation, it is advised to cache the
	 * result. *-
	public BoundingBox extendBoundingBox (final BoundingBox out) {
		return extendBoundingBox(out, true);
	}

	/** Extends the bounding box with the bounds of this Node. This is a potential slow operation, it is advised to cache the
	 * result. *-
	public BoundingBox extendBoundingBox (final BoundingBox out, boolean transform) {
		final int partCount = parts.size;
		for (int i = 0; i < partCount; i++) {
			final NodePart part = parts.get(i);
			if (part.enabled) {
				final MeshPart meshPart = part.meshPart;
				if (transform)
					meshPart.mesh.extendBoundingBox(out, meshPart.indexOffset, meshPart.numVertices, globalTransform);
				else
					meshPart.mesh.extendBoundingBox(out, meshPart.indexOffset, meshPart.numVertices);
			}
		}
		final int childCount = children.size;
		for (int i = 0; i < childCount; i++)
			children.get(i).extendBoundingBox(out);
		return out;
	}

	/** @param recursive false to fetch a root child only, true to search the entire node tree for the specified node.
	 * @return The node with the specified id, or null if not found. *-
	public Node getChild (final String id, boolean recursive, boolean ignoreCase) {
		return getNode(children, id, recursive, ignoreCase);
	}

	/** Adds the specified nodes as the currently last child of this node. If the node is already a child of another node, then it
	 * is removed from its current parent.
	 * @param nodes The Node to add as child of this Node
	 * @return the zero-based index of the first added child *-
	public <T extends Node> int addChildren (final Iterable<T> nodes) {
		return insertChildren(-1, nodes);
	}

	/** Insert the specified nodes as children of this node at the specified index. If the node is already a child of another node,
	 * then it is removed from its current parent. If the specified index is less than zero or equal or greater than
	 * {@link #getChildCount()} then the Node is added as the currently last child.
	 * @param index The zero-based index at which to add the child
	 * @param nodes The nodes to add as child of this Node
	 * @return the zero-based index of the first inserted child *-
	public <T extends Node> int insertChildren (int index, final Iterable<T> nodes) {
		if (index < 0 || index > children.size)
			index = children.size;
		int i = index;
		for (T child : nodes)
			insertChild(i++, child);
		return index;
	}

	/** Helper method to recursive fetch a node from an array
	 * @param recursive false to fetch a root node only, true to search the entire node tree for the specified node.
	 * @return The node with the specified id, or null if not found. *-
	public static Node getNode (final Array<Node> nodes, final String id, boolean recursive, boolean ignoreCase) {
		final int n = nodes.size;
		Node node;
		if (ignoreCase) {
			for (int i = 0; i < n; i++)
				if ((node = nodes.get(i)).id.equalsIgnoreCase(id)) return node;
		} else {
			for (int i = 0; i < n; i++)
				if ((node = nodes.get(i)).id.equals(id)) return node;
		}
		if (recursive) {
			for (int i = 0; i < n; i++)
				if ((node = getNode(nodes.get(i).children, id, true, ignoreCase)) != null) return node;
		}
		return null;
	}
*/