package Libraries.Game.Graphics

use Libraries.Containers.Array
use Libraries.Game.Graphics.Color
use Libraries.Game.Graphics.TextureRegion
use Libraries.Game.Graphics.VertexAttribute
use Libraries.Game.Graphics.VertexAttributes
use Libraries.Game.Graphics.ModelData.MeshPart
use Libraries.Compute.Math
use Libraries.Compute.Matrix4
use Libraries.Compute.Matrix3
use Libraries.Compute.Vector3
use Libraries.Compute.Vector2
use Libraries.Game.BoundingBox
use Libraries.Game.NumberUtilities

class MeshBuilder 

    /*
    The POINTS value is one of the possible primitive type values. It is used to
    indicate that each vertex of the Mesh should be considered an individual
    point, separate from the other vertices.
    */
    public constant integer POINTS = 0

    /*
    The LINES value is one of the possible primitive type values. The Mesh will
    form lines using pairs of vertices.
    */
    public constant integer LINES = 1

    /*
    The TRIANGLES value is one of the possible primitive type values. The Mesh
    will form triangles from triplets of vertices.
    */
    public constant integer TRIANGLES = 4
    
    // An array used to temporarily store indices during operations.
    private Array<integer> tempIndices

    // An array used to temporarily store vertices during operations.
    private Array<number> tempVertices


    // A collection of temporary VertexSchematic objects used during operations.
    private VertexSchematic vertTemp1
    private VertexSchematic vertTemp2
    private VertexSchematic vertTemp3
    private VertexSchematic vertTemp4

    // A temporary Color object used during operations.
    private Color tempColor

    // The VertexAttributes of the mesh being constructed.
    private VertexAttributes attributes = undefined

    // The vertices of the mesh being constructed.
    private Array<number> vertices

    // The indices of the mesh being constructed.
    private Array<integer> indices

    // How many number components make up each vertex.
    private integer vertexSize = 0

    // The current vertex index, used for indexing.
    private integer vertexIndex = 0

    // The offset in the indices array when Begin() was called. Used to define a MeshPart.
    private integer indicesStart = 0

    // The count of number components in a vertex before the positional component.
    private integer positionOffset = 0

    // How many number components make up the position attribute.
    private integer positionSize = 0

    //The count of number components in a vertex before the normal component. If there is no normal, this will be -1.
    private integer normalOffset = -1

    // The count of number components in a vertex before the binormal component. If there is no binormal, this will be -1.
    private integer binormalOffset = -1

    // The count of number components in a vertex before the tangent component. If there is no tangent, this will be -1.
    private integer tangentOffset = -1

    // The count of number components in a vertex before the color component. If there is no color, this will be -1.
    private integer colorOffset = -1

    // How many number components make up the color attribute.
    private integer colorSize = 0

    // The count of number components in a vertex before the packed color component, or -1 if there is none.
    private integer colorPackedOffset = -1

    // The count of number components in a vertex before the texture coordinates, or -1 if there are none.
    private integer textureCoordinatesOffset = -1

    // The MeshPart currently under construction.
    private MeshPart part = undefined

    // The MeshParts created between calls to Begin() and End().
    private Array<MeshPart> parts

    // The color used if no vertex color is specified.
    private Color color

    // Whether or not a color has been specified for the vertices.
    private boolean hasColor = false

    // The current primitiveType being used to describe the mesh.
    private integer primitiveType = TRIANGLES

    // The last index which was used during Mesh construction.
    private integer lastIndex = -1

    // The UV range used for texture coordinates during construction.
    private number uOffset = 0
    private number uScale = 1
    private number vOffset = 0
    private number vScale = 1
    private boolean hasUVTransform = false
    private Array<number> vertex = undefined

    private boolean vertexTransformationEnabled = false
    private Matrix4 positionTransform
    private Matrix3 normalTransform
    private BoundingBox bounds

    private Math math
    private NumberUtilities numberUtilities
    private Vector3 calcVector

    /** @param usage bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal and
	 *           TextureCoordinates is supported. *-
	public static VertexAttributes createAttributes (long usage) {
		final Array<VertexAttribute> attrs = new Array<VertexAttribute>();
		if ((usage & Usage.Position) == Usage.Position)
			attrs.add(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE));
		if ((usage & Usage.ColorUnpacked) == Usage.ColorUnpacked)
			attrs.add(new VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE));
		if ((usage & Usage.ColorPacked) == Usage.ColorPacked)
			attrs.add(new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE));
		if ((usage & Usage.Normal) == Usage.Normal)
			attrs.add(new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE));
		if ((usage & Usage.TextureCoordinates) == Usage.TextureCoordinates)
			attrs.add(new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
		final VertexAttribute attributes[] = new VertexAttribute[attrs.size];
		for (int i = 0; i < attributes.length; i++)
			attributes[i] = attrs.get(i);
		return new VertexAttributes(attributes);
	}

        /** Begin building a mesh. Call {@link #part(String, int)} to start a {@link MeshPart}.
	 * @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal
	 *           and TextureCoordinates is supported. *-
	public void begin (final long attributes) {
		begin(createAttributes(attributes), -1);
	}

        /** Begin building a mesh.
	 * @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal
	 *           and TextureCoordinates is supported. *-
	public void begin (final long attributes, int primitiveType) {
		begin(createAttributes(attributes), primitiveType);
	}
    */

    /*
    This action informs the MeshBuilder to begin constructing a new mesh. If a
    mesh is already in construction, this will throw an error.
    */
    action Begin(VertexAttributes vAttributes)
        Begin(vAttributes, -1)
    end

    /*
    This action informs the MeshBuilder to begin constructing a new mesh. If a
    mesh is already in construction, this will throw an error. The
    VertexAttributes must contain at least a Position attribute, and can also
    contain Normal, Binormal, Tangent, ColorUnpacked, ColorPacked, or
    TextureCoordinates attributes. The type should be one of the primitive type
    constants in the MeshBuilder: POINTS, LINES, or TRIANGLES.
    */
    action Begin(VertexAttributes vAttributes, integer type)
        if attributes not= undefined
            alert("I can't begin building a new Mesh because there is already one under construction!")
        end

        attributes = vAttributes
        vertices:Empty()
        indices:Empty()
        parts:Empty()
        vertexIndex = 0
        lastIndex = -1
        indexStart = 0
        part = undefined
        vertexSize = attributes:vertexSize / 4

        if vertex = undefined or vertex:GetSize() < vertexSize
            Array<number> newVertexArray
            newVertexArray:SetSize(vertexSize)
            vertex = newVertexArray
        end

        VertexAttribute attribute = attributes:FindByUsage(attributes:POSITION)
        if attribute = undefined
            alert("I was told to construct a mesh without a Position attribute, but that attribute is required.")
        end
        positionOffset = attribute:offset / 4
        positionSize = attribute:componentCount

        attribute = attributes:FindByUsage(attributes:NORMAL)
        if attribute = undefined
            normalOffset = -1
        else
            normalOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:BINORMAL)
        if attribute = undefined
            binormalOffset = -1
        else
            binormalOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:TANGENT)
        if attribute = undefined
            tangentOffset = -1
        else
            tangentOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:COLOR_UNPACKED)
        if attribute = undefined
            colorOffset = -1
        else
            colorOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:COLOR_PACKED)
        if attribute = undefined
            colorPackedOffset = -1
        else
            colorPackedOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:TEXTURE_COORDINATES)
        if attribute = undefined
            textureCoordinatesOffset = -1
        else
            textureCoordinatesOffset = attribute:offset / 4
        end
        
        //SetColor(undefined)
        //SetUVRange(undefined)
        primitiveType = type
        bounds:Invalidate()
    end

    private action EndPart
        if part not= undefined
            /* The following lines of code set fields in the MeshPart that exist
            in libGDX, but that we do not currently use or have.

            part:center = bounds:GetCenter()
            part:halfExtents = bounds:GetDimensions():Scale(0.5)
            part:radius = part:halfExtents:Length()
            */
            bounds:Invalidate()
            part:indexOffset = indicesStart
            part:verticesCount = indices:GetSize() - indicesStart
            indicesStart = indices:GetSize()
            part = undefined
        end
    end

    /*
    This action will start constructing a new MeshPart for the Mesh. The new
    MeshPart will still not be usable until End() is called. This will reset
    any current color and vertex transformations.
    */
    action NewPart(text id, integer type) returns MeshPart
        if attributes = undefined
            alert("I can't begin constructing a new MeshPart if I'm not currently building a Mesh. Call Begin() before using NewPart().")
        end
        EndPart()

        MeshPart newPart
        part = newPart
        part:id = id
        primitiveType = type
        part:primitiveType = type
        parts:Add(part)

        //SetColor(undefined)
        //SetVertexTransform(undefined)
        //SetUVRange(undefined)
        
        return part
    end
    
    /*
    This action will finish construction of the current Mesh, and then return it.
    */
    action End returns Mesh
        if attributes = undefined
            alert("I must begin constructing a Mesh before I can finish it - call Begin() first.")
        end

        Mesh newMesh
        newMesh:Load(true, vertices:GetSize() / vertexSize, indices:GetSize(), attributes)

        EndPart()
        
        newMesh:SetVertices(vertices)
        newMesh:SetIndices(indices)

        integer counter = 0
        MeshPart meshPart = undefined
        repeat parts:GetSize() times
            meshPart = parts:Get(counter)
            meshPart:mesh = newMesh
            counter = counter + 1
        end
        parts:Empty()

        attributes = undefined
        vertices:Empty()
        indices:Empty()

        return newMesh
    end

    /*
    Empties the data being built up until now, including the vertices, indices,
    and all parts. Must be called between Begin() and End() to have any effect.
    This effectively discards all work done since the initial Begin(), but will
    not reset state such as UV region, color, or vertex transform.
    */
    action Empty
        vertices:Empty()
        indices:Empty()
        parts:Empty()
        vertexIndex = 0
        lastIndex = -1
        indicesStart = 0
        part = undefined
    end

    /*
    This action will return the amount of number components that makes up each
    vertex.
    */
    action GetVertexSize returns integer
        return vertexSize
    end

    /*
    This action returns the number of vertices that have been built so far for
    the current Mesh under construction. This will only return a valid result
    if used between calls to Begin() and End().
    */
    action GetVerticesCount returns number
        return vertices:GetSize() / vertexSize
    end

    /*
    This action will return a copy of all of the vertices built so far. This
    action must be called between Begin() and End() - otherwise, an error will
    be thrown.
    */
    action GetVertices returns Array<number>
        return vertices
    end

    /*
    This action will return the number of indices that has been built so far in
    the Mesh currently under construction. This is only valid between calls to
    Begin() and End().
    */
    action GetIndicesCount returns integer
        return indices:GetSize()
    end

    /*
    This action will return a copy of the indices that have been built so far.
    This action is only valid between calls to Begin() and End() - otherwise,
    this action will throw an error.
    */
    action GetIndices returns Array<integer>
        return indices
    end

    /*
    This action will return the attributes that were given for the current Mesh
    under construction. If there isn't a Mesh currently being built, this will
    be undefined.
    */
    action GetAttributes returns VertexAttributes
        return attributes
    end

    /*
    This action will return the MeshPart currently under construction by the
    MeshBuilder. If there isn't a MeshPart under construction, then this will be
    undefined.
    */
    action GetMeshPart returns MeshPart
        return part
    end

    /*
    This action will return the primitive type being used to define the geometry
    of the current Mesh under construction. The primitive type is an integer 
    value that represents an OpenGL constant, such as TRIANGLES.
    */
    action GetPrimitiveType returns integer
        return primitiveType
    end

    /*
    This action will set the color value of the vertices that are created during
    Mesh construction. The color is made of a red, green, blue, and alpha (or
    transparency) component.
    */
    action SetColor(number red, number green, number blue, number alpha)
        color:SetColor(red, green, blue, alpha)
        hasColor = not (red = 1.0 and green = 1.0 and blue = 1.0 and alpha = 1.0)
    end

    /*
    This action will set the color value of the vertices that are created during
    Mesh construction.
    */
    action SetColor(Color newColor)
        color:SetColor(newColor:GetRed(), newColor:GetGreen(), newColor:GetBlue(), newColor:GetAlpha())
        hasColor = not (newColor:GetRed() = 1.0 and newColor:GetGreen() = 1.0 and newColor:GetBlue() = 1.0 and newColor:GetAlpha() = 1.0)
    end

    // TO-DO: Better clarify what this action does.
    /*
    This action will set the UV range that will be applied to the vertices of
    the Mesh under construction. The UV values are used to determine how a 
    texture should be mapped onto the Mesh.
    */
    action SetUVRange(number u1, number v1, number u2, number v2)
        uOffset = u1
        vOffset = v1
        uScale = u2 - u1
        vScale = v2 - v1
        number errorMargin = 0.000001
        hasUVTransform = not (math:AbsoluteValue(u1) < errorMargin
                          and math:AbsoluteValue(v1) < errorMargin
                          and math:AbsoluteValue(u2 - 1.0) < errorMargin
                          and math:AbsoluteValue(v2 - 1.0) < errorMargin)
    end

    // TO-DO: Better clarify what this action does.
    /*
    This action will set the UV range that will be applied to the vertices of
    the Mesh under construction. The UV values are used to determine how a 
    texture should be mapped onto the Mesh.
    */
    action SetUVRange(TextureRegion region)
        if region = undefined
            hasUVTransform = false
            uOffset = 0
            vOffset = 0
            uScale = 1
            vScale = 1
        else
            SetUVRange(region:GetLeftSide(), region:GetTopSide(), region:GetRightSide(), region:GetBottomSide())
        end
    end

    /*
    This action will return a new Matrix4 object containing a copy of the vertex
    transformation matrix that the current Mesh being built is using.
    */
    action GetVertexTransform returns Matrix4
        Matrix4 new
        new:Set(positionTransform)
        return new
    end

    /*
    This action will set the transformation matrix for the vertices of the Mesh
    that is under construction.
    */
    action SetVertexTransform(Matrix4 transform)
        if transform not= undefined
            vertexTransformationEnabled = true
            positionTransform:Set(transform)
            normalTransform:Set(transform):Inverse():Transpose()
        else
            vertexTransformationEnabled = false
            positionTransform:IdentityMatrix()
            normalTransform:IdentityMatrix()
        end
    end

    /*
    This action will return whether or not the Mesh under construction is
    currently using a Matrix4 to transform its vertices.
    */
    action IsVertexTransformationEnabled returns boolean
        return vertexTransformationEnabled
    end

    /*
    This action will set the MeshBuilder to allow for vertex transformation
    using a Matrix4 object.
    */
    action SetVertexTransformationEnabled(boolean enabled)
        vertexTransformationEnabled = enabled
    end

    /*
    This action will ensure that the current Mesh under construction will
    have enough room to store the given number of vertices, in addition to what
    it is currently storing.
    */
    action EnsureVertices(integer numVertices)
        vertices:SetMaxSize(vertices:GetSize() + numVertices * vertexSize)
    end

    /*
    This action will ensure that the current Mesh under construction will
    support all of its current indices, plus the given number of additional
    indices.
    */
    action EnsureIndices(integer numIndices)
        indices:SetMaxSize(indices:GetSize() + numIndices)
    end

    /*
    This action will guarantee that the Mesh under construction will have the
    proper number of indices to form the given number of triangles, based on
    what primitive type has already been set for the Mesh.
    */
    action EnsureTriangleIndices(integer numTriangles)
        if primitiveType = LINES
            EnsureIndices(6 * numTriangles)
        elseif primitiveType = TRIANGLES or primitiveType = POINTS
            EnsureIndices(3 * numTriangles)
        else
            alert("The MeshBuilder was given an invalid primitive type - the supported values are the POINTS, LINES, or TRIANGLES constants.")
        end
    end
  
    /*
    This action will guarantee that the Mesh under construction will have the
    proper number of indices to form the given number of rectangles, based on
    what primitive type has already been set for the Mesh.
    */
    action EnsureRectangleIndices(integer numRectangles)
        if primitiveType = POINTS
            EnsureIndices(4 * numRectangles)
        elseif primitiveType = LINES
            EnsureIndices(8 * numRectangles)
        elseif primitiveType = TRIANGLES
            EnsureIndices(6 * numRectangles)
        else
            alert("The MeshBuilder was given an invalid primitive type - the supported values are the POINTS, LINES, or TRIANGLES constants.")
        end
    end

    /*
    This action will return what the last index used was during the construction
    of a Mesh.
    */
    action GetLastIndex returns integer
        return lastIndex
    end
    
    private action TransformPosition(Array<number> values, integer offset, integer size, Matrix4 transform)
        if size > 2
            calcVector:Set(values:Get(offset), values:Get(offset + 1), values:Get(offset + 2))
            calcVector:Multiply(transform)
            values:Set(offset, calcVector:GetX())
            values:Set(offset + 1, calcVector:GetY())
            values:Set(offset + 2, calcVector:GetZ())
        elseif size > 1
            calcVector:Set(values:Get(offset), values:Get(offset + 1), 0)
            calcVector:Multiply(transform)
            values:Set(offset, calcVector:GetX())
            values:Set(offset + 1, calcVector:GetY())
        else
            calcVector:Set(values:Get(offset), 0, 0)
            calcVector:Multiply(transform)
            values:Set(offset, calcVector:GetX())
        end
    end

    private action TransformNormal(Array<number> values, integer offset, integer size, Matrix3 transform)
        if size > 2
            calcVector:Set(values:Get(offset), values:Get(offset + 1), values:Get(offset + 2))
            calcVector:Multiply(transform)
            calcVector:Normalize()
            values:Set(offset, calcVector:GetX())
            values:Set(offset + 1, calcVector:GetY())
            values:Set(offset + 2, calcVector:GetZ())
        elseif size > 1
            calcVector:Set(values:Get(offset), values:Get(offset + 1), 0)
            calcVector:Multiply(transform)
            calcVector:Normalize()
            values:Set(offset, calcVector:GetX())
            values:Set(offset + 1, calcVector:GetY())
        else
            calcVector:Set(values:Get(offset), 0, 0)
            calcVector:Multiply(transform)
            calcVector:Normalize()
            values:Set(offset, calcVector:GetX())
        end
    end

    private action AddVertex(Array<number> values, integer offset)
        integer originalSize = vertices:GetSize()
        
        integer counter = 0
        repeat values:GetSize() times
            vertices:Add(values:Get(counter))
            counter = counter + 1
        end

        lastIndex = vertexIndex

        if vertexTransformationEnabled
            TransformPosition(vertices, originalSize + positionOffset, positionSize, positionTransform)
            
            if normalOffset >= 0
                TransformNormal(vertices, originalSize + normalOffset, 3, normalTransform)
            end

            if binormalOffset >= 0
                TransformNormal(vertices, originalSize + binormalOffset, 3, normalTransform)
            end

            if tangentOffset >= 0
                TransformNormal(vertices, originalSize + tangentOffset, 3, normalTransform)
            end
        end

        number x = vertices:Get(originalSize + positionOffset)
        number y = 0
        number z = 0
        if positionSize > 1
            y = vertices:Get(originalSize + positionOffset + 1)
            if positionSize > 2
                z = vertices:Get(originalSize + positionOffset + 2)
            end
        end
        bounds:Extend(x, y, z)

        if hasColor
            if colorOffset >= 0
                vertices:Set(originalSize + colorOffset, vertices:Get(originalSize + colorOffset) * color:GetRed())
                vertices:Set(originalSize + colorOffset + 1, vertices:Get(originalSize + colorOffset + 1) * color:GetGreen())
                vertices:Set(originalSize + colorOffset + 2, vertices:Get(originalSize + colorOffset + 2) * color:GetBlue())
                if colorSize > 3
                    vertices:Set(originalSize + colorOffset + 3, vertices:Get(originalSize + colorOffset + 3) * color:GetAlpha())
                end
            elseif colorPackedOffset >= 0
                tempColor:SetColorFromCode(numberUtilities:EncodeNumberAsInteger(vertices:Get(originalSize + colorPackedOffset)))
                tempColor:SetColor(tempColor:GetRed() * color:GetRed(), tempColor:GetGreen() * color:GetGreen(),
                    tempColor:GetBlue() * color:GetBlue(), tempColor:GetAlpha() * color:GetAlpha())

                vertices:Set(originalSize + colorPackedOffset, tempColor:EncodeColorAsNumber())
            end
        end

        if hasUVTransform and textureCoordinatesOffset >= 0
            vertices:Set(originalSize + textureCoordinatesOffset, uOffset + uScale * vertices:Get(originalSize + textureCoordinatesOffset))
            vertices:Set(originalSize + textureCoordinatesOffset + 1, vOffset + vScale * vertices:Get(originalSize + textureCoordinatesOffset + 1))
        end
    end

    /*
    This action will create a new vertex and add it to the Mesh currently under
    construction. The index of the newly created vertex will be returned.
    */
    action AddVertex(Vector3 pos, Vector3 norm, Color col, Vector2 uv) returns integer
        if vertexIndex = vertexIndex:GetMaximumValue()
            alert("I can't add another vertex to the mesh because I've already used the maximum possible.")
        end

        vertex:Set(positionOffset, pos:GetX())
        
        if positionSize > 1
            vertex:Set(positionOffset + 1, pos:GetY())
            if positionSize > 2
                vertex:Set(positionOffset + 2, pos:GetZ())
            end
        end

        if normalOffset >= 0
            if norm = undefined
                calcVector:Set(pos):Normalize()
                vertex:Set(normalOffset, calcVector:GetX())
                vertex:Set(normalOffset + 1, calcVector:GetY())
                vertex:Set(normalOffset + 2, calcVector:GetZ())
            else
                vertex:Set(normalOffset, norm:GetX())
                vertex:Set(normalOffset + 1, norm:GetY())
                vertex:Set(normalOffset + 2, norm:GetZ())
            end
        end

        if colorOffset >= 0
            if color = undefined
                vertex:Set(colorOffset, 1.0)
                vertex:Set(colorOffset + 1, 1.0)
                vertex:Set(colorOffset + 2, 1.0)
                if colorSize > 3
                    vertex:Set(colorOffset + 3, 1.0)
                end
            else
                vertex:Set(colorOffset, col:GetRed())
                vertex:Set(colorOffset + 1, col:GetGreen())
                vertex:Set(colorOffset + 2, col:GetBlue())
                if colorSize > 3
                    vertex:Set(colorOffset + 3, col:GetAlpha())
                end
            end
        elseif colorPackedOffset >= 0
            if col = undefined
                Color newColor = color:White()
                vertex:Set(colorPackedOffset, newColor:EncodeColorAsNumber())
            else
                vertex:Set(colorPackedOffset, col:EncodeColorAsNumber())
            end
        end

        if uv not= undefined and textureCoordinatesOffset >= 0
            vertex:Set(textureCoordinatesOffset, uv:GetX())
            vertex:Set(textureCoordinatesOffset + 1, uv:GetY())
        end

        AddVertex(vertex, 0)
        return lastIndex
    end

    /*
    This action will add the vertex described by the given VertexSchematic to
    the Mesh currently under construction. This action will return the index of
    the newly added vertex.
    */
    action AddVertex(VertexSchematic schematic) returns integer
        Vector3 position = undefined
        Vector3 normal = undefined
        Color color = undefined
        Vector2 uv = undefined

        if schematic:HasPosition()
            position = schematic:GetPosition()
        end

        if schematic:HasNormal()
            normal = schematic:GetNormal()
        end

        if schematic:HasColor()
            color = schematic:GetColor()
        end

        if schematic:HasTextureCoordinates()
            uv = schematic:GetTextureCoordinates()
        end

        return AddVertex(position, normal, color, uv)
    end

    /*
    This action will add a new index to the indices of the Mesh under
    construction. 
    */
    action AddIndex(integer value)
        indices:Add(value)
    end

    /*
    This action will create a new line between the two given indices in the Mesh
    under construction. This is only valid if the primitive type being used is
    LINES - otherwise, an error will be thrown.
    */
    action AddLine(integer index1, integer index2)
        if primitiveType not= LINES
            alert("I can't add a line to the Mesh because the primitive type used to define the Mesh is not LINES!")
        end

        EnsureIndices(2)
        indices:Add(index1)
        indices:Add(index2)
    end

    /*
    This action will add two new vertices to the current Mesh under
    construction, and then create a line between them. This is only valid if the
    primitive type being used is LINES - otherwise, an error will be thrown.
    */
    action AddLine(VertexSchematic point1, VertexSchematic point2)
        EnsureVertices(2)
        AddLine(AddVertex(point1), AddVertex(point2))
    end

    /*
    This action will add two new vertices to the current Mesh under
    construction, and then create a line between them. This is only valid if the
    primitive type being used is LINES - otherwise, an error will be thrown.
    */
    action AddLine(Vector3 point1, Vector3 point2)
        vertTemp1:Set(point1, undefined, undefined, undefined)
        vertTemp2:Set(point2, undefined, undefined, undefined)
        AddLine(vertTemp1, vertTemp2)
    end

    /*
    This action will add two new vertices to the current Mesh under
    construction, and then create a line between them. This is only valid if the
    primitive type being used is LINES - otherwise, an error will be thrown.
    */
    action AddLine(number x1, number y1, number z1, number x2, number y2, number z2)
        vertTemp1:Set(undefined, undefined, undefined, undefined):SetPosition(x1, y1, z1)
        vertTemp2:Set(undefined, undefined, undefined, undefined):SetPosition(x2, y2, z2)
        AddLine(vertTemp1, vertTemp2)
    end

    /*
    This action will add two new vertices to the current Mesh under
    construction, and then create a line between them. This is only valid if the
    primitive type being used is LINES - otherwise, an error will be thrown.
    */
    action AddLine(Vector3 point1, Color color1, Vector3 point2, Color color2)
        vertTemp1:Set(point1, undefined, color1, undefined)
        vertTemp2:Set(point2, undefined, color1, undefined)
        AddLine(vertTemp1, vertTemp2)
    end

    /*
    This action will create a new triangle between the three given indices in
    the Mesh under construction. This is only valid if the primitive type being
    used is either POINTS, LINES, or TRIANGLES. Otherwise, an error will be
    thrown.
    */
    action AddTriangle(integer index1, integer index2, integer index3)
        if primitiveType = TRIANGLES or primitiveType = POINTS
            EnsureIndices(3)
            indices:Add(index1)
            indices:Add(index2)
            indices:Add(index3)
        elseif primitiveType = LINES
            EnsureIndices(6)
            indices:Add(index1)
            indices:Add(index2)
            indices:Add(index2)
            indices:Add(index3)
            indices:Add(index3)
            indices:Add(index1)
        else
            alert("I was asked to add a triangle, but I can only do that if the primitive type I'm using is POINTS, LINES, or TRIANGLES.")
        end
    end

    /*
    This action will add a new Rectangle to the Mesh under construction, using
    the given indices to form the rectangle. The supported primitive types are
    POINTS, LINES, and TRIANGLES - any other primitive type will throw an error.
    */
    action AddRectangle(integer corner00, integer corner10, integer corner11, integer corner01)
        if primitiveType = TRIANGLES
            EnsureIndices(6)
            indices:Add(corner00)
            indices:Add(corner10)
            indices:Add(corner11)
            indices:Add(corner11)
            indices:Add(corner01)
            indices:Add(corner00)
        elseif primitiveType = LINES
            EnsureIndices(8)
            indices:Add(corner00)
            indices:Add(corner10)
            indices:Add(corner10)
            indices:Add(corner11)
            indices:Add(corner11)
            indices:Add(corner01)
            indices:Add(corner01)
            indices:Add(corner00)
        elseif primitiveType = POINTS
            EnsureIndices(4)
            indices:Add(corner00)
            indices:Add(corner10)
            indices:Add(corner11)
            indices:Add(corner01)
        else
            alert("I was given an invalid primitive type for construction rectangles - the supported primitive types are POINTS, LINES, and TRIANGLES.")
        end
    end

    /*
    This action will add the geometry of an existing Mesh to the Mesh that is
    currently under construction by the MeshBuilder.
    */
//    action AddMesh(Mesh mesh)
//        AddMesh(mesh, 0, mesh:GetIndicesCount())
//    end

    /*
    This action will add an existing MeshPart to the Mesh that is currently
    under construction by the MeshBuilder.
    */
//    action AddMesh(MeshPart meshPart)
//        if meshPart:primitiveType not= primitiveType
//            alert("The primitive type of the MeshPart doesn't match the primitive type being used by the Mesh under construction.")
//        end
//
//        AddMesh(meshPart:mesh, meshPart:indexOffset, meshPart:verticesCount)
//    end

    /*
    This action will add an existing MeshPart to the Mesh that is currently
    under construction by the MeshBuilder.
    */
//    action AddMesh(Mesh mesh, integer indexOffset, integer numIndices)
//        if not attributes:Equals(mesh:GetVertexAttributes())
//            alert("The vertex attributes of the given Mesh do not match the vertex attributes of the Mesh under construction.")
//        end
//
//        if numIndices <= 0
//            return now
//        end
//
//        integer numberCount = mesh:GetVerticesCount() * vertexSize
//        tempVertices:Empty()
//        tempVertices:SetMaxSize(numberCount)
//        // mesh:GetVertices(tempVertices)
//
//        tempIndices:Empty()
//        tempIndices:SetMaxSize(numIndices)
//        // mesh:GetIndices(indexOffset, numIndices, tempIndices, 0)
//
//        AddMesh(tempVertices, tempIndices, 0, numIndices)
//    end

    /*
    This action will add the given vertex and index arrays to the geometry of
    the Mesh currently under construction by the MeshBuilder.
    */
//    action AddMesh(Array<number> vertices, Array<integer> indicies, integer indexOffset, integer numIndices)
//        // if indicesMap = undefined
//        //      ...
//        // else
//        //  indicesMap:Empty()
//        //  indicesMap:SetMaxSize(numIndices)
//        // end
//
//        EnsureIndices(numIndices)
//        integer numVertices = vertices:GetSize() / vertexSize
//        if numVertices < numIndices
//            EnsureVertices(numVertices)
//        else
//            EnsureVertices(numIndices)
//        end
//
//        integer counter = 0
//        repeat numIndices times
//            integer sidx = indices:Get(indexOffset + counter)
////            integer didx = indicesMap:Get(sidx, -1)
////            if didx < 0
////                AddVertex(vertices, sidx * vertexSize)
////                didx = lastIndex
////                //indicesMap:Set(sidx, lastIndex)
////            end
////        
////            AddIndex(didx)
//            counter = counter + 1
//        end
//    end

    /*
    This action will add the given vertex and index arrays to the geometry of
    the Mesh currently under construction by the MeshBuilder.
    */
    action AddMesh(Array<number> vertices, Array<integer> indices)
        integer offset = lastIndex + 1

        integer numVertices = vertices:GetSize() / vertexSize
        EnsureVertices(numVertices)

        integer counter = 0
        repeat while counter < vertices:GetSize()
            AddVertex(vertices, counter)
            counter = counter + vertexSize
        end

        EnsureIndices(indices:GetSize())
        
        counter = 0
        repeat while counter < indices:GetSize()
            AddIndex(indices:Get(counter) + offset)
            counter = counter + 1
        end
    end

end

/*
	@Override
	public void triangle (VertexInfo p1, VertexInfo p2, VertexInfo p3) {
		ensureVertices(3);
		triangle(vertex(p1), vertex(p2), vertex(p3));
	}

	@Override
	public void triangle (Vector3 p1, Vector3 p2, Vector3 p3) {
		triangle(vertTmp1.set(p1, null, null, null), vertTmp2.set(p2, null, null, null), vertTmp3.set(p3, null, null, null));
	}

	@Override
	public void triangle (Vector3 p1, Color c1, Vector3 p2, Color c2, Vector3 p3, Color c3) {
		triangle(vertTmp1.set(p1, null, c1, null), vertTmp2.set(p2, null, c2, null), vertTmp3.set(p3, null, c3, null));
	}

	@Override
	public void rect (VertexInfo corner00, VertexInfo corner10, VertexInfo corner11, VertexInfo corner01) {
		ensureVertices(4);
		rect(vertex(corner00), vertex(corner10), vertex(corner11), vertex(corner01));
	}

	@Override
	public void rect (Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal) {
		rect(vertTmp1.set(corner00, normal, null, null).setUV(0f, 1f), vertTmp2.set(corner10, normal, null, null).setUV(1f, 1f),
			vertTmp3.set(corner11, normal, null, null).setUV(1f, 0f), vertTmp4.set(corner01, normal, null, null).setUV(0f, 0f));
	}

	@Override
	public void rect (float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11,
		float x01, float y01, float z01, float normalX, float normalY, float normalZ) {
		rect(vertTmp1.set(null, null, null, null).setPos(x00, y00, z00).setNor(normalX, normalY, normalZ).setUV(0f, 1f), vertTmp2
			.set(null, null, null, null).setPos(x10, y10, z10).setNor(normalX, normalY, normalZ).setUV(1f, 1f),
			vertTmp3.set(null, null, null, null).setPos(x11, y11, z11).setNor(normalX, normalY, normalZ).setUV(1f, 0f), vertTmp4
				.set(null, null, null, null).setPos(x01, y01, z01).setNor(normalX, normalY, normalZ).setUV(0f, 0f));
	}

	// TODO: The following methods are deprecated and will be removed in a future release
	
	@Override
	@Deprecated
	public void patch (VertexInfo corner00, VertexInfo corner10, VertexInfo corner11, VertexInfo corner01, int divisionsU,
		int divisionsV) {
		PatchShapeBuilder.build(this, corner00, corner10, corner11, corner01, divisionsU, divisionsV);
	}

	@Override
	@Deprecated
	public void patch (Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal, int divisionsU,
		int divisionsV) {
		PatchShapeBuilder.build(this, corner00, corner10, corner11, corner01, normal, divisionsU, divisionsV);
	}

	@Override
	@Deprecated
	public void patch (float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11,
		float x01, float y01, float z01, float normalX, float normalY, float normalZ, int divisionsU, int divisionsV) {
		PatchShapeBuilder.build(this, x00, y00, z00, x10, y10, z10, x11, y11, z11, x01, y01, z01, normalX, normalY, normalZ, divisionsU, divisionsV);
	}
	
	@Override
	@Deprecated
	public void box (VertexInfo corner000, VertexInfo corner010, VertexInfo corner100, VertexInfo corner110, VertexInfo corner001,
		VertexInfo corner011, VertexInfo corner101, VertexInfo corner111) {
		BoxShapeBuilder.build(this, corner000, corner010, corner100, corner110, corner001, corner011, corner101, corner111);
	}

	@Override
	@Deprecated
	public void box (Vector3 corner000, Vector3 corner010, Vector3 corner100, Vector3 corner110, Vector3 corner001,
		Vector3 corner011, Vector3 corner101, Vector3 corner111) {
		BoxShapeBuilder.build(this, corner000, corner010, corner100, corner110, corner001, corner011, corner101, corner111);
	}

	@Override
	@Deprecated
	public void box (Matrix4 transform) {
		BoxShapeBuilder.build(this, transform);
	}

	@Override
	@Deprecated
	public void box (float width, float height, float depth) {
		BoxShapeBuilder.build(this, width, height, depth);
	}

	@Override
	@Deprecated
	public void box (float x, float y, float z, float width, float height, float depth) {
		BoxShapeBuilder.build(this, x, y, z, width, height, depth);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ) {
		EllipseShapeBuilder.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal) {
		EllipseShapeBuilder.build(this, radius, divisions, center, normal);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, final Vector3 tangent,
		final Vector3 binormal) {
		EllipseShapeBuilder.build(this, radius, divisions, center, normal, tangent, binormal);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ) {
		EllipseShapeBuilder.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
			tangentY, tangentZ, binormalX, binormalY, binormalZ);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder
			.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, radius, divisions, center, normal, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, final Vector3 tangent,
		final Vector3 binormal, float angleFrom, float angleTo) {
		circle(radius, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, tangent.x, tangent.y, tangent.z,
			binormal.x, binormal.y, binormal.z, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ,
		float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
			tangentY, tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ) {
		EllipseShapeBuilder.build(this, width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal) {
		EllipseShapeBuilder.build(this, width, height, divisions, center, normal);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal,
		final Vector3 tangent, final Vector3 binormal) {
		EllipseShapeBuilder.build(this, width, height, divisions, center, normal, tangent, binormal);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY,
		float binormalZ) {
		EllipseShapeBuilder.build(this, width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
			tangentY, tangentZ, binormalX, binormalY, binormalZ);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, angleFrom,
			angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal, float angleFrom,
		float angleTo) {
		EllipseShapeBuilder.build(this, width, height, divisions, center, normal, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal,
		final Vector3 tangent, final Vector3 binormal, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, divisions, center, normal, tangent, binormal, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY,
		float binormalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
			tangentY, tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, Vector3 center,
		Vector3 normal) {
		EllipseShapeBuilder.build(this, width, height, innerWidth, innerHeight, divisions, center, normal);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, float centerX,
		float centerY, float centerZ, float normalX, float normalY, float normalZ) {
		EllipseShapeBuilder.build(this, width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX,
			normalY, normalZ);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, float centerX,
		float centerY, float centerZ, float normalX, float normalY, float normalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX,
			normalY, normalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, float centerX,
		float centerY, float centerZ, float normalX, float normalY, float normalZ, float tangentX, float tangentY, float tangentZ,
		float binormalX, float binormalY, float binormalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX,
			normalY, normalZ, tangentX, tangentY, tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void cylinder (float width, float height, float depth, int divisions) {
		CylinderShapeBuilder.build(this, width, height, depth, divisions);
	}

	@Override
	@Deprecated
	public void cylinder (float width, float height, float depth, int divisions, float angleFrom, float angleTo) {
		CylinderShapeBuilder.build(this, width, height, depth, divisions, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void cylinder (float width, float height, float depth, int divisions, float angleFrom, float angleTo, boolean close) {
		CylinderShapeBuilder.build(this, width, height, depth, divisions, angleFrom, angleTo, close);
	}

	@Override
	@Deprecated
	public void cone (float width, float height, float depth, int divisions) {
		cone(width, height, depth, divisions, 0, 360);
	}

	@Override
	@Deprecated
	public void cone (float width, float height, float depth, int divisions, float angleFrom, float angleTo) {
		ConeShapeBuilder.build(this, width, height, depth, divisions, angleFrom, angleTo);
	}
	
	@Override
	@Deprecated
	public void sphere (float width, float height, float depth, int divisionsU, int divisionsV) {
		SphereShapeBuilder.build(this, width, height, depth, divisionsU, divisionsV);
	}

	@Override
	@Deprecated
	public void sphere (final Matrix4 transform, float width, float height, float depth, int divisionsU, int divisionsV) {
		SphereShapeBuilder.build(this, transform, width, height, depth, divisionsU, divisionsV);
	}

	@Override
	@Deprecated
	public void sphere (float width, float height, float depth, int divisionsU, int divisionsV, float angleUFrom, float angleUTo,
		float angleVFrom, float angleVTo) {
		SphereShapeBuilder.build(this, width, height, depth, divisionsU, divisionsV, angleUFrom, angleUTo, angleVFrom, angleVTo);
	}

	@Override
	@Deprecated
	public void sphere (final Matrix4 transform, float width, float height, float depth, int divisionsU, int divisionsV,
		float angleUFrom, float angleUTo, float angleVFrom, float angleVTo) {
		SphereShapeBuilder.build(this, transform, width, height, depth, divisionsU, divisionsV, angleUFrom, angleUTo, angleVFrom,
			angleVTo);
	}

	@Override
	@Deprecated
	public void capsule (float radius, float height, int divisions) {
		CapsuleShapeBuilder.build(this, radius, height, divisions);
	}
	
	@Override
	@Deprecated
	public void arrow (float x1, float y1, float z1, float x2, float y2, float z2, float capLength, float stemThickness,
		int divisions) {
		ArrowShapeBuilder.build(this, x1, y1, z1, x2, y2, z2, capLength, stemThickness, divisions);
	}
*/