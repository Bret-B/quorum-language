package Libraries.Game.Graphics

use Libraries.Containers.Array
use Libraries.Game.Graphics.Color
use Libraries.Game.Graphics.TextureRegion
use Libraries.Game.Graphics.VertexAttribute
use Libraries.Game.Graphics.VertexAttributes
use Libraries.Game.Graphics.ModelData.MeshPart
use Libraries.Compute.Math
use Libraries.Compute.Matrix4
use Libraries.Compute.Matrix3
use Libraries.Compute.Vector3
use Libraries.Game.BoundingBox
use Libraries.Game.NumberUtilities

class MeshBuilder 

    /*
    The POINTS value is one of the possible primitive type values. It is used to
    indicate that each vertex of the Mesh should be considered an individual
    point, separate from the other vertices.
    */
    public constant integer POINTS = 0

    /*
    The LINES value is one of the possible primitive type values. The Mesh will
    form lines using pairs of vertices.
    */
    public constant integer LINES = 1

    /*
    The TRIANGLES value is one of the possible primitive type values. The Mesh
    will form triangles from triplets of vertices.
    */
    public constant integer TRIANGLES = 4
    
    // An array used to temporarily store indices during operations.
    private Array<integer> tempIndices

    // An array used to temporarily store vertices during operations.
    private Array<number> tempVertices


    // A collection of temporary VertexBuilder objects used during operations.
    // private VertexBuilder vertTemp1
    // private VertexBuilder vertTemp2
    // private VertexBuilder vertTemp3
    // private VertexBuilder vertTemp4

    // A temporary Color object used during operations.
    private Color tempColor

    // The VertexAttributes of the mesh being constructed.
    private VertexAttributes attributes = undefined

    // The vertices of the mesh being constructed.
    private Array<number> vertices

    // The indices of the mesh being constructed.
    private Array<integer> indices

    // How many number components make up each vertex.
    private integer vertexSize = 0

    // The current vertex index, used for indexing.
    private integer vertexIndex = 0

    // The offset in the indices array when Begin() was called. Used to define a MeshPart.
    private integer indicesStart = 0

    // The count of number components in a vertex before the positional component.
    private integer positionOffset = 0

    // How many number components make up the position attribute.
    private integer positionSize = 0

    //The count of number components in a vertex before the normal component. If there is no normal, this will be -1.
    private integer normalOffset = -1

    // The count of number components in a vertex before the binormal component. If there is no binormal, this will be -1.
    private integer binormalOffset = -1

    // The count of number components in a vertex before the tangent component. If there is no tangent, this will be -1.
    private integer tangentOffset = -1

    // The count of number components in a vertex before the color component. If there is no color, this will be -1.
    private integer colorOffset = -1

    // How many number components make up the color attribute.
    private integer colorSize = 0

    // The count of number components in a vertex before the packed color component, or -1 if there is none.
    private integer colorPackedOffset = -1

    // The count of number components in a vertex before the texture coordinates, or -1 if there are none.
    private integer textureCoordinatesOffset = -1

    // The MeshPart currently under construction.
    private MeshPart part = undefined

    // The MeshParts created between calls to Begin() and End().
    private Array<MeshPart> parts

    // The color used if no vertex color is specified.
    private Color color

    // Whether or not a color has been specified for the vertices.
    private boolean hasColor = false

    // The current primitiveType being used to describe the mesh.
    private integer primitiveType = TRIANGLES

    // The last index which was used during Mesh construction.
    private integer lastIndex = -1

    // The UV range used for texture coordinates during construction.
    private number uOffset = 0
    private number uScale = 1
    private number vOffset = 0
    private number vScale = 1
    private boolean hasUVTransform = false
    private Array<number> vertex = undefined

    private boolean vertexTransformationEnabled = false
    private Matrix4 positionTransform
    private Matrix3 normalTransform
    private BoundingBox bounds

    private Math math
    private NumberUtilities numberUtilities
    private Vector3 calcVector

    /** @param usage bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal and
	 *           TextureCoordinates is supported. *-
	public static VertexAttributes createAttributes (long usage) {
		final Array<VertexAttribute> attrs = new Array<VertexAttribute>();
		if ((usage & Usage.Position) == Usage.Position)
			attrs.add(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE));
		if ((usage & Usage.ColorUnpacked) == Usage.ColorUnpacked)
			attrs.add(new VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE));
		if ((usage & Usage.ColorPacked) == Usage.ColorPacked)
			attrs.add(new VertexAttribute(Usage.ColorPacked, 4, ShaderProgram.COLOR_ATTRIBUTE));
		if ((usage & Usage.Normal) == Usage.Normal)
			attrs.add(new VertexAttribute(Usage.Normal, 3, ShaderProgram.NORMAL_ATTRIBUTE));
		if ((usage & Usage.TextureCoordinates) == Usage.TextureCoordinates)
			attrs.add(new VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + "0"));
		final VertexAttribute attributes[] = new VertexAttribute[attrs.size];
		for (int i = 0; i < attributes.length; i++)
			attributes[i] = attrs.get(i);
		return new VertexAttributes(attributes);
	}

        /** Begin building a mesh. Call {@link #part(String, int)} to start a {@link MeshPart}.
	 * @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal
	 *           and TextureCoordinates is supported. *-
	public void begin (final long attributes) {
		begin(createAttributes(attributes), -1);
	}

        /** Begin building a mesh.
	 * @param attributes bitwise mask of the {@link com.badlogic.gdx.graphics.VertexAttributes.Usage}, only Position, Color, Normal
	 *           and TextureCoordinates is supported. *-
	public void begin (final long attributes, int primitiveType) {
		begin(createAttributes(attributes), primitiveType);
	}
    */

    /*
    This action informs the MeshBuilder to begin constructing a new mesh. If a
    mesh is already in construction, this will throw an error.
    */
    action Begin(VertexAttributes vAttributes)
        Begin(vAttributes, -1)
    end

    /*
    This action informs the MeshBuilder to begin constructing a new mesh. If a
    mesh is already in construction, this will throw an error. The
    VertexAttributes must contain at least a Position attribute, and can also
    contain Normal, Binormal, Tangent, ColorUnpacked, ColorPacked, or
    TextureCoordinates attributes. The type should be one of the primitive type
    constants in the MeshBuilder: POINTS, LINES, or TRIANGLES.
    */
    action Begin(VertexAttributes vAttributes, integer type)
        if attributes not= undefined
            alert("I can't begin building a new Mesh because there is already one under construction!")
        end

        attributes = vAttributes
        vertices:Empty()
        indices:Empty()
        parts:Empty()
        vertexIndex = 0
        lastIndex = -1
        indexStart = 0
        part = undefined
        vertexSize = attributes:vertexSize / 4

        if vertex = undefined or vertex:GetSize() < vertexSize
            Array<number> newVertexArray
            newVertexArray:SetSize(vertexSize)
            vertex = newVertexArray
        end

        VertexAttribute attribute = attributes:FindByUsage(attributes:POSITION)
        if attribute = undefined
            alert("I was told to construct a mesh without a Position attribute, but that attribute is required.")
        end
        positionOffset = attribute:offset / 4
        positionSize = attribute:componentCount

        attribute = attributes:FindByUsage(attributes:NORMAL)
        if attribute = undefined
            normalOffset = -1
        else
            normalOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:BINORMAL)
        if attribute = undefined
            binormalOffset = -1
        else
            binormalOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:TANGENT)
        if attribute = undefined
            tangentOffset = -1
        else
            tangentOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:COLOR_UNPACKED)
        if attribute = undefined
            colorOffset = -1
        else
            colorOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:COLOR_PACKED)
        if attribute = undefined
            colorPackedOffset = -1
        else
            colorPackedOffset = attribute:offset / 4
        end

        attribute = attributes:FindByUsage(attributes:TEXTURE_COORDINATES)
        if attribute = undefined
            textureCoordinatesOffset = -1
        else
            textureCoordinatesOffset = attribute:offset / 4
        end
        
        //SetColor(undefined)
        //SetUVRange(undefined)
        primitiveType = type
        bounds:Invalidate()
    end

    private action EndPart
        if part not= undefined
            /* The following lines of code set fields in the MeshPart that exist
            in libGDX, but that we do not currently use or have.

            part:center = bounds:GetCenter()
            part:halfExtents = bounds:GetDimensions():Scale(0.5)
            part:radius = part:halfExtents:Length()
            */
            bounds:Invalidate()
            part:indexOffset = indicesStart
            part:verticesCount = indices:GetSize() - indicesStart
            indicesStart = indices:GetSize()
            part = undefined
        end
    end

    /*
    This action will start constructing a new MeshPart for the Mesh. The new
    MeshPart will still not be usable until End() is called. This will reset
    any current color and vertex transformations.
    */
    action NewPart(text id, integer type) returns MeshPart
        if attributes = undefined
            alert("I can't begin constructing a new MeshPart if I'm not currently building a Mesh. Call Begin() before using NewPart().")
        end
        EndPart()

        MeshPart newPart
        part = newPart
        part:id = id
        primitiveType = type
        part:primitiveType = type
        parts:Add(part)

        //SetColor(undefined)
        //SetVertexTransform(undefined)
        //SetUVRange(undefined)
        
        return part
    end
    
    /*
    This action will finish construction of the current Mesh, and then return it.
    */
    action End returns Mesh
        if attributes = undefined
            alert("I must begin constructing a Mesh before I can finish it - call Begin() first.")
        end

        Mesh newMesh
        newMesh:Load(true, vertices:GetSize() / vertexSize, indices:GetSize(), attributes)

        EndPart()
        
        newMesh:SetVertices(vertices)
        newMesh:SetIndices(indices)

        integer counter = 0
        MeshPart meshPart = undefined
        repeat parts:GetSize() times
            meshPart = parts:Get(counter)
            meshPart:mesh = newMesh
            counter = counter + 1
        end
        parts:Empty()

        attributes = undefined
        vertices:Empty()
        indices:Empty()

        return newMesh
    end

    /*
    Empties the data being built up until now, including the vertices, indices,
    and all parts. Must be called between Begin() and End() to have any effect.
    This effectively discards all work done since the initial Begin(), but will
    not reset state such as UV region, color, or vertex transform.
    */
    action Empty
        vertices:Empty()
        indices:Empty()
        parts:Empty()
        vertexIndex = 0
        lastIndex = -1
        indicesStart = 0
        part = undefined
    end

    /*
    This action will return the amount of number components that makes up each
    vertex.
    */
    action GetVertexSize returns integer
        return vertexSize
    end

    /*
    This action returns the number of vertices that have been built so far for
    the current Mesh under construction. This will only return a valid result
    if used between calls to Begin() and End().
    */
    action GetVerticesCount returns number
        return vertices:GetSize() / vertexSize
    end

    /*
    This action will return a copy of all of the vertices built so far. This
    action must be called between Begin() and End() - otherwise, an error will
    be thrown.
    */
    action GetVertices returns Array<number>
        return vertices
    end

    /*
    This action will return the number of indices that has been built so far in
    the Mesh currently under construction. This is only valid between calls to
    Begin() and End().
    */
    action GetIndicesCount returns integer
        return indices:GetSize()
    end

    /*
    This action will return a copy of the indices that have been built so far.
    This action is only valid between calls to Begin() and End() - otherwise,
    this action will throw an error.
    */
    action GetIndices returns Array<integer>
        return indices
    end

    /*
    This action will return the attributes that were given for the current Mesh
    under construction. If there isn't a Mesh currently being built, this will
    be undefined.
    */
    action GetAttributes returns VertexAttributes
        return attributes
    end

    /*
    This action will return the MeshPart currently under construction by the
    MeshBuilder. If there isn't a MeshPart under construction, then this will be
    undefined.
    */
    action GetMeshPart returns MeshPart
        return part
    end

    /*
    This action will return the primitive type being used to define the geometry
    of the current Mesh under construction. The primitive type is an integer 
    value that represents an OpenGL constant, such as TRIANGLES.
    */
    action GetPrimitiveType returns integer
        return primitiveType
    end

    /*
    This action will set the color value of the vertices that are created during
    Mesh construction. The color is made of a red, green, blue, and alpha (or
    transparency) component.
    */
    action SetColor(number red, number green, number blue, number alpha)
        color:SetColor(red, green, blue, alpha)
        hasColor = not (red = 1.0 and green = 1.0 and blue = 1.0 and alpha = 1.0)
    end

    /*
    This action will set the color value of the vertices that are created during
    Mesh construction.
    */
    action SetColor(Color newColor)
        color:SetColor(newColor:GetRed(), newColor:GetGreen(), newColor:GetBlue(), newColor:GetAlpha())
        hasColor = not (newColor:GetRed() = 1.0 and newColor:GetGreen() = 1.0 and newColor:GetBlue() = 1.0 and newColor:GetAlpha() = 1.0)
    end

    // TO-DO: Better clarify what this action does.
    /*
    This action will set the UV range that will be applied to the vertices of
    the Mesh under construction. The UV values are used to determine how a 
    texture should be mapped onto the Mesh.
    */
    action SetUVRange(number u1, number v1, number u2, number v2)
        uOffset = u1
        vOffset = v1
        uScale = u2 - u1
        vScale = v2 - v1
        number errorMargin = 0.000001
        hasUVTransform = not (math:AbsoluteValue(u1) < errorMargin
                          and math:AbsoluteValue(v1) < errorMargin
                          and math:AbsoluteValue(u2 - 1.0) < errorMargin
                          and math:AbsoluteValue(v2 - 1.0) < errorMargin)
    end

    // TO-DO: Better clarify what this action does.
    /*
    This action will set the UV range that will be applied to the vertices of
    the Mesh under construction. The UV values are used to determine how a 
    texture should be mapped onto the Mesh.
    */
    action SetUVRange(TextureRegion region)
        if region = undefined
            hasUVTransform = false
            uOffset = 0
            vOffset = 0
            uScale = 1
            vScale = 1
        else
            SetUVRange(region:GetLeftSide(), region:GetTopSide(), region:GetRightSide(), region:GetBottomSide())
        end
    end

    /*
    This action will return a new Matrix4 object containing a copy of the vertex
    transformation matrix that the current Mesh being built is using.
    */
    action GetVertexTransform returns Matrix4
        Matrix4 new
        new:Set(positionTransform)
        return new
    end

    /*
    This action will set the transformation matrix for the vertices of the Mesh
    that is under construction.
    */
    action SetVertexTransform(Matrix4 transform)
        if transform not= undefined
            vertexTransformationEnabled = true
            positionTransform:Set(transform)
            normalTransform:Set(transform):Inverse():Transpose()
        else
            vertexTransformationEnabled = false
            positionTransform:IdentityMatrix()
            normalTransform:IdentityMatrix()
        end
    end

    /*
    This action will return whether or not the Mesh under construction is
    currently using a Matrix4 to transform its vertices.
    */
    action IsVertexTransformationEnabled returns boolean
        return vertexTransformationEnabled
    end

    /*
    This action will set the MeshBuilder to allow for vertex transformation
    using a Matrix4 object.
    */
    action SetVertexTransformationEnabled(boolean enabled)
        vertexTransformationEnabled = enabled
    end

    /*
    This action will ensure that the current Mesh under construction will
    support the given number of vertices.
    */
    action EnsureVerticesCapacity(integer numVertices)
        vertices:SetMaxSize(numVertices * vertexSize)
    end

    /*
    This action will ensure that the current Mesh under construction will
    support the given number of indices.
    */
    action EnsureIndices(integer numIndices)
        indices:SetMaxSize(numIndices)
    end

    /*
    This action will guarantee that the Mesh under construction will have the
    proper number of indices to form the given number of triangles, based on
    what primitive type has already been set for the Mesh.
    */
    action EnsureTriangleIndices(integer numTriangles)
        if primitiveType = LINES
            EnsureIndices(6 * numTriangles)
        elseif primitiveType = TRIANGLES or primitiveType = POINTS
            EnsureIndices(3 * numTriangles)
        else
            alert("The MeshBuilder was given an invalid primitive type - the supported values are the POINTS, LINES, or TRIANGLES constants.")
        end
    end
  
    /*
    This action will guarantee that the Mesh under construction will have the
    proper number of indices to form the given number of rectangles, based on
    what primitive type has already been set for the Mesh.
    */
    action EnsureRectangleIndices(integer numRectangles)
        if primitiveType = POINTS
            EnsureIndices(4 * numRectangles)
        elseif primitiveType = LINES
            EnsureIndices(8 * numRectangles)
        elseif primitiveType = TRIANGLES
            EnsureIndices(6 * numRectangles)
        else
            alert("The MeshBuilder was given an invalid primitive type - the supported values are the POINTS, LINES, or TRIANGLES constants.")
        end
    end

    /*
    This action will return what the last index used was during the construction
    of a Mesh.
    */
    action GetLastIndex returns integer
        return lastIndex
    end
    
    private action TransformPosition(Array<number> values, integer offset, integer size, Matrix4 transform)
        if size > 2
            calcVector:Set(values:Get(offset), values:Get(offset + 1), values:Get(offset + 2))
            calcVector:Multiply(transform)
            values:Set(offset, calcVector:GetX())
            values:Set(offset + 1, calcVector:GetY())
            values:Set(offset + 2, calcVector:GetZ())
        elseif size > 1
            calcVector:Set(values:Get(offset), values:Get(offset + 1), 0)
            calcVector:Multiply(transform)
            values:Set(offset, calcVector:GetX())
            values:Set(offset + 1, calcVector:GetY())
        else
            calcVector:Set(values:Get(offset), 0, 0)
            calcVector:Multiply(transform)
            values:Set(offset, calcVector:GetX())
        end
    end

    private action TransformNormal(Array<number> values, integer offset, integer size, Matrix3 transform)
        if size > 2
            calcVector:Set(values:Get(offset), values:Get(offset + 1), values:Get(offset + 2))
            calcVector:Multiply(transform)
            calcVector:Normalize()
            values:Set(offset, calcVector:GetX())
            values:Set(offset + 1, calcVector:GetY())
            values:Set(offset + 2, calcVector:GetZ())
        elseif size > 1
            calcVector:Set(values:Get(offset), values:Get(offset + 1), 0)
            calcVector:Multiply(transform)
            calcVector:Normalize()
            values:Set(offset, calcVector:GetX())
            values:Set(offset + 1, calcVector:GetY())
        else
            calcVector:Set(values:Get(offset), 0, 0)
            calcVector:Multiply(transform)
            calcVector:Normalize()
            values:Set(offset, calcVector:GetX())
        end
    end

    private action AddVertex(Array<number> values, integer offset)
        integer originalSize = vertices:GetSize()
        
        integer counter = 0
        repeat values:GetSize() times
            vertices:Add(values:Get(counter))
            counter = counter + 1
        end

        lastIndex = vertexIndex

        if vertexTransformationEnabled
            TransformPosition(vertices, originalSize + positionOffset, positionSize, positionTransform)
            
            if normalOffset >= 0
                TransformNormal(vertices, originalSize + normalOffset, 3, normalTransform)
            end

            if binormalOffset >= 0
                TransformNormal(vertices, originalSize + binormalOffset, 3, normalTransform)
            end

            if tangentOffset >= 0
                TransformNormal(vertices, originalSize + tangentOffset, 3, normalTransform)
            end
        end

        number x = vertices:Get(originalSize + positionOffset)
        number y = 0
        number z = 0
        if positionSize > 1
            y = vertices:Get(originalSize + positionOffset + 1)
            if positionSize > 2
                z = vertices:Get(originalSize + positionOffset + 2)
            end
        end
        bounds:Extend(x, y, z)

        if hasColor
            if colorOffset >= 0
                vertices:Set(originalSize + colorOffset, vertices:Get(originalSize + colorOffset) * color:GetRed())
                vertices:Set(originalSize + colorOffset + 1, vertices:Get(originalSize + colorOffset + 1) * color:GetGreen())
                vertices:Set(originalSize + colorOffset + 2, vertices:Get(originalSize + colorOffset + 2) * color:GetBlue())
                if colorSize > 3
                    vertices:Set(originalSize + colorOffset + 3, vertices:Get(originalSize + colorOffset + 3) * color:GetAlpha())
                end
            elseif colorPackedOffset >= 0
                tempColor:SetColorFromCode(numberUtilities:EncodeNumberAsInteger(vertices:Get(originalSize + colorPackedOffset)))
                tempColor:SetColor(tempColor:GetRed() * color:GetRed(), tempColor:GetGreen() * color:GetGreen(),
                    tempColor:GetBlue() * color:GetBlue(), tempColor:GetAlpha() * color:GetAlpha())

                vertices:Set(originalSize + colorPackedOffset, tempColor:EncodeColorAsNumber())
            end
        end

        if hasUVTransform and textureCoordinatesOffset >= 0
            vertices:Set(originalSize + textureCoordinatesOffset, uOffset + uScale * vertices:Get(originalSize + textureCoordinatesOffset))
            vertices:Set(originalSize + textureCoordinatesOffset + 1, vOffset + vScale * vertices:Get(originalSize + textureCoordinatesOffset + 1))
        end
    end

end

/*

	private final void addVertex (final float[] values, final int offset) {
		final int o = vertices.size;
		vertices.addAll(values, offset, stride);
		lastIndex = (short)(vindex++);

		if (vertexTransformationEnabled) {
			transformPosition(vertices.items, o + posOffset, posSize, positionTransform);
			if (norOffset >= 0) transformNormal(vertices.items, o + norOffset, 3, normalTransform);
			if (biNorOffset >= 0) transformNormal(vertices.items, o + biNorOffset, 3, normalTransform);
			if (tangentOffset >= 0) transformNormal(vertices.items, o + tangentOffset, 3, normalTransform);
		}

		final float x = vertices.items[o + posOffset];
		final float y = (posSize > 1) ? vertices.items[o + posOffset + 1] : 0f;
		final float z = (posSize > 2) ? vertices.items[o + posOffset + 2] : 0f;
		bounds.ext(x, y, z);

		if (hasColor) {
			if (colOffset >= 0) {
				vertices.items[o + colOffset] *= color.r;
				vertices.items[o + colOffset + 1] *= color.g;
				vertices.items[o + colOffset + 2] *= color.b;
				if (colSize > 3) vertices.items[o + colOffset + 3] *= color.a;
			} else if (cpOffset >= 0) {
				vertices.items[o + cpOffset] = tempC1.set(NumberUtils.floatToIntColor(vertices.items[o + cpOffset])).mul(color)
					.toFloatBits();
			}
		}

		if (hasUVTransform && uvOffset >= 0) {
			vertices.items[o + uvOffset] = uOffset + uScale * vertices.items[o + uvOffset];
			vertices.items[o + uvOffset + 1] = vOffset + vScale * vertices.items[o + uvOffset + 1];
		}
	}

	private final Vector3 tmpNormal = new Vector3();

	@Override
	public short vertex (Vector3 pos, Vector3 nor, Color col, Vector2 uv) {
		if (vindex >= Short.MAX_VALUE) throw new GdxRuntimeException("Too many vertices used");

		vertex[posOffset] = pos.x;
		if (posSize > 1) vertex[posOffset + 1] = pos.y;
		if (posSize > 2) vertex[posOffset + 2] = pos.z;

		if (norOffset >= 0) {
			if (nor == null) nor = tmpNormal.set(pos).nor();
			vertex[norOffset] = nor.x;
			vertex[norOffset + 1] = nor.y;
			vertex[norOffset + 2] = nor.z;
		}

		if (colOffset >= 0) {
			if (col == null) col = Color.WHITE;
			vertex[colOffset] = col.r;
			vertex[colOffset + 1] = col.g;
			vertex[colOffset + 2] = col.b;
			if (colSize > 3) vertex[colOffset + 3] = col.a;
		} else if (cpOffset > 0) {
			if (col == null) col = Color.WHITE;
			vertex[cpOffset] = col.toFloatBits(); // FIXME cache packed color?
		}

		if (uv != null && uvOffset >= 0) {
			vertex[uvOffset] = uv.x;
			vertex[uvOffset + 1] = uv.y;
		}

		addVertex(vertex, 0);
		return lastIndex;
	}

	@Override
	public short vertex (final float... values) {
		final int n = values.length - stride;
		for (int i = 0; i <= n; i += stride)
			addVertex(values, i);
		return lastIndex;
	}

	@Override
	public short vertex (final VertexInfo info) {
		return vertex(info.hasPosition ? info.position : null, info.hasNormal ? info.normal : null, info.hasColor ? info.color
			: null, info.hasUV ? info.uv : null);
	}

	@Override
	public void index (final short value) {
		indices.add(value);
	}

	@Override
	public void index (final short value1, final short value2) {
		ensureIndices(2);
		indices.add(value1);
		indices.add(value2);
	}

	@Override
	public void index (final short value1, final short value2, final short value3) {
		ensureIndices(3);
		indices.add(value1);
		indices.add(value2);
		indices.add(value3);
	}

	@Override
	public void index (final short value1, final short value2, final short value3, final short value4) {
		ensureIndices(4);
		indices.add(value1);
		indices.add(value2);
		indices.add(value3);
		indices.add(value4);
	}

	@Override
	public void index (short value1, short value2, short value3, short value4, short value5, short value6) {
		ensureIndices(6);
		indices.add(value1);
		indices.add(value2);
		indices.add(value3);
		indices.add(value4);
		indices.add(value5);
		indices.add(value6);
	}

	@Override
	public void index (short value1, short value2, short value3, short value4, short value5, short value6, short value7,
		short value8) {
		ensureIndices(8);
		indices.add(value1);
		indices.add(value2);
		indices.add(value3);
		indices.add(value4);
		indices.add(value5);
		indices.add(value6);
		indices.add(value7);
		indices.add(value8);
	}

	@Override
	public void line (short index1, short index2) {
		if (primitiveType != GL20.GL_LINES) throw new GdxRuntimeException("Incorrect primitive type");
		index(index1, index2);
	}

	@Override
	public void line (VertexInfo p1, VertexInfo p2) {
		ensureVertices(2);
		line(vertex(p1), vertex(p2));
	}

	@Override
	public void line (Vector3 p1, Vector3 p2) {
		line(vertTmp1.set(p1, null, null, null), vertTmp2.set(p2, null, null, null));
	}

	@Override
	public void line (float x1, float y1, float z1, float x2, float y2, float z2) {
		line(vertTmp1.set(null, null, null, null).setPos(x1, y1, z1), vertTmp2.set(null, null, null, null).setPos(x2, y2, z2));
	}

	@Override
	public void line (Vector3 p1, Color c1, Vector3 p2, Color c2) {
		line(vertTmp1.set(p1, null, c1, null), vertTmp2.set(p2, null, c2, null));
	}

	@Override
	public void triangle (short index1, short index2, short index3) {
		if (primitiveType == GL20.GL_TRIANGLES || primitiveType == GL20.GL_POINTS) {
			index(index1, index2, index3);
		} else if (primitiveType == GL20.GL_LINES) {
			index(index1, index2, index2, index3, index3, index1);
		} else
			throw new GdxRuntimeException("Incorrect primitive type");
	}

	@Override
	public void triangle (VertexInfo p1, VertexInfo p2, VertexInfo p3) {
		ensureVertices(3);
		triangle(vertex(p1), vertex(p2), vertex(p3));
	}

	@Override
	public void triangle (Vector3 p1, Vector3 p2, Vector3 p3) {
		triangle(vertTmp1.set(p1, null, null, null), vertTmp2.set(p2, null, null, null), vertTmp3.set(p3, null, null, null));
	}

	@Override
	public void triangle (Vector3 p1, Color c1, Vector3 p2, Color c2, Vector3 p3, Color c3) {
		triangle(vertTmp1.set(p1, null, c1, null), vertTmp2.set(p2, null, c2, null), vertTmp3.set(p3, null, c3, null));
	}

	@Override
	public void rect (short corner00, short corner10, short corner11, short corner01) {
		if (primitiveType == GL20.GL_TRIANGLES) {
			index(corner00, corner10, corner11, corner11, corner01, corner00);
		} else if (primitiveType == GL20.GL_LINES) {
			index(corner00, corner10, corner10, corner11, corner11, corner01, corner01, corner00);
		} else if (primitiveType == GL20.GL_POINTS) {
			index(corner00, corner10, corner11, corner01);
		} else
			throw new GdxRuntimeException("Incorrect primitive type");
	}

	@Override
	public void rect (VertexInfo corner00, VertexInfo corner10, VertexInfo corner11, VertexInfo corner01) {
		ensureVertices(4);
		rect(vertex(corner00), vertex(corner10), vertex(corner11), vertex(corner01));
	}

	@Override
	public void rect (Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal) {
		rect(vertTmp1.set(corner00, normal, null, null).setUV(0f, 1f), vertTmp2.set(corner10, normal, null, null).setUV(1f, 1f),
			vertTmp3.set(corner11, normal, null, null).setUV(1f, 0f), vertTmp4.set(corner01, normal, null, null).setUV(0f, 0f));
	}

	@Override
	public void rect (float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11,
		float x01, float y01, float z01, float normalX, float normalY, float normalZ) {
		rect(vertTmp1.set(null, null, null, null).setPos(x00, y00, z00).setNor(normalX, normalY, normalZ).setUV(0f, 1f), vertTmp2
			.set(null, null, null, null).setPos(x10, y10, z10).setNor(normalX, normalY, normalZ).setUV(1f, 1f),
			vertTmp3.set(null, null, null, null).setPos(x11, y11, z11).setNor(normalX, normalY, normalZ).setUV(1f, 0f), vertTmp4
				.set(null, null, null, null).setPos(x01, y01, z01).setNor(normalX, normalY, normalZ).setUV(0f, 0f));
	}

	@Override
	public void addMesh (Mesh mesh) {
		addMesh(mesh, 0, mesh.getNumIndices());
	}

	@Override
	public void addMesh (MeshPart meshpart) {
		if (meshpart.primitiveType != primitiveType) throw new GdxRuntimeException("Primitive type doesn't match");
		addMesh(meshpart.mesh, meshpart.offset, meshpart.size);
	}

	@Override
	public void addMesh (Mesh mesh, int indexOffset, int numIndices) {
		if (!attributes.equals(mesh.getVertexAttributes())) throw new GdxRuntimeException("Vertex attributes do not match");
		if (numIndices <= 0) return; // silently ignore an empty mesh part

		// FIXME don't triple copy, instead move the copy to jni
		int numFloats = mesh.getNumVertices() * stride;
		tmpVertices.clear();
		tmpVertices.ensureCapacity(numFloats);
		tmpVertices.size = numFloats;
		mesh.getVertices(tmpVertices.items);

		tmpIndices.clear();
		tmpIndices.ensureCapacity(numIndices);
		tmpIndices.size = numIndices;
		mesh.getIndices(indexOffset, numIndices, tmpIndices.items, 0);

		addMesh(tmpVertices.items, tmpIndices.items, 0, numIndices);
	}

	private static IntIntMap indicesMap = null;

	@Override
	public void addMesh (float[] vertices, short[] indices, int indexOffset, int numIndices) {
		if (indicesMap == null)
			indicesMap = new IntIntMap(numIndices);
		else {
			indicesMap.clear();
			indicesMap.ensureCapacity(numIndices);
		}
		ensureIndices(numIndices);
		final int numVertices = vertices.length / stride;
		ensureVertices(numVertices < numIndices ? numVertices : numIndices);
		for (int i = 0; i < numIndices; i++) {
			final int sidx = indices[indexOffset + i];
			int didx = indicesMap.get(sidx, -1);
			if (didx < 0) {
				addVertex(vertices, sidx * stride);
				indicesMap.put(sidx, didx = lastIndex);
			}
			index((short)didx);
		}
	}

	@Override
	public void addMesh (float[] vertices, short[] indices) {
		final short offset = (short)(lastIndex + 1);

		final int numVertices = vertices.length / stride;
		ensureVertices(numVertices);
		for (int v = 0; v < vertices.length; v += stride)
			addVertex(vertices, v);

		ensureIndices(indices.length);
		for (int i = 0; i < indices.length; ++i)
			index((short)(indices[i] + offset));
	}

	
	// TODO: The following methods are deprecated and will be removed in a future release
	
	@Override
	@Deprecated
	public void patch (VertexInfo corner00, VertexInfo corner10, VertexInfo corner11, VertexInfo corner01, int divisionsU,
		int divisionsV) {
		PatchShapeBuilder.build(this, corner00, corner10, corner11, corner01, divisionsU, divisionsV);
	}

	@Override
	@Deprecated
	public void patch (Vector3 corner00, Vector3 corner10, Vector3 corner11, Vector3 corner01, Vector3 normal, int divisionsU,
		int divisionsV) {
		PatchShapeBuilder.build(this, corner00, corner10, corner11, corner01, normal, divisionsU, divisionsV);
	}

	@Override
	@Deprecated
	public void patch (float x00, float y00, float z00, float x10, float y10, float z10, float x11, float y11, float z11,
		float x01, float y01, float z01, float normalX, float normalY, float normalZ, int divisionsU, int divisionsV) {
		PatchShapeBuilder.build(this, x00, y00, z00, x10, y10, z10, x11, y11, z11, x01, y01, z01, normalX, normalY, normalZ, divisionsU, divisionsV);
	}
	
	@Override
	@Deprecated
	public void box (VertexInfo corner000, VertexInfo corner010, VertexInfo corner100, VertexInfo corner110, VertexInfo corner001,
		VertexInfo corner011, VertexInfo corner101, VertexInfo corner111) {
		BoxShapeBuilder.build(this, corner000, corner010, corner100, corner110, corner001, corner011, corner101, corner111);
	}

	@Override
	@Deprecated
	public void box (Vector3 corner000, Vector3 corner010, Vector3 corner100, Vector3 corner110, Vector3 corner001,
		Vector3 corner011, Vector3 corner101, Vector3 corner111) {
		BoxShapeBuilder.build(this, corner000, corner010, corner100, corner110, corner001, corner011, corner101, corner111);
	}

	@Override
	@Deprecated
	public void box (Matrix4 transform) {
		BoxShapeBuilder.build(this, transform);
	}

	@Override
	@Deprecated
	public void box (float width, float height, float depth) {
		BoxShapeBuilder.build(this, width, height, depth);
	}

	@Override
	@Deprecated
	public void box (float x, float y, float z, float width, float height, float depth) {
		BoxShapeBuilder.build(this, x, y, z, width, height, depth);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ) {
		EllipseShapeBuilder.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal) {
		EllipseShapeBuilder.build(this, radius, divisions, center, normal);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, final Vector3 tangent,
		final Vector3 binormal) {
		EllipseShapeBuilder.build(this, radius, divisions, center, normal, tangent, binormal);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ) {
		EllipseShapeBuilder.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
			tangentY, tangentZ, binormalX, binormalY, binormalZ);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder
			.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, radius, divisions, center, normal, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, final Vector3 center, final Vector3 normal, final Vector3 tangent,
		final Vector3 binormal, float angleFrom, float angleTo) {
		circle(radius, divisions, center.x, center.y, center.z, normal.x, normal.y, normal.z, tangent.x, tangent.y, tangent.z,
			binormal.x, binormal.y, binormal.z, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void circle (float radius, int divisions, float centerX, float centerY, float centerZ, float normalX, float normalY,
		float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY, float binormalZ,
		float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, radius, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
			tangentY, tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ) {
		EllipseShapeBuilder.build(this, width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal) {
		EllipseShapeBuilder.build(this, width, height, divisions, center, normal);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal,
		final Vector3 tangent, final Vector3 binormal) {
		EllipseShapeBuilder.build(this, width, height, divisions, center, normal, tangent, binormal);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY,
		float binormalZ) {
		EllipseShapeBuilder.build(this, width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
			tangentY, tangentZ, binormalX, binormalY, binormalZ);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, angleFrom,
			angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal, float angleFrom,
		float angleTo) {
		EllipseShapeBuilder.build(this, width, height, divisions, center, normal, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, final Vector3 center, final Vector3 normal,
		final Vector3 tangent, final Vector3 binormal, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, divisions, center, normal, tangent, binormal, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, int divisions, float centerX, float centerY, float centerZ, float normalX,
		float normalY, float normalZ, float tangentX, float tangentY, float tangentZ, float binormalX, float binormalY,
		float binormalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, divisions, centerX, centerY, centerZ, normalX, normalY, normalZ, tangentX,
			tangentY, tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, Vector3 center,
		Vector3 normal) {
		EllipseShapeBuilder.build(this, width, height, innerWidth, innerHeight, divisions, center, normal);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, float centerX,
		float centerY, float centerZ, float normalX, float normalY, float normalZ) {
		EllipseShapeBuilder.build(this, width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX,
			normalY, normalZ);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, float centerX,
		float centerY, float centerZ, float normalX, float normalY, float normalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX,
			normalY, normalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void ellipse (float width, float height, float innerWidth, float innerHeight, int divisions, float centerX,
		float centerY, float centerZ, float normalX, float normalY, float normalZ, float tangentX, float tangentY, float tangentZ,
		float binormalX, float binormalY, float binormalZ, float angleFrom, float angleTo) {
		EllipseShapeBuilder.build(this, width, height, innerWidth, innerHeight, divisions, centerX, centerY, centerZ, normalX,
			normalY, normalZ, tangentX, tangentY, tangentZ, binormalX, binormalY, binormalZ, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void cylinder (float width, float height, float depth, int divisions) {
		CylinderShapeBuilder.build(this, width, height, depth, divisions);
	}

	@Override
	@Deprecated
	public void cylinder (float width, float height, float depth, int divisions, float angleFrom, float angleTo) {
		CylinderShapeBuilder.build(this, width, height, depth, divisions, angleFrom, angleTo);
	}

	@Override
	@Deprecated
	public void cylinder (float width, float height, float depth, int divisions, float angleFrom, float angleTo, boolean close) {
		CylinderShapeBuilder.build(this, width, height, depth, divisions, angleFrom, angleTo, close);
	}

	@Override
	@Deprecated
	public void cone (float width, float height, float depth, int divisions) {
		cone(width, height, depth, divisions, 0, 360);
	}

	@Override
	@Deprecated
	public void cone (float width, float height, float depth, int divisions, float angleFrom, float angleTo) {
		ConeShapeBuilder.build(this, width, height, depth, divisions, angleFrom, angleTo);
	}
	
	@Override
	@Deprecated
	public void sphere (float width, float height, float depth, int divisionsU, int divisionsV) {
		SphereShapeBuilder.build(this, width, height, depth, divisionsU, divisionsV);
	}

	@Override
	@Deprecated
	public void sphere (final Matrix4 transform, float width, float height, float depth, int divisionsU, int divisionsV) {
		SphereShapeBuilder.build(this, transform, width, height, depth, divisionsU, divisionsV);
	}

	@Override
	@Deprecated
	public void sphere (float width, float height, float depth, int divisionsU, int divisionsV, float angleUFrom, float angleUTo,
		float angleVFrom, float angleVTo) {
		SphereShapeBuilder.build(this, width, height, depth, divisionsU, divisionsV, angleUFrom, angleUTo, angleVFrom, angleVTo);
	}

	@Override
	@Deprecated
	public void sphere (final Matrix4 transform, float width, float height, float depth, int divisionsU, int divisionsV,
		float angleUFrom, float angleUTo, float angleVFrom, float angleVTo) {
		SphereShapeBuilder.build(this, transform, width, height, depth, divisionsU, divisionsV, angleUFrom, angleUTo, angleVFrom,
			angleVTo);
	}

	@Override
	@Deprecated
	public void capsule (float radius, float height, int divisions) {
		CapsuleShapeBuilder.build(this, radius, height, divisions);
	}
	
	@Override
	@Deprecated
	public void arrow (float x1, float y1, float z1, float x2, float y2, float z2, float capLength, float stemThickness,
		int divisions) {
		ArrowShapeBuilder.build(this, x1, y1, z1, x2, y2, z2, capLength, stemThickness, divisions);
	}
*/