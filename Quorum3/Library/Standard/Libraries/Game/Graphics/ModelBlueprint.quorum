package Libraries.Game.Graphics

//import com.badlogic.gdx.graphics.GL20;
//import com.badlogic.gdx.graphics.Mesh;
use Libraries.Game.Graphics.Texture
use Libraries.Game.Graphics.ColorAttribute
use Libraries.Game.Graphics.NumberAttribute
use Libraries.Game.Graphics.BlendingAttribute
use Libraries.Game.Graphics.TextureAttribute
use Libraries.Game.Graphics.TextureDescriptor
//import com.badlogic.gdx.graphics.VertexAttributes;
//import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
//import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
//import com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute;
//import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
use Libraries.Game.Graphics.ModelData.all
//import com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor;
//import com.badlogic.gdx.graphics.g3d.utils.TextureProvider;
//import com.badlogic.gdx.graphics.g3d.utils.TextureProvider.FileTextureProvider;
use Libraries.Compute.Matrix4
use Libraries.Compute.Quaternion
use Libraries.Compute.Vector3
//import com.badlogic.gdx.math.collision.BoundingBox;
//import com.badlogic.gdx.utils.ArrayMap;
//import com.badlogic.gdx.utils.BufferUtils;
use Libraries.Game.Disposable
use Libraries.Containers.Array
use Libraries.Containers.HashTable
use Libraries.Containers.Blueprints.Iterator

class ModelBlueprint is Disposable
    public Array<Material> materials
    public Array<Node> nodes
    public Array<Animation> animations
    public Array<Mesh> meshes
    public Array<MeshPart> meshParts
    public Array<Disposable> disposables
    // JAVA:
    //private ObjectMap<NodePart, ArrayMap<String, Matrix4>> nodePartBones = new ObjectMap<NodePart, ArrayMap<String, Matrix4>>();

    action Load(ModelData data)
        LoadMeshes(data:meshes)
        LoadMaterials(data:materials)
    //    JAVA:
    //    loadMeshes(modelData.meshes);
    //    loadMaterials(modelData.materials, textureProvider);
    //    loadNodes(modelData.nodes);
    //    loadAnimations(modelData.animations);
    //    calculateTransforms();
    end

    private action LoadMeshes(Array<ModelMesh> meshes)
        integer counter = 0
        repeat meshes:GetSize() times
            ConvertMesh(meshes:Get(counter))
            counter = counter + 1
        end
    end

    private action ConvertMesh(ModelMesh modelMesh)
        integer indicesCount = 0
        integer index = 0
        
        repeat modelMesh:parts:GetSize() times
            ModelMeshPart part = modelMesh:parts:Get(index)
            indicesCount = indicesCount + part:indices:GetSize()
            index = index + 1
        end

        VertexAttributes attributes
        attributes:SetAttributes(modelMesh:attributes)
        integer verticesCount = modelMesh:vertices:GetSize() / (attributes:vertexSize / 4)

        Mesh mesh
        mesh:Load(true, verticesCount, indicesCount, attributes)
        meshes:Add(mesh)
        disposables:Add(mesh)

        mesh:GetVertexData():FillVertexBuffer(modelMesh:vertices)
        mesh:GetIndexData():Clear()

        integer offset = 0
        index = 0
        repeat modelMesh:parts:GetSize() times
            ModelMeshPart part = modelMesh:parts:Get(index)
            MeshPart meshPart
            meshPart:id = part:id
            meshPart:primitiveType = part:primitiveType
            meshPart:indexOffset = offset
            meshPart:verticesCount = part:indices:GetSize()
            mesh:GetIndexData():Put(part:indices)
            offset = offset + meshPart:verticesCount
            meshParts:Add(meshPart)
        end

        mesh:GetIndexData():SetPosition(0)
    end

    private action LoadMaterials(Array<ModelMaterial> modelMaterials)
        integer counter = 0
        repeat modelMaterials:GetSize() times
            materials:Add(ConvertMaterial(modelMaterials:Get(counter)))
            counter = counter + 1
        end
    end

    private action ConvertMaterial(ModelMaterial mtl) returns Material

        Material result
        result:id = mtl:id

        ColorAttribute creator

        if mtl:ambient not= undefined
            result:Add(creator:CreateAmbient(mtl:ambient))
        end
        if mtl:diffuse not= undefined
            result:Add(creator:CreateDiffuse(mtl:diffuse))
        end
        if mtl:specular not= undefined
            result:Add(creator:CreateSpecular(mtl:specular))
        end
        if mtl:emissive not= undefined
            result:Add(creator:CreateEmissive(mtl:emissive))
        end
        if mtl:reflection not= undefined
            result:Add(creator:CreateReflection(mtl:reflection))
        end
        if mtl:shininess > 0
            NumberAttribute temp
            temp:SetAttribute(temp:GetShininessValue(), mtl:shininess)
            result:Add(temp)
        end
        if mtl:opacity not= 1.0
            BlendingAttribute temp
            temp:opacity = mtl:opacity
            result:Add(temp)
        end
        
        // JAVA:
        // ObjectMap<String, Texture> textures = new ObjectMap<String, Texture>();
        HashTable<text, Texture> textures

        // Comment from libGDX:
        // FIXME uvScaling/uvTranslation totally ignored
        
        if mtl:textures not= undefined
            integer counter = 0
            ModelTextureData tex = undefined
            repeat mtl:textures:GetSize() times
                tex = mtl:textures:Get(counter)
                
                Texture texture = undefined
                if textures:HasKey(tex:fileName)
                    texture = textures:GetValue(tex:fileName)
                else
                    Texture newTexture
                    texture = newTexture
                    texture:LoadModelTexture(tex:fileName)
                    textures:Add(tex:fileName, texture)
                    disposables:Add(texture)
                end

                TextureDescriptor descriptor
                descriptor:minFilter:ConstructTextureFilter(texture:GetMinimizeFilter():GetValue())
                descriptor:magFilter:ConstructTextureFilter(texture:GetMagnifyFilter():GetValue())
                descriptor:uWrap:ConstructTextureWrap(texture:GetHorizontalWrap():GetValue())
                descriptor:vWrap:ConstructTextureWrap(texture:GetVerticalWrap():GetValue())
                
                number offsetU = 0
                number offsetV = 0
                number scaleU = 1
                number scaleV = 1
                if tex:uvTranslation not= undefined
                    offsetU = tex:uvTranslation:GetX()
                    offsetV = tex:uvTranslation:GetY()
                end

                if tex:uvScaling not= undefined
                    scaleU = tex:uvScaling:GetX()
                    scaleV = tex:uvScaling:GetY()
                end

                integer usageValue = 0
                TextureAttribute temp

                if tex:usage = tex:USAGE_DIFFUSE
                    usageValue = temp:GetDiffuseValue()
                elseif tex:usage = tex:USAGE_SPECULAR
                    usageValue = temp:GetSpecularValue()
                elseif tex:usage = tex:USAGE_BUMP
                    usageValue = temp:GetBumpValue()
                elseif tex:usage = tex:USAGE_NORMAL
                    usageValue = temp:GetNormalValue()
                elseif tex:usage = tex:USAGE_AMBIENT
                    usageValue = temp:GetAmbientValue()
                elseif tex:usage = tex:USAGE_EMISSIVE
                    usageValue = temp:GetEmissiveValue()
                elseif tex:usage = tex:USAGE_REFLECTION
                    usageValue = temp:GetReflectionValue()
                end

                temp:SetAttribute(usageValue, descriptor, offsetU, offsetV, scaleU, scaleV)
                result:Add(temp)

                counter = counter + 1
            end
        end

        return result
    end

    private action LoadNodes(Array<ModelNode> modelNodes)
        HashTable<NodePart, HashTable<text, Matrix4>> nodePartBones

        integer counter = 0
        repeat modelNodes:GetSize() times
            nodes:Add(LoadNode(modelNodes:Get(counter), nodePartBones))
            counter = counter + 1
        end
        
        NodePart key = undefined
        HashTable<text, Matrix4> value = undefined
        Iterator<NodePart> keyIterator = nodePartBones:GetKeyIterator()
        repeat while keyIterator:HasNext()
            key = keyIterator:Next()
            value = nodePartBones:GetValue(key)
            key:invBoneBindTransforms:Empty()
            
            text key2 = ""
            Matrix4 value2 = undefined
            Iterator<text> keyIterator2 = value:GetKeyIterator()
            repeat while keyIterator2:HasNext()
                key2 = keyIterator2:Next()
                value2 = value:GetValue(key2)

                Matrix4 temp
                temp:Set(value2)
                temp:Inverse()

                key:invBoneBindTransforms:Add(GetNode(key2), temp)
            end
        end
    end

    private action LoadNode(ModelNode modelNode, HashTable<NodePart, HashTable<text, Matrix4>> nodePartBones) returns Node
        Node node
        node:id = modelNode:id

        if modelNode:translation not= undefined
            node:translation:Set(modelNode:translation)
        end
        if modelNode:rotation not= undefined
            node:rotation:Set(modelNode:rotation)
        end
        if modelNode:scale not= undefined
            node:scale:Set(modelNode:scale)
        end

        if modelNode:parts not= undefined
            integer counter = 0
            ModelNodePart modelNodePart = undefined
            repeat modelNode:parts:GetSize() times
                modelNodePart = modelNode:parts:Get(counter)
                MeshPart meshPart = undefined
                Material meshMaterial = undefined

                if modelNodePart:meshPartID not= ""
                    integer meshCounter = 0
                    boolean searching = true
                    MeshPart part = undefined
                    repeat while searching and meshCounter < meshParts:GetSize()
                        part = meshParts:Get(meshCounter)
                        if modelNodePart:meshPartID = part:id
                            meshPart = part
                            searching = false
                        end
                        meshCounter = meshCounter + 1
                    end
                end

                if modelNodePart:materialID not= ""
                    integer materialCounter = 0
                    boolean searching = true
                    Material material = undefined
                    repeat while searching and materialCounter < materials:GetSize()
                        material = materials:Get(materialCounter)
                        if modelNodePart:materialID = material:id
                            meshMaterial = material
                            searching = false
                        end
                        materialCounter = materialCounter + 1
                    end
                end

                if meshPart = undefined or meshMaterial = undefined
                    alert("Invalid node, node ID: " + node:id)
                end

                NodePart nodePart
                nodePart:meshPart = meshPart
                nodePart:material = meshMaterial
                node:parts:Add(nodePart)
                if modelNodePart:bones not= undefined
                    nodePartBones:Add(nodePart, modelNodePart:bones)
                end

                counter = counter + 1
            end
        end

        if modelNode:children not= undefined
            integer counter = 0
            ModelNode child = undefined
            repeat modelNode:children:GetSize() times
                child = modelNode:children:Get(counter)
                node:Add(LoadNode(child, nodePartBones))
                counter = counter + 1
            end
        end

        return node
    end

    private action GetNode(text nodeID) returns Node
        integer counter = 0
        Node node = undefined
        repeat nodes:GetSize() times
            node = nodes:Get(counter)
            if node:id = nodeID
                return node
            end
            counter = counter + 1
        end
        counter = 0
        Node result = undefined
        repeat nodes:GetSize() times
            node = nodes:Get(counter)
            result = node:GetChild(nodeID)
            if result not= undefined
                return result
            end
            counter = counter + 1
        end

        return result
    end

    action GetAnimation(text id) returns Animation
        integer counter = 0
        repeat animations:GetSize() times
            if animations:Get(counter):id:EqualsIgnoringCase(id)
                return animations:Get(counter)
            end
            counter = counter + 1
        end
        return undefined
    end

    action Dispose
        //...
    end
    /** 
        

	private void loadAnimations (Iterable<ModelAnimation> modelAnimations) {
		for (final ModelAnimation anim : modelAnimations) {
			Animation animation = new Animation();
			animation.id = anim.id;
			for (ModelNodeAnimation nanim : anim.nodeAnimations) {
				final Node node = getNode(nanim.nodeId);
				if (node == null) continue;
				NodeAnimation nodeAnim = new NodeAnimation();
				nodeAnim.node = node;

				if (nanim.translation != null) {
					nodeAnim.translation = new Array<NodeKeyframe<Vector3>>();
					nodeAnim.translation.ensureCapacity(nanim.translation.size);
					for (ModelNodeKeyframe<Vector3> kf : nanim.translation) {
						if (kf.keytime > animation.duration) animation.duration = kf.keytime;
						nodeAnim.translation.add(new NodeKeyframe<Vector3>(kf.keytime, new Vector3(kf.value == null ? node.translation
							: kf.value)));
					}
				}

				if (nanim.rotation != null) {
					nodeAnim.rotation = new Array<NodeKeyframe<Quaternion>>();
					nodeAnim.rotation.ensureCapacity(nanim.rotation.size);
					for (ModelNodeKeyframe<Quaternion> kf : nanim.rotation) {
						if (kf.keytime > animation.duration) animation.duration = kf.keytime;
						nodeAnim.rotation.add(new NodeKeyframe<Quaternion>(kf.keytime, new Quaternion(kf.value == null ? node.rotation
							: kf.value)));
					}
				}

				if (nanim.scaling != null) {
					nodeAnim.scaling = new Array<NodeKeyframe<Vector3>>();
					nodeAnim.scaling.ensureCapacity(nanim.scaling.size);
					for (ModelNodeKeyframe<Vector3> kf : nanim.scaling) {
						if (kf.keytime > animation.duration) animation.duration = kf.keytime;
						nodeAnim.scaling.add(new NodeKeyframe<Vector3>(kf.keytime,
							new Vector3(kf.value == null ? node.scale : kf.value)));
					}
				}

				if ((nodeAnim.translation != null && nodeAnim.translation.size > 0)
					|| (nodeAnim.rotation != null && nodeAnim.rotation.size > 0)
					|| (nodeAnim.scaling != null && nodeAnim.scaling.size > 0)) animation.nodeAnimations.add(nodeAnim);
			}
			if (animation.nodeAnimations.size > 0) animations.add(animation);
		}
	}

	/** Adds a {@link Disposable} to be managed and disposed by this Model. Can be used to keep track of manually loaded textures
	 * for {@link ModelInstance}.
	 * @param disposable the Disposable *-
	public void manageDisposable (Disposable disposable) {
		if (!disposables.contains(disposable, true)) disposables.add(disposable);
	}

	/** @return the {@link Disposable} objects that will be disposed when the {@link #dispose()} method is called. *-
	public Iterable<Disposable> getManagedDisposables () {
		return disposables;
	}

	@Override
	public void dispose () {
		for (Disposable disposable : disposables) {
			disposable.dispose();
		}
	}

	/** Calculates the local and world transform of all {@link Node} instances in this model, recursively. First each
	 * {@link Node#localTransform} transform is calculated based on the translation, rotation and scale of each Node. Then each
	 * {@link Node#calculateWorldTransform()} is calculated, based on the parent's world transform and the local transform of each
	 * Node. Finally, the animation bone matrices are updated accordingly.</p>
	 * 
	 * This method can be used to recalculate all transforms if any of the Node's local properties (translation, rotation, scale)
	 * was modified. *-
	public void calculateTransforms () {
		final int n = nodes.size;
		for (int i = 0; i < n; i++) {
			nodes.get(i).calculateTransforms(true);
		}
		for (int i = 0; i < n; i++) {
			nodes.get(i).calculateBoneTransforms(true);
		}
	}

	/** Calculate the bounding box of this model instance. This is a potential slow operation, it is advised to cache the result.
	 * @param out the {@link BoundingBox} that will be set with the bounds.
	 * @return the out parameter for chaining *-
	public BoundingBox calculateBoundingBox (final BoundingBox out) {
		out.inf();
		return extendBoundingBox(out);
	}

	/** Extends the bounding box with the bounds of this model instance. This is a potential slow operation, it is advised to cache
	 * the result.
	 * @param out the {@link BoundingBox} that will be extended with the bounds.
	 * @return the out parameter for chaining *-
	public BoundingBox extendBoundingBox (final BoundingBox out) {
		final int n = nodes.size;
		for (int i = 0; i < n; i++)
			nodes.get(i).extendBoundingBox(out);
		return out;
	}

	/** @param id The ID of the material to fetch.
	 * @return The {@link Material} with the specified id, or null if not available. *-
	public Material getMaterial (final String id) {
		return getMaterial(id, true);
	}

	/** @param id The ID of the material to fetch.
	 * @param ignoreCase whether to use case sensitivity when comparing the material id.
	 * @return The {@link Material} with the specified id, or null if not available. *-
	public Material getMaterial (final String id, boolean ignoreCase) {
		final int n = materials.size;
		Material material;
		if (ignoreCase) {
			for (int i = 0; i < n; i++)
				if ((material = materials.get(i)).id.equalsIgnoreCase(id)) return material;
		} else {
			for (int i = 0; i < n; i++)
				if ((material = materials.get(i)).id.equals(id)) return material;
		}
		return null;
	}

	/** @param id The ID of the node to fetch.
	 * @return The {@link Node} with the specified id, or null if not found. *-
	public Node getNode (final String id) {
		return getNode(id, true);
	}

	/** @param id The ID of the node to fetch.
	 * @param recursive false to fetch a root node only, true to search the entire node tree for the specified node.
	 * @return The {@link Node} with the specified id, or null if not found. *-
	public Node getNode (final String id, boolean recursive) {
		return getNode(id, recursive, false);
	}

	/** @param id The ID of the node to fetch.
	 * @param recursive false to fetch a root node only, true to search the entire node tree for the specified node.
	 * @param ignoreCase whether to use case sensitivity when comparing the node id.
	 * @return The {@link Node} with the specified id, or null if not found. *-
	public Node getNode (final String id, boolean recursive, boolean ignoreCase) {
		return Node.getNode(nodes, id, recursive, ignoreCase);
	}*/
end