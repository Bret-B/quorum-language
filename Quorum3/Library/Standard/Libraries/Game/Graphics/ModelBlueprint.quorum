package Libraries.Game.Graphics

//import com.badlogic.gdx.assets.loaders.ModelLoader;
//import com.badlogic.gdx.graphics.GL20;
//import com.badlogic.gdx.graphics.Mesh;
use Libraries.Game.Graphics.Texture
//import com.badlogic.gdx.graphics.VertexAttributes;
//import com.badlogic.gdx.graphics.g3d.attributes.BlendingAttribute;
//import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
//import com.badlogic.gdx.graphics.g3d.attributes.FloatAttribute;
//import com.badlogic.gdx.graphics.g3d.attributes.TextureAttribute;
use Libraries.Game.Graphics.ModelData.all
//import com.badlogic.gdx.graphics.g3d.utils.TextureDescriptor;
//import com.badlogic.gdx.graphics.g3d.utils.TextureProvider;
//import com.badlogic.gdx.graphics.g3d.utils.TextureProvider.FileTextureProvider;
use Libraries.Compute.Matrix4
use Libraries.Compute.Quaternion
use Libraries.Compute.Vector3
//import com.badlogic.gdx.math.collision.BoundingBox;
//import com.badlogic.gdx.utils.Array;
//import com.badlogic.gdx.utils.ArrayMap;
//import com.badlogic.gdx.utils.BufferUtils;
use Libraries.Game.Disposable
//import com.badlogic.gdx.utils.GdxRuntimeException;
//import com.badlogic.gdx.utils.ObjectMap;
use Libraries.Containers.Array

class ModelBlueprint is Disposable
    //public Array<Material> materials
    public Array<Node> nodes
    public Array<Animation> animations
    public Array<Mesh> meshes
    public Array<MeshPart> meshParts
    public Array<Disposable> disposables
    // JAVA:
    //private ObjectMap<NodePart, ArrayMap<String, Matrix4>> nodePartBones = new ObjectMap<NodePart, ArrayMap<String, Matrix4>>();

    action Load(ModelData data)
    //    JAVA:
    //    loadMeshes(modelData.meshes);
    //    loadMaterials(modelData.materials, textureProvider);
    //    loadNodes(modelData.nodes);
    //    loadAnimations(modelData.animations);
    //    calculateTransforms();
    end

    private action LoadMeshes(Array<ModelMesh> meshes)
        integer counter = 0
        repeat meshes:GetSize() times
            ConvertMesh(meshes:Get(counter))
            counter = counter + 1
        end
    end

    private action ConvertMesh(ModelMesh modelMesh)
        // JAVA:
        /*
        int numIndices = 0;
        for (ModelMeshPart part : modelMesh.parts) {
                numIndices += part.indices.length;
        }
        VertexAttributes attributes = new VertexAttributes(modelMesh.attributes);
        int numVertices = modelMesh.vertices.length / (attributes.vertexSize / 4);

        Mesh mesh = new Mesh(true, numVertices, numIndices, attributes);
        meshes.add(mesh);
        disposables.add(mesh);

        BufferUtils.copy(modelMesh.vertices, mesh.getVerticesBuffer(), modelMesh.vertices.length, 0);
        int offset = 0;
        mesh.getIndicesBuffer().clear();
        for (ModelMeshPart part : modelMesh.parts) {
                MeshPart meshPart = new MeshPart();
                meshPart.id = part.id;
                meshPart.primitiveType = part.primitiveType;
                meshPart.indexOffset = offset;
                meshPart.numVertices = part.indices.length;
                meshPart.mesh = mesh;
                mesh.getIndicesBuffer().put(part.indices);
                offset += meshPart.numVertices;
                meshParts.add(meshPart);
        }
        mesh.getIndicesBuffer().position(0);
        */
    end

    private action LoadMaterials(Array<ModelMaterial> modelMaterials)
        integer counter = 0
        repeat modelMaterials:GetSize() times
            // JAVA:
            // this.materials.add(convertMaterial(mtl, textureProvider));
            counter = counter + 1
        end
    end

    private action ConvertMaterial(ModelMaterial mtl)
        // JAVA:
        /*
            Material result = new Material();
		result.id = mtl.id;
		if (mtl.ambient != null) result.set(new ColorAttribute(ColorAttribute.Ambient, mtl.ambient));
		if (mtl.diffuse != null) result.set(new ColorAttribute(ColorAttribute.Diffuse, mtl.diffuse));
		if (mtl.specular != null) result.set(new ColorAttribute(ColorAttribute.Specular, mtl.specular));
		if (mtl.emissive != null) result.set(new ColorAttribute(ColorAttribute.Emissive, mtl.emissive));
		if (mtl.reflection != null) result.set(new ColorAttribute(ColorAttribute.Reflection, mtl.reflection));
		if (mtl.shininess > 0f) result.set(new FloatAttribute(FloatAttribute.Shininess, mtl.shininess));
		if (mtl.opacity != 1.f) result.set(new BlendingAttribute(GL20.GL_SRC_ALPHA, GL20.GL_ONE_MINUS_SRC_ALPHA, mtl.opacity));

		ObjectMap<String, Texture> textures = new ObjectMap<String, Texture>();

		// FIXME uvScaling/uvTranslation totally ignored
		if (mtl.textures != null) {
			for (ModelTexture tex : mtl.textures) {
				Texture texture;
				if (textures.containsKey(tex.fileName)) {
					texture = textures.get(tex.fileName);
				} else {
					texture = textureProvider.load(tex.fileName);
					textures.put(tex.fileName, texture);
					disposables.add(texture);
				}

				TextureDescriptor descriptor = new TextureDescriptor(texture);
				descriptor.minFilter = texture.getMinFilter();
				descriptor.magFilter = texture.getMagFilter();
				descriptor.uWrap = texture.getUWrap();
				descriptor.vWrap = texture.getVWrap();

				float offsetU = tex.uvTranslation == null ? 0f : tex.uvTranslation.x;
				float offsetV = tex.uvTranslation == null ? 0f : tex.uvTranslation.y;
				float scaleU = tex.uvScaling == null ? 1f : tex.uvScaling.x;
				float scaleV = tex.uvScaling == null ? 1f : tex.uvScaling.y;

				switch (tex.usage) {
				case ModelTexture.USAGE_DIFFUSE:
					result.set(new TextureAttribute(TextureAttribute.Diffuse, descriptor, offsetU, offsetV, scaleU, scaleV));
					break;
				case ModelTexture.USAGE_SPECULAR:
					result.set(new TextureAttribute(TextureAttribute.Specular, descriptor, offsetU, offsetV, scaleU, scaleV));
					break;
				case ModelTexture.USAGE_BUMP:
					result.set(new TextureAttribute(TextureAttribute.Bump, descriptor, offsetU, offsetV, scaleU, scaleV));
					break;
				case ModelTexture.USAGE_NORMAL:
					result.set(new TextureAttribute(TextureAttribute.Normal, descriptor, offsetU, offsetV, scaleU, scaleV));
					break;
				case ModelTexture.USAGE_AMBIENT:
					result.set(new TextureAttribute(TextureAttribute.Ambient, descriptor, offsetU, offsetV, scaleU, scaleV));
					break;
				case ModelTexture.USAGE_EMISSIVE:
					result.set(new TextureAttribute(TextureAttribute.Emissive, descriptor, offsetU, offsetV, scaleU, scaleV));
					break;
				case ModelTexture.USAGE_REFLECTION:
					result.set(new TextureAttribute(TextureAttribute.Reflection, descriptor, offsetU, offsetV, scaleU, scaleV));
					break;
				}
			}
		}

		return result;
        */
    end

    private action LoadNodes(ModelNode modelNodes)
        //...
    end

    action GetAnimation(text id) returns Animation
        integer counter = 0
        repeat animations:GetSize() times
            if animations:Get(counter):id:EqualsIgnoringCase(id)
                return animations:Get(counter)
            end
            counter = counter + 1
        end
        return undefined
    end

    action Dispose
        //...
    end
    /** 
        private ObjectMap<NodePart, ArrayMap<String, Matrix4>> nodePartBones = new ObjectMap<NodePart, ArrayMap<String, Matrix4>>();

	private void loadNodes (Iterable<ModelNode> modelNodes) {
		nodePartBones.clear();
		for (ModelNode node : modelNodes) {
			nodes.add(loadNode(node));
		}
		for (ObjectMap.Entry<NodePart, ArrayMap<String, Matrix4>> e : nodePartBones.entries()) {
			if (e.key.invBoneBindTransforms == null)
				e.key.invBoneBindTransforms = new ArrayMap<Node, Matrix4>(Node.class, Matrix4.class);
			e.key.invBoneBindTransforms.clear();
			for (ObjectMap.Entry<String, Matrix4> b : e.value.entries())
				e.key.invBoneBindTransforms.put(getNode(b.key), new Matrix4(b.value).inv());
		}
	}

	private Node loadNode (ModelNode modelNode) {
		Node node = new Node();
		node.id = modelNode.id;

		if (modelNode.translation != null) node.translation.set(modelNode.translation);
		if (modelNode.rotation != null) node.rotation.set(modelNode.rotation);
		if (modelNode.scale != null) node.scale.set(modelNode.scale);
		// FIXME create temporary maps for faster lookup?
		if (modelNode.parts != null) {
			for (ModelNodePart modelNodePart : modelNode.parts) {
				MeshPart meshPart = null;
				Material meshMaterial = null;

				if (modelNodePart.meshPartId != null) {
					for (MeshPart part : meshParts) {
						if (modelNodePart.meshPartId.equals(part.id)) {
							meshPart = part;
							break;
						}
					}
				}

				if (modelNodePart.materialId != null) {
					for (Material material : materials) {
						if (modelNodePart.materialId.equals(material.id)) {
							meshMaterial = material;
							break;
						}
					}
				}

				if (meshPart == null || meshMaterial == null) throw new GdxRuntimeException("Invalid node: " + node.id);

				if (meshPart != null && meshMaterial != null) {
					NodePart nodePart = new NodePart();
					nodePart.meshPart = meshPart;
					nodePart.material = meshMaterial;
					node.parts.add(nodePart);
					if (modelNodePart.bones != null) nodePartBones.put(nodePart, modelNodePart.bones);
				}
			}
		}

		if (modelNode.children != null) {
			for (ModelNode child : modelNode.children) {
				node.addChild(loadNode(child));
			}
		}

		return node;
	}

	private void loadAnimations (Iterable<ModelAnimation> modelAnimations) {
		for (final ModelAnimation anim : modelAnimations) {
			Animation animation = new Animation();
			animation.id = anim.id;
			for (ModelNodeAnimation nanim : anim.nodeAnimations) {
				final Node node = getNode(nanim.nodeId);
				if (node == null) continue;
				NodeAnimation nodeAnim = new NodeAnimation();
				nodeAnim.node = node;

				if (nanim.translation != null) {
					nodeAnim.translation = new Array<NodeKeyframe<Vector3>>();
					nodeAnim.translation.ensureCapacity(nanim.translation.size);
					for (ModelNodeKeyframe<Vector3> kf : nanim.translation) {
						if (kf.keytime > animation.duration) animation.duration = kf.keytime;
						nodeAnim.translation.add(new NodeKeyframe<Vector3>(kf.keytime, new Vector3(kf.value == null ? node.translation
							: kf.value)));
					}
				}

				if (nanim.rotation != null) {
					nodeAnim.rotation = new Array<NodeKeyframe<Quaternion>>();
					nodeAnim.rotation.ensureCapacity(nanim.rotation.size);
					for (ModelNodeKeyframe<Quaternion> kf : nanim.rotation) {
						if (kf.keytime > animation.duration) animation.duration = kf.keytime;
						nodeAnim.rotation.add(new NodeKeyframe<Quaternion>(kf.keytime, new Quaternion(kf.value == null ? node.rotation
							: kf.value)));
					}
				}

				if (nanim.scaling != null) {
					nodeAnim.scaling = new Array<NodeKeyframe<Vector3>>();
					nodeAnim.scaling.ensureCapacity(nanim.scaling.size);
					for (ModelNodeKeyframe<Vector3> kf : nanim.scaling) {
						if (kf.keytime > animation.duration) animation.duration = kf.keytime;
						nodeAnim.scaling.add(new NodeKeyframe<Vector3>(kf.keytime,
							new Vector3(kf.value == null ? node.scale : kf.value)));
					}
				}

				if ((nodeAnim.translation != null && nodeAnim.translation.size > 0)
					|| (nodeAnim.rotation != null && nodeAnim.rotation.size > 0)
					|| (nodeAnim.scaling != null && nodeAnim.scaling.size > 0)) animation.nodeAnimations.add(nodeAnim);
			}
			if (animation.nodeAnimations.size > 0) animations.add(animation);
		}
	}

	/** Adds a {@link Disposable} to be managed and disposed by this Model. Can be used to keep track of manually loaded textures
	 * for {@link ModelInstance}.
	 * @param disposable the Disposable *-
	public void manageDisposable (Disposable disposable) {
		if (!disposables.contains(disposable, true)) disposables.add(disposable);
	}

	/** @return the {@link Disposable} objects that will be disposed when the {@link #dispose()} method is called. *-
	public Iterable<Disposable> getManagedDisposables () {
		return disposables;
	}

	@Override
	public void dispose () {
		for (Disposable disposable : disposables) {
			disposable.dispose();
		}
	}

	/** Calculates the local and world transform of all {@link Node} instances in this model, recursively. First each
	 * {@link Node#localTransform} transform is calculated based on the translation, rotation and scale of each Node. Then each
	 * {@link Node#calculateWorldTransform()} is calculated, based on the parent's world transform and the local transform of each
	 * Node. Finally, the animation bone matrices are updated accordingly.</p>
	 * 
	 * This method can be used to recalculate all transforms if any of the Node's local properties (translation, rotation, scale)
	 * was modified. *-
	public void calculateTransforms () {
		final int n = nodes.size;
		for (int i = 0; i < n; i++) {
			nodes.get(i).calculateTransforms(true);
		}
		for (int i = 0; i < n; i++) {
			nodes.get(i).calculateBoneTransforms(true);
		}
	}

	/** Calculate the bounding box of this model instance. This is a potential slow operation, it is advised to cache the result.
	 * @param out the {@link BoundingBox} that will be set with the bounds.
	 * @return the out parameter for chaining *-
	public BoundingBox calculateBoundingBox (final BoundingBox out) {
		out.inf();
		return extendBoundingBox(out);
	}

	/** Extends the bounding box with the bounds of this model instance. This is a potential slow operation, it is advised to cache
	 * the result.
	 * @param out the {@link BoundingBox} that will be extended with the bounds.
	 * @return the out parameter for chaining *-
	public BoundingBox extendBoundingBox (final BoundingBox out) {
		final int n = nodes.size;
		for (int i = 0; i < n; i++)
			nodes.get(i).extendBoundingBox(out);
		return out;
	}

	/** @param id The ID of the material to fetch.
	 * @return The {@link Material} with the specified id, or null if not available. *-
	public Material getMaterial (final String id) {
		return getMaterial(id, true);
	}

	/** @param id The ID of the material to fetch.
	 * @param ignoreCase whether to use case sensitivity when comparing the material id.
	 * @return The {@link Material} with the specified id, or null if not available. *-
	public Material getMaterial (final String id, boolean ignoreCase) {
		final int n = materials.size;
		Material material;
		if (ignoreCase) {
			for (int i = 0; i < n; i++)
				if ((material = materials.get(i)).id.equalsIgnoreCase(id)) return material;
		} else {
			for (int i = 0; i < n; i++)
				if ((material = materials.get(i)).id.equals(id)) return material;
		}
		return null;
	}

	/** @param id The ID of the node to fetch.
	 * @return The {@link Node} with the specified id, or null if not found. *-
	public Node getNode (final String id) {
		return getNode(id, true);
	}

	/** @param id The ID of the node to fetch.
	 * @param recursive false to fetch a root node only, true to search the entire node tree for the specified node.
	 * @return The {@link Node} with the specified id, or null if not found. *-
	public Node getNode (final String id, boolean recursive) {
		return getNode(id, recursive, false);
	}

	/** @param id The ID of the node to fetch.
	 * @param recursive false to fetch a root node only, true to search the entire node tree for the specified node.
	 * @param ignoreCase whether to use case sensitivity when comparing the node id.
	 * @return The {@link Node} with the specified id, or null if not found. *-
	public Node getNode (final String id, boolean recursive, boolean ignoreCase) {
		return Node.getNode(nodes, id, recursive, ignoreCase);
	}*/
end