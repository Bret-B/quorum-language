package Libraries.Game.Collision

use Libraries.Compute.Vector3
use Libraries.Containers.Array
use Libraries.Compute.Math
use Libraries.Game.Collision.ConvexConvexSubSimplexClosestResult

class ConvexConvexSimplexSolver
// ****************************************************************************
// VoroniSimplexSolver class fields and actions

    constant integer VORONI_SIMPLEX_MAX_VERTICES = 5
    
    constant integer VERTA = 0
    constant integer VERTB = 1
    constant integer VERTC = 2
    constant integer VERTD = 3

    public integer numVertices = 0

    public Array<Vector3> simplexVectorW
    public Array<Vector3> simplexPointsP
    public Array<Vector3> simplexPointsQ

    public Vector3 cachedP1
    public Vector3 cachedP2
    public Vector3 cachedV
    public Vector3 lastW
    public boolean cachedValidClosest = false

    ConvexConvexSubSimplexClosestResult cachedBC

    public boolean needsUpdate = true

    Math math

    on create
        repeat VORONI_SIMPLEX_MAX_VERTICES times
            Vector3 v1
            Vector3 v2
            Vector3 v3
            simplexVectorW:Add(v1)
            simplexPointsP:Add(v2)
            simplexPointsQ:Add(v3)
        end
    end

    action RemoveVertex(integer index)
        numVertices = numVertices - 1
        simplexVectorW:Get(index):Set(simplexVectorW:Get(numVertices))
        simplexPointsP:Get(index):Set(simplexPointsP:Get(numVertices))
        simplexPointsQ:Get(index):Set(simplexPointsQ:Get(numVertices))
    end

    action ReduceVertices(ConvexConvexSubSimplexClosestResult usedVerts)
        if numVertices >= 4 and not usedVerts:usedVertexD
            RemoveVertex(3)
        end

        if numVertices >= 3 and not usedVerts:usedVertexC
            RemoveVertex(2)
        end

        if numVertices >= 2 and not usedVerts:usedVertexB
            RemoveVertex(1)
        end

        if numVertices >= 1 and not usedVerts:usedVertexA
            RemoveVertex(0)
        end
    end

    action UpdateClosestVectorAndPoints returns boolean
        if needsUpdate
            cachedBC:Reset()

            needsUpdate = false

            if numVertices = 0
                cachedValidClosest = false
            elseif numVertices = 1
                cachedP1:Set(simplexPointsP:Get(0))
                cachedP2:Set(simplexPointsQ:Get(0))
                cachedV:Set(cachedP1):Subtract(cachedP2)
                cachedBC:Reset()
                cachedBC:SetBarycentricCoordinates(1, 0, 0, 0)
                cachedValidClosest = cachedBC:IsValid()
            elseif numVertices = 2
                Vector3 tmp

                Vector3 from = simplexVectorW:Get(0)
                Vector3 to = simplexVectorW:Get(1)
                Vector3 nearest

                Vector3 p
                p:Set(0, 0, 0)
                Vector3 diff
                diff:Set(p):Subtract(from)

                Vector3 v
                v:Set(to):Subtract(from)

                number t = v:DotProduct(diff)

                if t > 0
                    number dotVV = v:DotProduct(v)
                    if t < dotVV
                        t = t / dotVV
                        tmp:Set(v):Scale(t)
                        diff:Subtract(tmp)
                        cachedBC:usedVertexA = true
                        cachedBC:usedVertexB = true
                    else
                        t = 1
                        diff:Subtract(v)
                        cachedBC:usedVertexB = true
                    end
                else
                    t = 0
                    cachedBC:usedVertexA = true
                end

                cachedBC:SetBarycentricCoordinates(1 - t, t, 0, 0)

                tmp:Set(v):Scale(t)
                nearest:Set(from):Add(tmp)

                tmp:Set(simplexPointsP:Get(1)):Subtract(simplexPointsP:Get(0))
                tmp:Scale(t)
                cachedP1:Set(simplexPointsP:Get(0)):Add(tmp)

                tmp:Set(simplexPointsQ:Get(1)):Subtract(simplexPointsQ:Get(0))
                tmp:Scale(t)
                cachedP2:Set(simplexPointsQ:Get(0)):Add(tmp)

                cachedV:Set(cachedP1):Subtract(cachedP2)

                ReduceVertices(cachedBC)

                cachedValidClosest = cachedBC:IsValid()
            elseif numVertices = 3
                Vector3 tmp1
                Vector3 tmp2
                Vector3 tmp3

                Vector3 p
                p:Set(0, 0, 0)

                Vector3 a = simplexVectorW:Get(0)
                Vector3 b = simplexVectorW:Get(1)
                Vector3 c = simplexVectorW:Get(2)

                ClosestPointTriangle(p, a, b, c, cachedBC)

                tmp1:Set(simplexPointsP:Get(0)):Scale(cachedBC:barycentricCoordinates:Get(0))
                tmp2:Set(simplexPointsP:Get(1)):Scale(cachedBC:barycentricCoordinates:Get(1))
                tmp3:Set(simplexPointsP:Get(2)):Scale(cachedBC:barycentricCoordinates:Get(2))
                cachedP1:Set(tmp1):Add(tmp2):Add(tmp3)

                tmp1:Set(simplexPointsQ:Get(0)):Scale(cachedBC:barycentricCoordinates:Get(0))
                tmp2:Set(simplexPointsQ:Get(1)):Scale(cachedBC:barycentricCoordinates:Get(1))
                tmp3:Set(simplexPointsQ:Get(2)):Scale(cachedBC:barycentricCoordinates:Get(2))
                cachedP2:Set(tmp1):Add(tmp2):Add(tmp3)

                cachedV:Set(cachedP1):Subtract(cachedP2)

                ReduceVertices(cachedBC)
                cachedValidClosest = cachedBC:IsValid()
            elseif numVertices = 4
                Vector3 tmp1
                Vector3 tmp2
                Vector3 tmp3
                Vector3 tmp4

                Vector3 p
                p:Set(0, 0, 0)

                Vector3 a = simplexVectorW:Get(0)
                Vector3 b = simplexVectorW:Get(1)
                Vector3 c = simplexVectorW:Get(2)
                Vector3 d = simplexVectorW:Get(3)

                boolean hasSeparation = ClosestPointTetrahedron(p, a, b, c, d, cachedBC)
                boolean break = false

                if hasSeparation
                    tmp1:Set(simplexPointsP:Get(0)):Scale(cachedBC:barycentricCoordinates:Get(0))
                    tmp2:Set(simplexPointsP:Get(1)):Scale(cachedBC:barycentricCoordinates:Get(1))
                    tmp3:Set(simplexPointsP:Get(2)):Scale(cachedBC:barycentricCoordinates:Get(2))
                    tmp4:Set(simplexPointsP:Get(3)):Scale(cachedBC:barycentricCoordinates:Get(3))
                    cachedP1:Set(tmp1):Add(tmp2):Add(tmp3):Add(tmp4)

                    tmp1:Set(simplexPointsQ:Get(0)):Scale(cachedBC:barycentricCoordinates:Get(0))
                    tmp2:Set(simplexPointsQ:Get(1)):Scale(cachedBC:barycentricCoordinates:Get(1))
                    tmp3:Set(simplexPointsQ:Get(2)):Scale(cachedBC:barycentricCoordinates:Get(2))
                    tmp4:Set(simplexPointsQ:Get(3)):Scale(cachedBC:barycentricCoordinates:Get(3))
                    cachedP2:Set(tmp1):Add(tmp2):Add(tmp3):Add(tmp4)

                    cachedV:Set(cachedP1):Subtract(cachedP2)
                    ReduceVertices(cachedBC)
                else
                    if cachedBC:degenerate
                        cachedValidClosest = false
                    else
                        cachedValidClosest = true
                        cachedV:Set(0, 0, 0)
                    end
                    break = true
                end

                if not break
                    cachedValidClosest = cachedBC:IsValid()
                end
            else
                cachedValidClosest = false
            end
        end

        return cachedValidClosest
    end

    private action ClosestPointTriangle(Vector3 p, Vector3 a, Vector3 b, Vector3 c, ConvexConvexSubSimplexClosestResult result) returns boolean
        result:UsedVerticesReset()
        
        Vector3 ab
        ab:Set(b):Subtract(a)

        Vector3 ac
        ac:Set(c):Subtract(a)

        Vector3 ap
        ap:Set(p):Subtract(a)

        number d1 = ab:DotProduct(ap)
        number d2 = ac:DotProduct(ap)

        if d1 <= 0 and d2 <= 0
            result:closestPointOnSimplex:Set(a)
            result:usedVertexA = true
            result:SetBarycentricCoordinates(1, 0, 0, 0)
            return true
        end

        Vector3 bp
        bp:Set(p):Subtract(b)

        number d3 = ab:DotProduct(bp)
        number d4 = ac:DotProduct(bp)

        if d3 >= 0 and d4 <= d3
            result:closestPointOnSimplex:Set(b)
            result:usedVertexB = true
            result:SetBarycentricCoordinates(0, 1, 0, 0)
            return true
        end

        number vc = d1*d4 - d3*d2
        if vc <= 0 and d1 >= 0 and d3 <= 0
            number v = d1 / (d1 - d3)
            result:closestPointOnSimplex:Set(ab):Scale(v):Add(a)
            result:usedVertexA = true
            result:usedVertexB = true
            result:SetBarycentricCoordinates(1-v, v, 0, 0)
            return true
        end

        Vector3 cp
        cp:Set(p):Subtract(c)

        number d5 = ab:DotProduct(cp)
        number d6 = ac:DotProduct(cp)

        if d6 >= 0 and d5 <= d6
            result:closestPointOnSimplex:Set(c)
            result:usedVertexC = true
            result:SetBarycentricCoordinates(0, 0, 1, 0)
            return true
        end

        number vb = d5*d2 - d1*d6
        if vb <= 0 and d2 >= 0 and d6 <= 0
            w = d2 / (d2 - d6)
            result:closestPointOnSimplex:Set(ac):Scale(w):Add(a)
            result:usedVertexA = true
            result:usedVertexB = true
            result:SetBarycentricCoordinates(1-w, 0, w, 0)
            return true
        end

        number va = d3*d6 - d5*d4
        if va <= 0 and (d4 - d3) >= 0 and (d5 - d6) >= 0
            number w = (d4 - d3) / ((d4 - d3) + (d5 - d6))

            Vector3 tmp
            tmp:Set(c):Subtract(b)
            result:closestPointOnSimplex:Set(tmp):Scale(w):Add(b)

            result:usedVertexB = true
            result:usedVertexC = true
            result:SetBarycentricCoordinates(0, 1-w, w, 0)
            return true
        end

        number denom = 1 / (va + vb + vc)
        number v = vb * denom
        number w = vc * denom

        Vector3 tmp1
        Vector3 tmp2

        tmp1:Set(ab):Scale(v)
        tmp2:Set(ac):Scale(w)
        result:closestPointOnSimplex:Set(a):Add(tmp1):Add(tmp2)
        result:usedVertexA = true
        result:usedVertexB = true
        result:usedVertexC = true
        result:SetBarycentricCoordinates(1-v-w, v, w, 0)

        return true
    end
    
    private action PointOutsideOfPlane(Vector3 p, Vector3 a, Vector3 b, Vector3 c, Vector3 d) returns integer
        Vector3 tmp

        Vector3 normal
        normal:Set(b):Subtract(a)
        tmp:Set(c):Subtract(a)
        normal:CrossProduct(tmp)

        tmp:Set(p):Subtract(a)
        number signp = tmp:DotProduct(normal)

        tmp:Set(d):Subtract(a)
        number signd = tmp:DotProduct(normal)

        if signd * signd < ((0.0001 * 0.0001))
            return -1
        end

        if signp * signd < 0
            return 1
        else
            return 0
        end
    end

    private action ClosestPointTetrahedron(Vector3 p, Vector3 a, Vector3 b, Vector3 c, Vector3 d, ConvexConvexSubSimplexClosestResult finalResult) returns boolean
        ConvexConvexSubSimplexClosestResult tempResult
        tempResult:Reset()

        Vector3 tmp
        Vector3 q

        finalResult:closestPointOnSimplex:Set(p)
        finalResult:UsedVerticesReset()
        finalResult:usedVertexA = true
        finalResult:usedVertexB = true
        finalResult:usedVertexC = true
        finalResult:usedVertexD = true

        integer pointOutsideABC = PointOutsideOfPlane(p, a, b, c, d)
        integer pointOutsideACD = PointOutsideOfPlane(p, a, c, d, b)
        integer pointOutsideADB = PointOutsideOfPlane(p, a, d, b, c)
        integer pointOutsideBDC = PointOutsideOfPlane(p, b, d, c, a)

        if pointOutsideABC < 0 or pointOutsideACD < 0 or pointOutsideADB < 0 or pointOutsideBDC < 0
            finalResult:degenerate = true
            return false
        end

        if pointOutsideABC = 0 and pointOutsideACD = 0 and pointOutsideADB = 0 and pointOutsideBDC = 0
            return false
        end

        number bestSqDist = 0
        bestSqDist = bestSqDist:GetMaximumValue()

        if pointOutsideABC not= 0
            ClosestPointTriangle(p, a, b, c, tempResult)
            q:Set(tempResult:closestPointOnSimplex)

            tmp:Set(q):Subtract(p)
            number sqDist = tmp:DotProduct(tmp)
            
            if sqDist < bestSqDist
                bestSqDist = sqDist
                finalResult:closestPointOnSimplex:Set(q)
                finalResult:UsedVerticesReset()
                finalResult:usedVertexA = tempResult:usedVertexA
                finalResult:usedVertexB = tempResult:usedVertexB
                finalResult:usedVertexC = tempResult:usedVertexC
                finalResult:SetBarycentricCoordinates(tempResult:barycentricCoordinates:Get(VERTA), 
                                                      tempResult:barycentricCoordinates:Get(VERTB), 
                                                      tempResult:barycentricCoordinates:Get(VERTC), 
                                                      0)
            end
        end

        if pointOutsideACD not= 0
            ClosestPointTriangle(p, a, c, d, tempResult)
            q:Set(tempResult:closestPointOnSimplex)

            tmp:Set(q):Subtract(p)
            number sqDist = tmp:DotProduct(tmp)
            if sqDist < bestSqDist
                bestSqDist = sqDist
                finalResult:closestPointOnSimplex:Set(q)
                finalResult:UsedVerticesReset()
                finalResult:usedVertexA = tempResult:usedVertexA
                finalResult:usedVertexC = tempResult:usedVertexB
                finalResult:usedVertexD = tempResult:usedVertexC
                finalResult:SetBarycentricCoordinates(tempResult:barycentricCoordinates:Get(VERTA),
                                                      0,
                                                      tempResult:barycentricCoordinates:Get(VERTB),
                                                      tempResult:barycentricCoordinates:Get(VERTC))
            end
        end

        if pointOutsideADB not= 0
            ClosestPointTriangle(p, a, d, b, tempResult)
            q:Set(tempResult:closestPointOnSimplex)

            tmp:Set(q):Subtract(p)
            number sqDist = tmp:DotProduct(tmp)
            if sqDist < bestSqDist
                bestSqDist = sqDist
                finalResult:closestPointOnSimplex:Set(q)
                finalResult:UsedVerticesReset()
                finalResult:usedVertexA = tempResult:usedVertexA
                finalResult:usedVertexB = tempResult:usedVertexC
                finalResult:usedVertexD = tempResult:usedVertexB
                finalResult:SetBarycentricCoordinates(tempResult:barycentricCoordinates:Get(VERTA),
                                                      tempResult:barycentricCoordinates:Get(VERTC),
                                                      0,
                                                      tempResult:barycentricCoordinates:Get(VERTB))
            end
        end

        if pointOutsideBDC not= 0
            ClosestPointTriangle(p, b, d, c, tempResult)
            q:Set(tempResult:closestPointOnSimplex)

            tmp:Set(q):Subtract(p)
            number sqDist = tmp:DotProduct(tmp)
            if sqDist < bestSqDist
                bestSqDist = sqDist
                finalResult:closestPointOnSimplex:Set(q)
                finalResult:UsedVerticesReset()
                finalResult:usedVertexB = tempResult:usedVertexA
                finalResult:usedVertexC = tempResult:usedVertexC
                finalResult:usedVertexD = tempResult:usedVertexB
                finalResult:SetBarycentricCoordinates(0,
                                                      tempResult:barycentricCoordinates:Get(VERTA),
                                                      tempResult:barycentricCoordinates:Get(VERTC),
                                                      tempResult:barycentricCoordinates:Get(VERTB))
            end
        end

        if finalResult:usedVertexA and finalResult:usedVertexB and finalResult:usedVertexC and finalResult:usedVertexD
            return true
        end

        return true
    end

    action Reset
        number value = math:RaiseToPower(10, 30)
        cachedValidClosest = false
        numVertices = 0
        needsUpdate = true
        lastW:Set(value, value, value)
        cachedBC:Reset()
    end

    action AddVertex(Vector3 w, Vector3 p, Vector3 q)
        lastW:Set(w)
        needsUpdate = true

        simplexVectorW:Get(numVertices):Set(w)
        simplexPointsP:Get(numVertices):Set(p)
        simplexPointsQ:Get(numVertices):Set(q)

        numVertices = numVertices + 1
    end

    action Closest(Vector3 v) returns boolean
        boolean success = UpdateClosestVectorAndPoints()
        v:Set(cachedV)
        return success
    end

    action MaxVertex returns number
        integer i = 0
        integer numverts = numVertices
        number maxV = 0
        repeat while i < numverts
            number curLen2 = simplexVectorW:Get(i):LengthSquared()
            if maxV < curLen2
                maxV = curLen2
            end

            i = i + 1
        end

        return maxV
    end

    action FullSimplex returns boolean
        return numVertices = 4
    end

    action GetSimplex(Array<Vector3> pBuffer, Array<Vector3> qBuffer, Array<Vector3> yBuffer) returns integer
        integer i = 0
        repeat while i < numVertices
            yBuffer:Add(simplexVectorW:Get(i))
            pBuffer:Add(simplexPointsP:Get(i))
            qBuffer:Add(simplexPointsQ:Get(i))
            i = i + 1
        end
        return numVertices
    end
    
    action InSimplex(Vector3 w) returns boolean
        boolean found = false
        integer i = 0
        integer numVerts = numVertices

        repeat while i < numVerts
            if simplexVectorW:Get(i):Equals(w)
                found = true
            end

            i = i + 1
        end

        if w:Equals(lastW)
            return true
        end

        return found
    end

    action BackupClosest(Vector3 v)
        v:Set(cachedV)
    end
    
    action EmptySimplex returns boolean
        return numVertices = 0
    end

    action ComputePoints(Vector3 p1, Vector3 p2)
        UpdateClosestVectorAndPoints()
        p1:Set(cachedP1)
        p2:Set(cachedP2)
    end

    action NumVertices returns number
        return numVertices
    end
end