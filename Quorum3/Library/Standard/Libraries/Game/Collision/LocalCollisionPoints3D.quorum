package Libraries.Game.Collision

use Libraries.Containers.Array
use Libraries.Game.Collision.CollisionPoint3D
use Libraries.Interface.Item3D
use Libraries.Compute.Vector3
use Libraries.Compute.Math
use Libraries.Compute.Matrix3
use Libraries.Game.Collision.PhysicsPosition3D
use Libraries.Game.Physics.CollisionPersistentData
use Libraries.Game.Physics.all

class LocalCollisionPoints3D
    public constant integer MAX_COLLISION_POINTS = 4

    Array<CollisionPoint3D> points

    Item3D body0
    Item3D body1
    integer pointCount = 0
    
    integer index1A = 0

    on create
        repeat MAX_COLLISION_POINTS times
            CollisionPoint3D point
            points:Add(point)
        end
    end

    action Set(Item3D body0, Item3D body1)
        me:body0 = body0
        me:body1 = body1
        pointCount = 0
        index1A = 0
    end

    private action SortCachedPoints(CollisionPoint3D point) returns integer
        integer maxPenetrationIndex = -1
        number maxPenetration = point:GetDistance()
        integer i = 0
        repeat while i < MAX_COLLISION_POINTS
            if points:Get(i):GetDistance() < maxPenetration
                maxPenetrationIndex = i
                maxPenetration = points:Get(i):GetDistance()
            end
    
            i = i + 1
        end

        number res0 = 0
        number res1 = 0
        number res2 = 0
        number res3 = 0
        if maxPenetrationIndex not= 0
            Vector3 a0
            a0:Set(point:GetLocalPointA())
            a0:Subtract(points:Get(1):GetLocalPointA())

            Vector3 b0
            b0:Set(points:Get(3):GetLocalPointA())
            b0:Subtract(points:Get(2):GetLocalPointA())

            Vector3 cross
            cross:Set(a0)
            cross:CrossProduct(b0)

            res0 = cross:LengthSquared()
        end

        if maxPenetrationIndex not= 1
            Vector3 a1
            a1:Set(point:GetLocalPointA())
            a1:Subtract(points:Get(0):GetLocalPointA())

            Vector3 b1
            b1:Set(points:Get(3):GetLocalPointA())
            b1:Subtract(points:Get(2):GetLocalPointA())

            Vector3 cross
            cross:Set(a1)
            cross:CrossProduct(b1)
            
            res1 = cross:LengthSquared()
        end

        if maxPenetrationIndex not= 2
            Vector3 a2
            a2:Set(point:GetLocalPointA())
            a2:Subtract(points:Get(0):GetLocalPointA())

            Vector3 b2
            b2:Set(points:Get(3):GetLocalPointA())
            b2:Subtract(points:Get(1):GetLocalPointA())
            
            Vector3 cross
            cross:Set(a2)
            cross:CrossProduct(b2)

            res2 = cross:LengthSquared()
        end

        if maxPenetrationIndex not= 3
            Vector3 a3
            a3:Set(point:GetLocalPointA())
            a3:Subtract(points:Get(0):GetLocalPointA())
            
            Vector3 b3
            b3:Set(points:Get(2):GetLocalPointA())
            b3:Subtract(points:Get(1):GetLocalPointA())
            
            Vector3 cross
            cross:Set(a3)
            cross:CrossProduct(b3)

            res3 = cross:LengthSquared()
        end

        Math math
        res0 = math:AbsoluteValue(res0)
        res1 = math:AbsoluteValue(res1)
        res2 = math:AbsoluteValue(res2)
        res3 = math:AbsoluteValue(res3)

        integer maxIndex = -1
        number maxValue = 0
        maxValue = maxValue:GetMinimumValue()

        if res0 > maxValue
            maxIndex = 0
            maxValue = res0
        end

        if res1 > maxValue
            maxIndex = 1
            maxValue = res1
        end

        if res2 > maxValue
            maxIndex = 2
            maxValue = res2
        end

        if res3 > maxValue
            maxIndex = 3
            maxValue = res3
        end

        return maxIndex
    end

    action GetBody0 returns Item3D
        return body0
    end

    action GetBody1 returns Item3D
        return body1
    end

    action SetBodies(Item3D body0, Item3D body1)
        me:body0 = body0
        me:body1 = body1
    end

    action GetPointCount returns integer
        return pointCount
    end

    action GetCollisionPoint(integer index) returns CollisionPoint3D
        return points:Get(index)
    end

    action GetCacheEntry(CollisionPoint3D newPoint) returns integer
        number shortestDistance = GetCollisionBreakingThreshold() * GetCollisionBreakingThreshold()
        integer size = GetPointCount()
        integer nearestPoint = -1
        Vector3 diffA

        integer i = 0
        repeat while i < size
            CollisionPoint3D mp = points:Get(i)

            diffA:Set(mp:GetLocalPointA())
            diffA:Subtract(newPoint:GetLocalPointA())

            number distanceToCollisionPoint = diffA:DotProduct(diffA)
            if distanceToCollisionPoint < shortestDistance
                shortestDistance = distanceToCollisionPoint
                nearestPoint = i
            end

            i = i + 1
        end

        return nearestPoint
    end

    action AddCollisionPoint(CollisionPoint3D newPoint) returns integer
        integer insertIndex = GetPointCount()
        if insertIndex = MAX_COLLISION_POINTS
            if MAX_COLLISION_POINTS >= 4
                insertIndex = SortCachedPoints(newPoint)
            else
                insertIndex = 0
            end
        else
            pointCount = pointCount + 1
        end
        points:Get(insertIndex):Set(newPoint)
        return insertIndex
    end

    action RemoveCollisionPoint(integer index)
        integer lastUsedIndex = GetPointCount() - 1
        if index not= lastUsedIndex
            points:Get(index):Set(points:Get(lastUsedIndex))
            points:Get(lastUsedIndex):SetPersistentData(undefined)
            points:Get(lastUsedIndex):SetAppliedImpulse(0)
            points:Get(lastUsedIndex):SetLateralFrictionInitialized(false)
            points:Get(lastUsedIndex):SetAppliedImpulseLateralA(0)
            points:Get(lastUsedIndex):SetAppliedImpulseLateralB(0)
            points:Get(lastUsedIndex):SetLifeTime(0)
        end

        pointCount = pointCount - 1
    end

    action ReplaceCollisionPoint(CollisionPoint3D newPoint, integer insertIndex)
        integer lifeTime = points:Get(insertIndex):GetLifeTime()
        number appliedImpulse = points:Get(insertIndex):GetAppliedImpulse()
        number appliedLateralImpulse1 = points:Get(insertIndex):GetAppliedImpulseLateralA()
        number appliedLateralImpulse2 = points:Get(insertIndex):GetAppliedImpulseLateralB()

        CollisionPersistentData cache = points:Get(insertIndex):GetPersistentData()

        points:Get(insertIndex):Set(newPoint)
        
        points:Get(insertIndex):SetPersistentData(cache)
        points:Get(insertIndex):SetAppliedImpulse(appliedImpulse)
        points:Get(insertIndex):SetAppliedImpulseLateralA(appliedLateralImpulse1)
        points:Get(insertIndex):SetAppliedImpulseLateralB(appliedLateralImpulse2)
        points:Get(insertIndex):SetLifeTime(lifeTime)
    end

    private action ValidCollisionDistance(CollisionPoint3D point) returns boolean
        return point:GetDistance() <= GetCollisionBreakingThreshold()
    end

    action RefreshCollisionPoints(PhysicsPosition3D transformA, PhysicsPosition3D transformB)
        Vector3 tmp
        integer i = GetPointCount() - 1

        repeat while i >= 0
            CollisionPoint3D collisionPoint = points:Get(i)
            
            collisionPoint:GetWorldPositionOnA():Set(collisionPoint:GetLocalPointA())
            transformA:Transform(collisionPoint:GetWorldPositionOnA())

            collisionPoint:GetWorldPositionOnB():Set(collisionPoint:GetLocalPointB())
            transformB:Transform(collisionPoint:GetWorldPositionOnB())

            tmp:Set(collisionPoint:GetWorldPositionOnA())
            tmp:Subtract(collisionPoint:GetWorldPositionOnB())
            collisionPoint:SetDistance(tmp:DotProduct(collisionPoint:GetWorldNormalOnB()))

            collisionPoint:SetLifeTime(collisionPoint:GetLifeTime() + 1)

            i = i - 1
        end

        number distance2 = 0
        Vector3 projectedDifference
        Vector3 projectedPoint

        i = GetPointCount() - 1
        repeat while i >= 0
            CollisionPoint3D collisionPoint = points:Get(i)

            if not ValidCollisionDistance(collisionPoint)
                RemoveCollisionPoint(i)
            else
                tmp:Set(collisionPoint:GetWorldNormalOnB())
                tmp:Scale(collisionPoint:GetDistance())
                projectedPoint:Set(collisionPoint:GetWorldPositionOnA())
                projectedPoint:Subtract(tmp)
                projectedDifference:Set(collisionPoint:GetWorldPositionOnB())
                projectedDifference:Subtract(projectedPoint)
                distance2 = projectedDifference:DotProduct(projectedDifference)
                if distance2 > GetCollisionBreakingThreshold() * GetCollisionBreakingThreshold()
                    RemoveCollisionPoint(i)
                end
            end

            i = i - 1
        end
    end

    action ClearCollisionPoints
        pointCount = 0
    end

    action GetCollisionBreakingThreshold returns number
        return 0.02
    end

    action GetIndexA returns integer
        return index1A
    end

    action SetIndexA(integer index)
        index1A = index
    end
end