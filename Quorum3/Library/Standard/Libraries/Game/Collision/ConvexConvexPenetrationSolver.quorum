package Libraries.Game.Collision

use Libraries.Game.Collision.ConvexConvexDistanceSolver
use Libraries.Game.Collision.ConvexConvexFace
use Libraries.Containers.Table
use Libraries.Compute.Vector3
use Libraries.Containers.Array
use Libraries.Game.Collison.ConvexConvexVertex

class ConvexConvexPenetrationSolver
    public ConvexConvexDistanceSolver gjk

    public ConvexConvexFace root = undefined
    public integer nFaces = 0
    public integer iterations = 0
    public Table<Vector3> features
    public Array<Vector3> nearest
    public Vector3 normal
    public number depth = 0
    public boolean failed = false

    constant number cstInf = EpaInfaceEps:GetMaximumValue()
    constant integer EpaMaxIterations = 256
    constant number EpaInfaceEps = 0.01
    constant number EpaAccuracy = 0.001

    Array<integer> mod3
    Table<integer> tetrahedron_fidx
    Table<integer> tetrahedron_eidx

    Table<integer> hexahedron_fidx
    Table<integer> hexahedron_eidx  

    on create
        integer i = 0
        repeat 2 times
            integer j = 0
            repeat 3 times
                Vector3 v
                features:Set(i, j, v)

                j = j + 1
            end
            
            i = i + 1
        end

        repeat 2 times
            Vector3 v
            nearest:Add(v)
        end

        mod3:Add(0)
        mod3:Add(1)
        mod3:Add(2)
        mod3:Add(0)
        mod3:Add(1)

        tetrahedron_fidx:Add(0, 0, 2)
        tetrahedron_fidx:Add(0, 1, 1)
        tetrahedron_fidx:Add(0, 2, 0)

        tetrahedron_fidx:Add(1, 0, 3)
        tetrahedron_fidx:Add(1, 1, 0)
        tetrahedron_fidx:Add(1, 2, 1)

        tetrahedron_fidx:Add(2, 0, 3)
        tetrahedron_fidx:Add(2, 1, 1)
        tetrahedron_fidx:Add(2, 2, 2)

        tetrahedron_fidx:Add(3, 0, 3)
        tetrahedron_fidx:Add(3, 1, 2)
        tetrahedron_fidx:Add(3, 2, 0)

        tetrahedron_eidx:Add(0, 0, 0)
        tetrahedron_eidx:Add(0, 1, 0)
        tetrahedron_eidx:Add(0, 2, 2)
        tetrahedron_eidx:Add(0, 3, 1)

        tetrahedron_eidx:Add(1, 0, 0)
        tetrahedron_eidx:Add(1, 1, 1)
        tetrahedron_eidx:Add(1, 2, 1)
        tetrahedron_eidx:Add(1, 3, 1)

        tetrahedron_eidx:Add(2, 0, 0)
        tetrahedron_eidx:Add(2, 1, 2)
        tetrahedron_eidx:Add(2, 2, 3)
        tetrahedron_eidx:Add(2, 3, 1)

        tetrahedron_eidx:Add(3, 0, 1)
        tetrahedron_eidx:Add(3, 1, 0)
        tetrahedron_eidx:Add(3, 2, 3)
        tetrahedron_eidx:Add(3, 3, 2)

        tetrahedron_eidx:Add(4, 0, 2)
        tetrahedron_eidx:Add(4, 1, 0)
        tetrahedron_eidx:Add(4, 2, 1)
        tetrahedron_eidx:Add(4, 3, 2)

        tetrahedron_eidx:Add(5, 0, 3)
        tetrahedron_eidx:Add(5, 1, 0)
        tetrahedron_eidx:Add(5, 2, 2)
        tetrahedron_eidx:Add(5, 3, 2)

        hexahedron_fidx:Add(0, 0, 2)
        hexahedron_fidx:Add(0, 1, 0)
        hexahedron_fidx:Add(0, 2, 4)

        hexahedron_fidx:Add(1, 0, 4)
        hexahedron_fidx:Add(1, 1, 1)
        hexahedron_fidx:Add(1, 2, 2)

        hexahedron_fidx:Add(2, 0, 1)
        hexahedron_fidx:Add(2, 1, 4)
        hexahedron_fidx:Add(2, 2, 0)

        hexahedron_fidx:Add(3, 0, 0)
        hexahedron_fidx:Add(3, 1, 3)
        hexahedron_fidx:Add(3, 2, 1)

        hexahedron_fidx:Add(4, 0, 0)
        hexahedron_fidx:Add(4, 1, 2)
        hexahedron_fidx:Add(4, 2, 3)

        hexahedron_fidx:Add(5, 0, 1)
        hexahedron_fidx:Add(5, 1, 3)
        hexahedron_fidx:Add(5, 2, 2)

        hexahedron_eidx:Add(0, 0, 0)
        hexahedron_eidx:Add(0, 1, 0)
        hexahedron_eidx:Add(0, 2, 4)
        hexahedron_eidx:Add(0, 3, 0)

        hexahedron_eidx:Add(1, 0, 0)
        hexahedron_eidx:Add(1, 1, 1)
        hexahedron_eidx:Add(1, 2, 2)
        hexahedron_eidx:Add(1, 3, 1)

        hexahedron_eidx:Add(2, 0, 0)
        hexahedron_eidx:Add(2, 1, 2)
        hexahedron_eidx:Add(2, 2, 1)
        hexahedron_eidx:Add(2, 3, 2)

        hexahedron_eidx:Add(3, 0, 1)
        hexahedron_eidx:Add(3, 1, 1)
        hexahedron_eidx:Add(3, 2, 5)
        hexahedron_eidx:Add(3, 3, 2)

        hexahedron_eidx:Add(4, 0, 1)
        hexahedron_eidx:Add(4, 1, 0)
        hexahedron_eidx:Add(4, 2, 2)
        hexahedron_eidx:Add(4, 3, 0)

        hexahedron_eidx:Add(5, 0, 2)
        hexahedron_eidx:Add(5, 1, 2)
        hexahedron_eidx:Add(5, 2, 3)
        hexahedron_eidx:Add(5, 3, 2)

        hexahedron_eidx:Add(6, 0, 3)
        hexahedron_eidx:Add(6, 1, 1)
        hexahedron_eidx:Add(6, 2, 5)
        hexahedron_eidx:Add(6, 3, 0)

        hexahedron_eidx:Add(7, 0, 3)
        hexahedron_eidx:Add(7, 1, 0)
        hexahedron_eidx:Add(7, 2, 4)
        hexahedron_eidx:Add(7, 3, 2)

        hexahedron_eidx:Add(8, 0, 5)
        hexahedron_eidx:Add(8, 1, 1)
        hexahedron_eidx:Add(8, 2, 4)
        hexahedron_eidx:Add(8, 3, 1)
    end

    action Set(ConvexConvexDistanceSolver gjk)
        me:gjk = gjk
    end

    action GetCoordinates(ConvexConvexFace face, Vector3 out) returns Vector3
        Vector3 tmp
        Vector3 tmp1
        Vector3 tmp2

        Vector3 o
        o:Set(face:n):Scale(-face:d)

        Array<number> a

        tmp1:Set(face:v:Get(0):w):Subtract(o)
        tmp2:Set(face:v:Get(1):w):Subtract(o)
        tmp:Set(tmp1):CrossProduct(tmp2)
        a:Add(tmp:Length())

        tmp1:Set(face:v:Get(1):w):Subtract(o)
        tmp2:Set(face:v:Get(2):w):Subtract(o)
        tmp:Set(tmp1):CrossProduct(tmp2)
        a:Add(tmp:Length())

        tmp1:Set(face:v:Get(2):w):Subtract(o)
        tmp2:Set(face:v:Get(0):w):Subtract(o)
        tmp:Set(tmp1):CrossProduct(tmp2)
        a:Add(tmp:Length())

        number sm = a:Get(0) + a:Get(1) + a:Get(2)

        out:Set(a:Get(0), a:Get(1), a:Get(2))
        number scale = 1
        if sm > 0
            scale = sm
        end
        out:Scale(1 / scale)

        return out
    end

    action FindBest returns ConvexConvexFace
        ConvexConvexFace bf = undefined

        if root not= undefined
            ConvexConvexFace cf = root
            number bd = cstInf
            repeat while cf not= undefined
                if cf:d < bd
                    bd = cf:d
                    bf = cf
                end
                cf = cf:next
            end
        end

        return bf
    end

    action Set(ConvexConvexFace f, ConvexConvexVertex a, ConvexConvexVertex b, ConvexConvexVertex c) returns boolean
        Vector3 tmp1
        Vector3 tmp2
        Vector3 tmp3

        Vector3 nrm
        tmp1:Set(b:w):Subtract(a:w)
        tmp2:Set(c:w):Subtract(a:w)
        nrm:Set(tmp1):CrossProduct(tmp2)

        number length = nrm:Length()

        tmp1:Set(a:w):CrossProduct(b:w)
        tmp2:Set(b:w):CrossProduct(c:w)
        tmp3:Set(c:w):CrossProduct(a:w)

        boolean valid = tmp1:DotProduct(nrm) >= - EpaInfaceEps and
                        tmp2:DotProduct(nrm) >= - EpaInfaceEps and
                        tmp3:DotProduct(nrm) >= - EpaInfaceEps

        f:v:Get(0):Set(a)
        f:v:Get(1):Set(b)
        f:v:Get(2):Set(c)
        f:mark = 0
        f:n:Set(nrm)
        number scale = cstInf
        if length > 0
            scale = length
        end
        f:n:Scale(1 / scale)
        f:d = 0
        if 0 < -f:n:DotProduct(a:w)
            f:d = -f:n:DotProduct(a:w)
        end

        return valid
    end

    action NewFace(ConvexConvexVertex a, ConvexConvexVertex b, ConvexConvexVertex c) returns ConvexConvexFace
        ConvexConvexFace pf
        if Set(pf, a, b, c)
            if root not= undefined
                root:prev = pf
            end
            pf:prev = undefined
            pf:next = root
            root = pf
            nFaces = nFaces + 1
        else
            pf:prev = undefined
            pf:next = undefined
        end

        return pf
    end

    action Detach(ConvexConvexFace face)
        if face:prev not= undefined or face:next not= undefined
            nFaces = nFaces - 1
            if face = root
                root = face:next
                root:prev = undefined
            else
                if face:next = undefined
                    face:prev:SetNext(undefined)
                else
                    face:prev:SetNext(face:next)
                    face:next:SetPrevious(face:prev)
                end
            end
            face:prev = undefined
            face:next = undefined
        end
    end

    action Link(ConvexConvexFace f0, integer e0, ConvexConvexFace f1, integer e1)
        f0:faces:Set(e0, f1)
        f1:e:Set(e1, e0)
        f1:faces:Set(e1, f0)
        f0:e:Set(e0, e1)
    end

    action Support(Vector3 w) returns ConvexConvexVertex
        ConvexConvexVertex v
        gjk:Support(w, v)
        return v
    end

    action BuildHorizon(integer markid, ConvexConvexVertex w, ConvexConvexFace f, integer e, Array<ConvexConvexFace> cf, Array<ConvexConvexFace> ff) returns integer
        integer ne = 0
        if f:mark not= markid
            integer e1 = mod3:Get(e + 1)
            if f:n:DotProduct(w:w) + f:d > 0
                ConvexConvexFace nf = NewFace(f:v:Get(e1), f:v:Get(e), w)
                Link(nf, 0, f, e)
                if cf:Get(0) not= undefined
                    Link(cf:Get(0), 1, nf, 2)
                else
                    ff:Set(0, nf)
                end
                cf:Set(0, nf)
                ne = 1
            else
                integer e2 = mod3:Get(e + 2)
                Detach(f)
                f:mark = markid
                ne = ne + BuildHorizon(markid, w, f:faces:Get(e1), f:e:Get(e1), cf, ff)
                ne = ne + BuildHorizon(markid, w, f:faces:Get(e2), f:e:Get(e2), cf, ff)
            end
        end
        
        return ne
    end

    action EvaluatePD returns number
        return EvaluatePD(EpaAccuracy)
    end

    action EvaluatePD(number accuracy) returns number
        Vector3 tmp

        ConvexConvexFace bestFace = undefined
        integer markid = 1
        depth = -cstInf
        normal:Set(0, 0, 0)
        root = undefined
        nFaces = 0
        iterations = 0
        failed = false

        if gjk:EncloseOrigin()
            Table<integer> pfidx_ptr = undefined
            integer pfidx_index = 0
            
            integer nfidx = 0

            Table<integer> peidx_ptr = undefined
            integer peidx_index = 0

            integer neidx = 0
            Array<ConvexConvexVertex> basemkv
            Array<ConvexConvexFace> basefaces

            if gjk:order = 3
                //Tetrahedron
                pfidx_ptr = tetrahedron_fidx
                pfidx_index = 0

                nfidx = 4

                peidx_ptr = tetrahedron_eidx
                peidx_index = 0

                neidx = 6                
            elseif gjk:order = 4
                //Hexahedron
                pfidx_ptr = hexahedron_fidx
                pfidx_index = 0
                
                nfidx = 6

                peidx_ptr = hexahedron_eidx
                peidx_index = 0

                neidx = 9
            end
         
            integer i = 0
            repeat while i <= gjk:order
                ConvexConvexVertex mkv
                basemkv:Add(mkv)
                basemkv:Get(i):Set(gjk:simplex:Get(i))
                i = i + 1
            end

            i = 0
            repeat while i < nfidx
                ConvexConvexFace face = NewFace(basemkv:Get(pfidx_ptr:Get(pfidx_index, 0)), basemkv:Get(pfidx_ptr:Get(pfidx_index, 1)), basemkv:Get(pfidx_ptr:Get(pfidx_index, 2)))
                basefaces:Add(face)
                i = i + 1
                pfidx_index = pfidx_index + 1
            end

            i = 0
            repeat while i < neidx
                Link(basefaces:Get(peidx_ptr:Get(peidx_index, 0)), peidx_ptr:Get(peidx_index, 1), basefaces:Get(peidx_ptr:Get(peidx_index, 2)), peidx_ptr:Get(peidx_index, 3))

                i = i + 1
                peidx_index = peidx_index + 1
            end
        end

        if nFaces = 0
            return depth
        end

        boolean break = false
        repeat while iterations < EpaMaxIterations and not break
            ConvexConvexFace bf = FindBest()

            if bf not= undefined
                tmp:Set(bf:n):Scale(-1)
                ConvexConvexVertex w = Support(tmp)
                number d = bf:n:DotProduct(w:w) + bf:d
                bestFace = bf
                if d < -accuracy
                    Array<ConvexConvexFace> cf
                    Array<ConvexConvexFace> ff
                    integer nf = 0
                    Detach(bf)
                    markid = markid + 1
                    bf:mark = markid
                    integer j = 0
                    repeat while j < 3
                        nf = nf + BuildHorizon(markid, w, bf:faces:Get(j), bf:e:Get(j), cf, ff)
                        j = j + 1
                    end
                    if nf <= 2
                        break = true
                    end

                    if not break
                        Link(cf:Get(0), 1, ff:Get(0), 2)
                    end
                else
                    break = true
                end
            else
                break = true
            end

            if not break
                iterations = iterations + 1
            end
        end

        if bestFace not= undefined
            Vector3 v
            Vector3 b = GetCoordinates(bestFace, v)
            normal:Set(bestFace:n)
            depth = 0
            if bestFace:d > 0
                depth = bestFace:d
            end

            integer i = 0
            repeat while i < 2
                number s = 1
                if i not= 0
                    s = -1
                end

                integer j = 0
                repeat while j < 3
                    tmp:Set(bestFace:v:Get(j):r)
                    features:Set(i, j, gjk:LocalSupport(tmp, i))

                    j = j + 1
                end

                i = i + 1
            end

            Vector3 tmp1
            Vector3 tmp2
            Vector3 tmp3

            tmp1:Set(features:Get(0, 0)):Scale(b:GetX())
            tmp2:Set(features:Get(0, 1)):Scale(b:GetY())
            tmp3:Set(features:Get(0, 2)):Scale(b:GetZ())
            nearest:Get(0):Set(tmp1):Add(tmp2):Add(tmp3)

            tmp1:Set(features:Get(1, 0)):Scale(b:GetX())
            tmp2:Set(features:Get(1, 1)):Scale(b:GetY())
            tmp3:Set(features:Get(1, 2)):Scale(b:GetZ())
            nearest:Get(1):Set(tmp1):Add(tmp2):Add(tmp3)
            
        else
            failed = true
        end

        return depth
    end
end