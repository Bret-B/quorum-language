package Libraries.Game.Collision.Shapes

use Libraries.Game.Collision.Shapes.CollisionShape3D
use Libraries.Containers.Array
use Libraries.Compute.Vector3
use Libraries.Compute.Math
use Libraries.Compute.Plane
use Libraries.Compute.BitwiseOperations
use Libraries.Compute.Matrix3
use Libraries.Game.BoundingBox
use Libraries.Game.Collision.Transform3D

class Cylinder is CollisionShape3D
    Array<Vector3> directions
    Array<Vector3> supporting

    Vector3 localBoundingBoxMinimum
    Vector3 localBoundingBoxMaximum
    boolean isLocalBoundingBoxValid = false

    integer upAxis = 1

    on create
        parent:CollisionShape3D:SetType(parent:CollisionShape3D:CYLINDER)

        parent:CollisionShape3D:localScaling:Set(1, 1, 1)
        
        repeat 6 times
            Vector3 direction
            Vector3 support
            
            directions:Add(direction)
            supporting:Add(support)
        end

        directions:Get(0):Set(1, 0, 0)
        directions:Get(1):Set(0, 1, 0)
        directions:Get(2):Set(0, 0, 1)
        directions:Get(3):Set(-1, 0, 0)
        directions:Get(4):Set(0, -1, 0)
        directions:Get(5):Set(0, 0, -1)

        localBoundingBoxMinimum:Set(1, 1, 1)
        localBoundingBoxMaximum:Set(-1, -1, -1)
    end

    action CalculateLocalInertia(number mass, Vector3 inertia)
        Vector3 halfExtents = GetHalfExtentsWithMargin()

        number lx = 2 * halfExtents:GetX()
        number ly = 2 * halfExtents:GetY()
        number lz = 2 * halfExtents:GetZ()

        inertia:Set(mass / 12 * (ly * ly + lz * lz), mass / 12 * (lx * lx + lz * lz), mass / 12 * (lx * lx + ly * ly))
    end

    action ComputeBoundingBox(BoundingBox boundingBox, Transform3D transform)
        number margin = GetMargin()

        Vector3 localHalfExtents
        localHalfExtents:Set(localBoundingBoxMaximum)
        localHalfExtents:Subtract(localBoundingBoxMinimum)
        localHalfExtents:Scale(0.5)

        localHalfExtents:SetX(localHalfExtents:GetX() + margin)
        localHalfExtents:SetY(localHalfExtents:GetY() + margin)
        localHalfExtents:SetZ(localHalfExtents:GetZ() + margin)

        Vector3 localCenter
        localCenter:Set(localBoundingBoxMaximum)
        localCenter:Add(localBoundingBoxMinimum)
        localCenter:Scale(0.5)

        Math math

        Matrix3 abs_b
        abs_b:Set(transform:GetBasis())
        abs_b:Set(math:AbsoluteValue(abs_b:row0column0), math:AbsoluteValue(abs_b:row0column1), math:AbsoluteValue(abs_b:row0column2),
                  math:AbsoluteValue(abs_b:row1column0), math:AbsoluteValue(abs_b:row1column1), math:AbsoluteValue(abs_b:row1column2),
                  math:AbsoluteValue(abs_b:row2column0), math:AbsoluteValue(abs_b:row2column1), math:AbsoluteValue(abs_b:row2column2))


        Vector3 center
        transform:Transform(center)

        Vector3 extent
        Vector3 temp

        temp:Set(abs_b:row0column0, abs_b:row0column1, abs_b:row0column2)
        extent:SetX(temp:DotProduct(localHalfExtents))
        temp:Set(abs_b:row1column0, abs_b:row1column1, abs_b:row1column2)
        extent:SetY(temp:DotProduct(localHalfExtents))
        temp:Set(abs_b:row2column0, abs_b:row2column1, abs_b:row2column2)
        extent:SetZ(temp:DotProduct(localHalfExtents))

        Vector3 boundingBoxMinimum
        Vector3 boundingBoxMaximum

        boundingBoxMinimum:Set(center)
        boundingBoxMinimum:Subtract(extent)
        boundingBoxMaximum:Set(center)
        boundingBoxMaximum:Add(extent)

        boundingBox:Set(boundingBoxMinimum, boundingBoxMaximum)
    end

    action Set(number width, number height, number depth)
        Vector3 halfExtents
        halfExtents:Set(width / 2, height / 2, depth / 2)
        Set(halfExtents)
    end

    private action Set(Vector3 halfExtents)
        Vector3 margin
        margin:Set(GetMargin(), GetMargin(), GetMargin())
        parent:CollisionShape3D:implicitShapeDimensions:Set(halfExtents:GetX() * parent:CollisionShape3D:localScaling:GetX(), 
                                                            halfExtents:GetY() * parent:CollisionShape3D:localScaling:GetY(), 
                                                            halfExtents:GetZ() * parent:CollisionShape3D:localScaling:GetZ())
        parent:CollisionShape3D:implicitShapeDimensions:Subtract(margin)
        upAxis = 1
        RecalculateLocalBoundingBox()
    end

    action SetUpAxis(integer upAxis)
        me:upAxis = upAxis
    end

    action GetHalfExtentsWithMargin returns Vector3
        Vector3 halfExtents = GetHalfExtentsWithoutMargin()
        Vector3 margin
        margin:Set(GetMargin(), GetMargin(), GetMargin())
        halfExtents:Add(margin)
        return halfExtents
    end

    action GetHalfExtentsWithoutMargin returns Vector3
        Vector3 out
        out:Set(parent:CollisionShape3D:implicitShapeDimensions)
        return out
    end

    action LocalGetSupportingVertex(Vector3 vector) returns Vector3
        Vector3 supVertex = LocalGetSupportingVertexWithoutMargin(vector)

        if GetMargin() not= 0
            Vector3 vecnorm
            vecnorm:Set(vector)

            if vecnorm:LengthSquared() < 0.000000119209290 * 0.000000119209290
                vecnorm:Set(-1, -1, -1)
            end
            vecnorm:Normalize()
            Vector3 temp
            temp:Set(supVertex)
            supVertex:Set(vecnorm)
            supVertex:Scale(GetMargin())
            supVertex:Add(temp)
        end

        return supVertex
    end

    action LocalGetSupportingVertexWithoutMargin(Vector3 vector) returns Vector3
        if upAxis = 0
            return CylinderLocalSupportX(GetHalfExtentsWithoutMargin(), vector)
        elseif upAxis = 1
            return CylinderLocalSupportY(GetHalfExtentsWithoutMargin(), vector)
        else
            return CylinderLocalSupportZ(GetHalfExtentsWithoutMargin(), vector)
        end
    end

    action SetMargin(number margin)
        Vector3 oldMargin
        oldMargin:Set(GetMargin(), GetMargin(), GetMargin())
        Vector3 implicitShapeDimensionsWithMargin
        implicitShapeDimensionsWithMargin:Set(parent:CollisionShape3D:implicitShapeDimensions)
        implicitShapeDimensionsWithMargin:Add(oldMargin)

        parent:CollisionShape3D:SetMargin(margin)
        Vector3 newMargin
        newMargin:Set(GetMargin(), GetMargin(), GetMargin())
        parent:CollisionShape3D:implicitShapeDimensions:Set(implicitShapeDimensionsWithMargin)
        parent:CollisionShape3D:implicitShapeDimensions:Subtract(newMargin)
    end

    action GetPlane(Vector3 planeNormal, Vector3 planeSupport, integer i)
        Plane plane
        GetPlaneEquation(plane, i)
        planeNormal:Set(plane:GetNormal())
        Vector3 temp
        temp:Set(planeNormal)
        temp:Scale(-1)
        planeSupport:Set(LocalGetSupportingVertex(temp))
    end

    action GetNumberOfPlanes returns integer
        return 6
    end

    action GetNumberOfVertices returns integer
        return 8
    end

    action GetNumberOfEdges returns integer
        return 12
    end

    action GetVertex(integer i, Vector3 vertex)
        BitwiseOperations bo
        Vector3 halfExtents = GetHalfExtentsWithoutMargin()
        
        vertex:Set(halfExtents:GetX() * (1 - (bo:And(i, 1))) - halfExtents:GetX() * (bo:And(i, 1)),
                   halfExtents:GetY() * (1 - bo:ShiftRight(bo:And(i, 2), 1)) - halfExtents:GetY() * bo:ShiftRight(bo:And(i, 2), 1),
                   halfExtents:GetZ() * (1 - bo:ShiftRight(bo:And(i, 4), 2)) - halfExtents:GetZ() * bo:ShiftRight(bo:And(i, 4), 2))
    end

    action GetPlaneEquation(Plane plane, integer i)
        Vector3 halfExtents = GetHalfExtentsWithoutMargin()

        if i = 0
            plane:Set(1, 0, 0, -1 * halfExtents:GetX())
        elseif i = 1
            plane:Set(-1, 0, 0, -1 * halfExtents:GetX())
        elseif i = 2
            plane:Set(0, 1, 0, -1 * halfExtents:GetY())
        elseif i = 3
            plane:Set(0, -1, 0, -1 * halfExtents:GetY())
        elseif i = 4
            plane:Set(0, 0, 1, -1 * halfExtents:GetZ())
        elseif i = 5
            plane:Set(0, 0, -1, -1 * halfExtents:GetZ())
        end
    end

    action GetEdge(integer i, Vector3 pa, Vector3 pb)
        integer edgeVertex0 = 0
        integer edgeVertex1 = 0

        if i = 0
            edgeVertex0 = 0
            edgeVertex1 = 1
        elseif i = 1
            edgeVertex0 = 0
            edgeVertex1 = 2
        elseif i = 2
            edgeVertex0 = 1
            edgeVertex1 = 3
        elseif i = 3
            edgeVertex0 = 2
            edgeVertex1 = 3
        elseif i = 4
            edgeVertex0 = 0
            edgeVertex1 = 4
        elseif i = 5
            edgeVertex0 = 1
            edgeVertex1 = 5
        elseif i = 6
            edgeVertex0 = 2
            edgeVertex1 = 6
        elseif i = 7
            edgeVertex0 = 3
            edgeVertex1 = 7
        elseif i = 8
            edgeVertex0 = 4
            edgeVertex1 = 5
        elseif i = 9
            edgeVertex0 = 4
            edgeVertex1 = 6
        elseif i = 10
            edgeVertex0 = 5
            edgeVertex1 = 7
        elseif i = 11
            edgeVertex0 = 6
            edgeVertex1 = 7
        end

        GetVertex(edgeVertex0, pa)
        GetVertex(edgeVertex1, pb)
    end

    action IsInside(Vector3 point, number tolerance) returns boolean
        Vector3 halfExtents = GetHalfExtentsWithoutMargin()

        boolean result = (point:GetX() <= (halfExtents:GetX() + tolerance)) and
                         (point:GetX() >= (-1 * halfExtents:GetX() - tolerance)) and
                         (point:GetY() <= (halfExtents:GetY() + tolerance)) and
                         (point:GetY() >= (-1 * halfExtents:GetY() - tolerance)) and
                         (point:GetZ() <= (halfExtents:GetZ() + tolerance)) and
                         (point:GetZ() >= (-1 * halfExtents:GetZ() - tolerance))

        return result
    end

    action CylinderLocalSupportX(Vector3 halfExtents, Vector3 vector) returns Vector3
        return CylinderLocalSupport(halfExtents, vector, 0, 1, 0, 2)
    end

    action CylinderLocalSupportY(Vector3 halfExtents, Vector3 vector) returns Vector3
        return CylinderLocalSupport(halfExtents, vector, 1, 0, 1, 2)
    end

    action CylinderLocalSupportZ(Vector3 halfExtents, Vector3 vector) returns Vector3
        return CylinderLocalSupport(halfExtents, vector, 2, 0, 2, 1)
    end

    private action CylinderLocalSupport(Vector3 halfExtents, Vector3 vector, integer cylinderUpAxis, integer XX, integer YY, integer ZZ) returns Vector3
        Vector3 out
        number radius = GetCoordinate(halfExtents, XX)

        number halfHeight = GetCoordinate(halfExtents, cylinderUpAxis)

        number d = 0
        Math math
        number s = math:SquareRoot(GetCoordinate(vector, XX) * GetCoordinate(vector, XX) + GetCoordinate(vector, ZZ) * GetCoordinate(vector, ZZ))

        if s not= 0
            d = radius / s
            SetCoordinate(out, XX, GetCoordinate(vector, XX) * d)
            number value = halfHeight
            if GetCoordinate(vector, YY) < 0
                value = -halfHeight
            end
            SetCoordinate(out, YY, value)
            SetCoordinate(out, ZZ, GetCoordinate(vector, ZZ) * d)
            return out
        else
            SetCoordinate(out, XX, radius)
            number value = halfHeight
            if GetCoordinate(vector, YY) < 0
                value = -halfHeight
            end
            SetCoordinate(out, YY, value)
            SetCoordinate(out, ZZ, 0)
            return out
        end
    end

    private action GetCoordinate(Vector3 vector, integer coordinate) returns number
        if coordinate = 0
            return vector:GetX()
        elseif coordinate = 1
            return vector:GetY()
        else
            return vector:GetZ()
        end
    end

    private action SetCoordinate(Vector3 vector, integer coordinate, number value)
        if coordinate = 0
            vector:SetX(value)
        elseif coordinate = 1
            vector:SetY(value)
        else
            vector:SetZ(value)
        end
    end

    action GetUpAxis returns integer
        return upAxis
    end

    action GetRadius returns number
        if upAxis = 0
            return GetHalfExtentsWithMargin():GetY()
        elseif upAxis = 1
            return GetHalfExtentsWithMargin():GetX()
        else
            return GetHalfExtentsWithMargin():GetX()
        end
    end

    action GetNumberPreferredPenetrationDirections returns integer
        return 6
    end

    action GetPreferredPenetrationDirection(integer index, Vector3 penetrationVector)
        if index = 0
            penetrationVector:Set(1, 0, 0)
        elseif index = 1
            penetrationVector:Set(-1, 0, 0)
        elseif index = 2
            penetrationVector:Set(0, 1, 0)
        elseif index = 3
            penetrationVector:Set(0, -1, 0)
        elseif index = 4
            penetrationVector:Set(0, 0, 1)
        elseif index = 5
            penetrationVector:Set(0, 0, -1)
        end
    end

    action Copy returns CollisionShape3D
        Cylinder cylinder
        cylinder:upAxis = upAxis
        cylinder:Set(parent:CollisionShape3D:implicitShapeDimensions)
        cylinder:parent:CollisionShape3D:localScaling:Set(parent:CollisionShape3D:localScaling)
        return cylinder
    end

    action RecalculateLocalBoundingBox
        isLocalBoundingBoxValid = true

        BatchedUnitVectorGetSupportingVertexWithoutMargin(directions, supporting, 6)

        integer i = 0
        repeat while i < 3
            SetCoordinate(localBoundingBoxMaximum, i, GetCoordinate(supporting:Get(i), i) + parent:CollisionShape3D:collisionMargin)
            SetCoordinate(localBoundingBoxMinimum, i, GetCoordinate(supporting:Get(i + 3), i) + parent:CollisionShape3D:collisionMargin)
            i = i + 1
        end
    end

    private action BatchedUnitVectorGetSupportingVertexWithoutMargin(Array<Vector3> vectors, Array<Vector3> supportVerticesOut, integer numVectors)
        integer i = 0
        repeat while i < numVectors
            if upAxis = 0
                supportVerticesOut:Get(i):Set(CylinderLocalSupportX(GetHalfExtentsWithoutMargin(), vectors:Get(i)))
            elseif upAxis = 1
                supportVerticesOut:Get(i):Set(CylinderLocalSupportY(GetHalfExtentsWithoutMargin(), vectors:Get(i)))
            else
                supportVerticesOut:Get(i):Set(CylinderLocalSupportZ(GetHalfExtentsWithoutMargin(), vectors:Get(i)))
            end

            i = i + 1
        end
    end

    action GetChildCount returns integer
        return 1
    end
end