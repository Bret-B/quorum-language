package Libraries.Game.Collision.Shapes

use Libraries.Compute.Vector3
use Libraries.Game.Collision.PhysicsPosition3D
use Libraries.Containers.Array
use Libraries.Compute.Math
use Libraries.Game.BoundingBox

class CollisionShape3D
    public constant integer MAX_PREFERRED_PENETRATION_DIRECTIONS = 10

    public constant integer SPHERE = 0
    public constant integer BOX = 1
    public constant integer CYLINDER = 2

    Vector3 localScaling
    Vector3 implicitShapeDimensions
    number collisionMargin = 0.04
    integer numberPreferredPenetrationDirections = 0

    integer type = 0

    on create
        implicitShapeDimensions:Set(1, 1, 1)
    end

    blueprint action ComputeBoundingBox(BoundingBox boundingBox, PhysicsPosition3D transform)
    
    action GetBoundingSphere(Vector3 center) returns number
        Vector3 temp1
        Vector3 temp2
        PhysicsPosition3D transform
        transform:SetToIdentity()
        BoundingBox boundingBox

        ComputeBoundingBox(boundingBox, transform)

        temp1:Set(boundingBox:GetMaximum())
        temp1:Subtract(boundingBox:GetMinimum())

        temp2:Set(boundingBox:GetMinimum())
        temp2:Add(boundingBox:GetMaximum())
        center:Set(temp2)
        center:Scale(0.5)

        return temp1:Length() * 0.5
    end

    action GetAngularMotionDisc returns number
        Vector3 center
        number disc = GetBoundingSphere(center)
        disc = disc + center:Length()
        return disc
    end

    action CalculateTemporalBoundingBox(PhysicsPosition3D currentTransform, Vector3 linearVelocity, Vector3 angularVelocity, number timeStep, 
                                        BoundingBox temporalBoundingBox)
        ComputeBoundingBox(temporalBoundingBox, currentTransform)
        
        number temporalAabbMaxx = temporalBoundingBox:GetMaximum():GetX()
        number temporalAabbMaxy = temporalBoundingBox:GetMaximum():GetY()
        number temporalAabbMaxz = temporalBoundingBox:GetMaximum():GetZ()
        number temporalAabbMinx = temporalBoundingBox:GetMinimum():GetX()
        number temporalAabbMiny = temporalBoundingBox:GetMinimum():GetY()
        number temporalAabbMinz = temporalBoundingBox:GetMinimum():GetZ()

        Vector3 linearMotion
        linearMotion:Set(linearVelocity)
        linearMotion:Scale(timeStep)

        if linearMotion:GetX() > 0
            temporalAabbMaxx = temporalAabbMaxx + linearMotion:GetX()
        else
            temporalAabbMinx = temporalAabbMinx + linearMotion:GetX()
        end

        if linearMotion:GetY() > 0
            temporalAabbMaxy = temporalAabbMaxy + linearMotion:GetY()
        else
            temporalAabbMiny = temporalAabbMiny + linearMotion:GetY()
        end

        if linearMotion:GetZ() > 0
            temporalAabbMaxz = temporalAabbMaxz + linearMotion:GetZ()
        else
            temporalAabbMinz = temporalAabbMinz + linearMotion:GetZ()
        end

        number angularMotion = angularVelocity:Length() * GetAngularMotionDisc() * timeStep
        Vector3 angularMotion3D
        angularMotion3D:Set(angularMotion, angularMotion, angularMotion)
        temporalBoundingBox:GetMinimum():Set(temporalAabbMinx, temporalAabbMiny, temporalAabbMinz)
        temporalBoundingBox:GetMaximum():Set(temporalAabbMaxx, temporalAabbMaxy, temporalAabbMaxz)

        temporalBoundingBox:GetMinimum():Subtract(angularMotion3D)
        temporalBoundingBox:GetMaximum():Add(angularMotion3D)
    end

    action GetType returns integer
        return type
    end

    action SetType(integer type)
        me:type = type
    end

    action SetLocalScaling(Vector3 scaling)
        Math math
        localScaling:Set(math:AbsoluteValue(scaling:GetX()), math:AbsoluteValue(scaling:GetY()), math:AbsoluteValue(scaling:GetZ()))
    end

    action GetLocalScaling(Vector3 out) returns Vector3
        out:Set(localScaling)
        return out
    end

    blueprint action CalculateLocalInertia(number mass, Vector3 intertia)

    action SetMargin(number margin)
        collisionMargin = margin
    end

    action GetMargin returns number
        return collisionMargin
    end

    action LocalGetSupportingVertex(Vector3 vector) returns Vector3
        Vector3 supVertex = LocalGetSupportingVertexWithoutMargin(vector)
        
        if GetMargin() not= 0
            Vector3 vecnorm
            vecnorm:Set(vector)
            if vecnorm:LengthSquared() < 0.000000119209290 * 0.000000119209290
                vecnorm:Set(-1, -1, -1)
            end

            vecnorm:Normalize()
            Vector3 temp
            temp:Set(supVertex)
            supVertex:Set(vecnorm)
            supVertex:Scale(GetMargin())
            supVertex:Add(temp)
        end
        
        return supVertex
    end

    blueprint action LocalGetSupportingVertexWithoutMargin(Vector3 vector) returns Vector3

    blueprint action GetNumberPreferredPenetrationDirections returns integer

    blueprint action GetPreferredPenetrationDirection(integer index, Vector3 penetrationVector)

    blueprint action Copy returns CollisionShape3D

    blueprint action GetChildCount returns integer
end