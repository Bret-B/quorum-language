package Libraries.Game.Physics

use Libraries.Compute.Vector3
use Libraries.Game.Collision.CollisionPoint3D

/*
This class is used by CollisionSolver3D to store all of the 
criteria, ex. the direction that one object should go relative to another object.
*/
class SolverConstraint3D
    public constant integer SOLVER_CONTACT = 0
    public constant integer SOLVER_FRICTION = 1

    Vector3 relativePosition1CrossNormal
    Vector3 contactNormal

    Vector3 relativePosition2CrossNormal
    Vector3 angularComponentA

    Vector3 angularComponentB

    number appliedPushImpulse = 0
    
    number appliedImpulse = 0
    integer bodyIDA = 0
    integer bodyIDB = 0
    
    number friction = 0
    number restitution = 0
    number jacobianDiagonalABInverse = 0
    number penetration = 0

    integer constraintType = 0
    integer frictionIndex = 0
    CollisionPoint3D originalContactPoint

    /*
    This action sets the cross product of a vector from the collision point to the center
    of the first object and the collision normal.
    */
    action SetRelativePosition1CrossNormal(Vector3 vector)
        me:relativePosition1CrossNormal = vector
    end

    /*
    This action returns the cross product of a vector from the collision point to the center
    of the first object and the collision normal.
    */
    action GetRelativePosition1CrossNormal returns Vector3
        return relativePosition1CrossNormal
    end

    /*
    This action sets the collision normal between two colliding objects.
    */
    action SetContactNormal(Vector3 normal)
        me:contactNormal = normal
    end

    /*
    This action returns the collision normal between two colliding objects.
    */
    action GetContactNormal returns Vector3
        return contactNormal
    end

    /*
    This action sets the cross product of a vector from the collision point to the center
    of the second object and the collision normal.
    */
    action SetRelativePosition2CrossNormal(Vector3 vector)
        me:relativePosition2CrossNormal = vector
    end

    /*
    This action returns the cross product of a vector from the collision point to the center
    of the second object and the collision normal.
    */
    action GetRelativePosition2CrossNormal returns Vector3
        return relativePosition2CrossNormal
    end


    /*
    This action sets the direction (global coordinates) at which an angular impulse should be applied
    due to the normal impulse on object A.
    */
    action SetAngularComponentA(Vector3 vector)
        me:angularComponentA = vector
    end


    /*
    This action returns the direction (global coordinates) at which an angular impulse should be applied
    due to the normal impulse on object A.
    */
    action GetAngularComponentA returns Vector3
        return angularComponentA
    end

    /*
    This action sets the direction (global coordinates) at which an angular impulse should be applied
    due to the normal impulse on object B.
    */
    action SetAngularComponentB(Vector3 vector)
        me:angularComponentB = vector
    end

    /*
    This action gets the direction (global coordinates) at which an angular impulse should be applied
    due to the normal impulse on object B.
    */
    action GetAngularComponentB returns Vector3
        return angularComponentB
    end

    /*
    This action sets the impulse that is needed to stop the two colliding objects 
    from penetrating each other.
    */
    action SetAppliedPushImpulse(number impulse)
        me:appliedPushImpulse = impulse
    end

    /*
    This action gets the impulse that is needed to stop the two colliding objects 
    from penetrating each other.
    */
    action GetAppliedPushImpulse returns number
        return appliedPushImpulse
    end

    /*
    This action sets the impulse that is needed to separate the two colliding objects.
    */
    action SetAppliedImpulse(number impulse)
        me:appliedImpulse = impulse
    end

    /*
    This action gets the impulse that is needed to separate the two colliding objects.
    */
    action GetAppliedImpulse returns number
        return appliedImpulse
    end

    /*
    This action sets if the first object would be responding to forces/torques (id = -2)
    or not (id = -1).
    */
    action SetBodyIDA(integer id)
        me:bodyIDA = id
    end
    
    /*
    This action gets if the first object would be responding to forces/torques (id = -2)
    or not (id = -1).
    */
    action GetBodyIDA returns integer
        return bodyIDA
    end

    /*
    This action sets if the second object would be responding to forces/torques (id = -2)
    or not (id = -1).
    */
    action SetBodyIDB(integer id)
        me:bodyIDB = id
    end
    
    /*
    This action gets if the second object would be responding to forces/torques (id = -2)
    or not (id = -1).
    */
    action GetBodyIDB returns integer
        return bodyIDB
    end

    /*
    This action sets the friction between the two colliding objects.
    */
    action SetFriction(number friction)
        me:friction = friction
    end

    /*
    This action gets the friction between the two colliding objects.
    */
    action GetFriction returns number
        return friction
    end

    /*
    This action sets the restitution between the two colliding objects.
    */
    action SetRestitution(number restitution)
        me:restitution = restitution
    end


    /*
    This action gets the restitution between the two colliding objects.
    */
    action GetRestitution returns number
        return restitution
    end

    /*
    This action sets a number that is used to scale the impulse that is used
    to avoid penetration of the two objects and the impulse that is used to
    move the two objects apart. These impulses will be applied along the collision
    normal between the two objects.
    */
    action SetJacobianDiagonalABInverse(number jacobian)
        me:jacobianDiagonalABInverse = jacobian
    end

    /*
    This action gets a number that is used to scale the impulse that is used
    to avoid penetration of the two objects and the impulse that is used to
    move the two objects apart. These impulses will be applied along the collision
    normal between the two objects.
    */
    action GetJacobianDiagonalABInverse returns number
        return jacobianDiagonalABInverse
    end

    /*
    This action records what the current penetration between the two objects is.
    */
    action SetPenetration(number penetration)
        me:penetration = penetration
    end

    /*
    This action gets what the current penetration between the two objects is.
    */
    action GetPenetration returns number
        return penetration
    end

    /*
    This action sets whether the solver is going to be a friction solver or a contact solver.
    */
    action SetConstraintType(integer type)
        me:constraintType = type
    end

    /*
    This action gets the solver type.
    */ 
    action GetConstraintType returns integer
        return constraintType
    end

    /*
    This action sets the friction index.
    */
    action SetFrictionIndex(integer index)
        me:frictionIndex = index
    end

    /*
    This action gets the friction index.
    */
    action GetFrictionIndex returns integer
        return frictionIndex
    end

    /*
    This action stores a collision point inside this SolverConstraint3D class.
    */
    action SetOriginalContactPoint(CollisionPoint3D contactPoint)
        me:originalContactPoint = contactPoint
    end

    /*
    This action gets the collision point that is inside this SolverConstraint3D class.
    */
    action GetOriginalContactPoint returns CollisionPoint3D
        return originalContactPoint
    end
end