package Libraries.Game.Physics

use Libraries.Containers.Array
use Libraries.Compute.Vector2
use Libraries.Interface.Events.CollisionEvent2D
use Libraries.Game.Physics.CollisionPositionConstraint
use Libraries.Game.Physics.CollisionVelocityConstraint
use Libraries.Interface.Item2D
use Libraries.Game.Collision.Shapes.CollisionShape2D
use Libraries.Game.Collision.LocalCollisionPoints2D
use Libraries.Game.Collision.CollisionPoint2D
use Libraries.Game.Collision.PhysicsPosition2D
use Libraries.Game.Collision.GlobalCollisionPoints2D
use Libraries.Containers.Table
use Libraries.Game.Physics.PositionSolver

class CollisionSolver2D 
    constant number k_maxConditionNumber = 100.0
    
    TimeStep2D timeStep
    Array<Vector2> positions
    Array<number> angles
    Array<Vector2> velocities
    Array<number> ws
    Array<CollisionPositionConstraint> positionConstraints
    Array<CollisionVelocityConstraint> velocityConstraints
    Array<CollisionEvent2D> collisions
    integer count = 0

    on create
        repeat 256 times
            CollisionPositionConstraint positionConstraint
            CollisionVelocityConstraint velocityConstraint
            positionConstraints:Add(positionConstraint)
            velocityConstraints:Add(velocityConstraint)
        end
    end

    action SetTimeStep(TimeStep2D timeStep)
        me:timeStep = timeStep
    end

    action SetCollisionList(Array<CollisionEvent2D> collisionList)
        collisions = collisionList
        count = collisionList:GetSize()
    end

    action SetPositionsList(Array<Vector2> positionsList)
        positions = positionsList
    end

    action SetAnglesList(Array<number> anglesList)
        angles = anglesList
    end

    action SetLinearVelocitiesList(Array<Vector2> linearVelocitiesList)
        velocities = linearVelocitiesList
    end

    action SetAngularVelocitiesList(Array<number> angularVelocitiesList)
        ws = angularVelocitiesList
    end

    action Initialize
        integer i = 0
        repeat while i < me:count
            CollisionEvent2D collision = collisions:Get(i)

            Item2D bodyA = collision:GetItemA()
            Item2D bodyB = collision:GetItemB()
            CollisionShape2D shapeA = bodyA:GetShape()
            CollisionShape2D shapeB = bodyB:GetShape()
            number radiusA = shapeA:GetRadius()
            number radiusB = shapeB:GetRadius()
            LocalCollisionPoints2D collisionPoints = collision:GetCollisionPoints()

            integer pointCount = collisionPoints:GetPointCount()

            CollisionVelocityConstraint vc = velocityConstraints:Get(i)
            vc:friction = collision:GetFriction()
            vc:restitution = collision:GetRestitution()
            vc:tangentSpeed = collision:GetTangentSpeed()
            vc:indexA = bodyA:GetCollisionGroupIndex()
            vc:indexB = bodyB:GetCollisionGroupIndex()
            vc:SetInverseMassA(bodyA:GetInverseMass())
            vc:SetInverseMassB(bodyB:GetInverseMass())
            vc:SetInverseInertiaA(bodyA:GetInverseInertia())
            vc:SetInverseInertiaB(bodyB:GetInverseInertia())
            vc:SetCollisionIndex(i)
            vc:SetPointCount(pointCount)

            CollisionPositionConstraint pc = positionConstraints:Get(i)
            pc:indexA = bodyA:GetCollisionGroupIndex()
            pc:indexB = bodyB:GetCollisionGroupIndex()
            pc:SetInverseMassA(bodyA:GetInverseMass())
            pc:SetInverseMassB(bodyB:GetInverseMass())
            pc:GetLocalCenterA():Set(bodyA:GetSweep():GetLocalCenter())
            pc:GetLocalCenterB():Set(bodyB:GetSweep():GetLocalCenter())
            pc:SetInverseInertiaA(bodyA:GetInverseInertia())
            pc:SetInverseInertiaB(bodyB:GetInverseInertia())
            pc:GetLocalNormal():Set(collisionPoints:GetLocalNormal())
            pc:GetLocalPoint():Set(collisionPoints:GetLocalPoint())
            pc:pointCount = pointCount
            pc:radiusA = radiusA
            pc:radiusB = radiusB
            pc:type = collisionPoints:GetType()

            integer j = 0
            repeat while j < pointCount
                CollisionPoint2D cp = collisionPoints:GetPoints():Get(j)
                VelocityConstraintPoint vcp = vc:GetPoints():Get(j)

                if timeStep:IsWarmStarting()
                    vcp:SetNormalImpulse(timeStep:GetTimeStepRatio() * cp:GetNormalImpulse())
                    vcp:SetTangentImpulse(timeStep:GetTimeStepRatio() * cp:GetNormalImpulse())
                else
                    vcp:normalImpulse = 0
                    vcp:tangentImpulse = 0
                end

                vcp:GetRadiusA():SetZero()
                vcp:GetRadiusB():SetZero()
                vcp:normalMass = 0
                vcp:tangentMass = 0
                vcp:velocityBias = 0
                pc:GetLocalPoint(j):SetX(cp:GetLocalPoint():GetX())
                pc:GetLocalPoint(j):SetY(cp:GetLocalPoint():GetY())

                j = j + 1
            end

            i = i + 1
        end
    end

    action WarmStart
        integer i = 0
        repeat while i < count
            CollisionVelocityConstraint vc = velocityConstraints:Get(i)

            integer indexA = vc:GetIndexA()
            integer indexB = vc:GetIndexB()
            number mA = vc:GetInverseMassA()
            number iA = vc:GetInverseInertiaA()
            number mB = vc:GetInverseMassB()
            number iB = vc:GetInverseInertiaB()
            integer pointCount = vc:GetPointCount()

            Vector2 vA = velocities:Get(indexA)
            number wA = ws:Get(indexA)
            Vector2 vB = velocities:Get(indexB)
            number wB = ws:Get(indexB)

            Vector2 normal = vc:GetNormal()
            number tangentX = 1.0 * normal:GetY()
            number tangentY = -1.0 * normal:GetX()

            integer j = 0
            repeat while j < pointCount
                VelocityConstraintPoint vcp = vc:GetPoints():Get(j)
                number Px = tangentX * vcp:GetTangentImpulse() + normal:GetX() * vcp:GetNormalImpulse()
                number Py = tangentY * vcp:GetTangentImpulse ()+ normal:GetY() * vcp:GetNormalImpulse()

                wA = wA - (iA * (vcp:GetRadiusA():GetX() * Py - vcp:GetRadiusA():GetY() * Px))
                vA:SetX(vA:GetX() - (Px * mA))
                vA:SetY(vA:GetY() - (Py * mA))
                wB = wB + (iB * (vcp:GetRadiusB():GetX() * Py - vcp:GetRadiusB():GetY() * Px))
                vB:SetX(vB:GetX() + (Px * mB))
                vB:SetY(vB:GetY() + (Py * mB))
                j = j + 1
            end
            ws:Set(indexA, wA)
            ws:Set(indexB, wB)
            i = i + 1
        end
    end

    PhysicsPosition2D xfA
    PhysicsPosition2D xfB
    GlobalCollisionPoints2D globalCollisionPoints

    action InitializeVelocityConstraints
        integer i = 0
        repeat while i < count
            CollisionVelocityConstraint vc = velocityConstraints:Get(i)
            CollisionPositionConstraint pc = positionConstraints:Get(i)

            number radiusA = pc:GetRadiusA()
            number radiusB = pc:GetRadiusB()
            LocalCollisionPoints2D collisionPoints = collisions:Get(vc:GetCollisionIndex()):GetCollisionPoints()
            
            integer indexA = vc:GetIndexA()
            integer indexB = vc:GetIndexB()

            number mA = vc:GetInverseMassA()
            number mB = vc:GetInverseMassB()
            number iA = vc:GetInverseInertiaA()
            number iB = vc:GetInverseInertiaB()
            Vector2 localCenterA = pc:GetLocalCenterA()
            Vector2 localCenterB = pc:GetLocalCenterB()

            Vector2 cA = positions:Get(indexA)
            number aA = angles:Get(indexA)
            Vector2 vA = velocities:Get(indexA)
            number wA = ws:Get(indexA)

            Vector2 cB = positions:Get(indexB)
            number aB = angles:Get(indexB)
            Vector2 vB = velocities:Get(indexB)
            number wB = ws:Get(indexB)

            xfA:Set(xfA:GetPosition(), aA)
            xfB:Set(xfB:GetPosition(), aB)
            xfA:GetPosition():SetX(cA:GetX() - (xfA:GetCosine() * localCenterA:GetX() - xfA:GetSine() * localCenterA:GetY()))
            xfA:GetPosition():SetY(cA:GetY() - (xfA:GetSine() * localCenterA:GetX() + xfA:GetCosine() * localCenterA:GetY()))
            xfB:GetPosition():SetX(cB:GetX() - (xfB:GetCosine() * localCenterB:GetX() - xfB:GetSine() * localCenterB:GetY()))
            xfB:GetPosition():SetY(cB:GetY() - (xfB:GetSine() * localCenterB:GetX() + xfB:GetCosine() * localCenterB:GetY()))

            globalCollisionPoints:Initialize(collisionPoints, xfA, radiusA, xfB, radiusB)

            Vector2 vcnormal = vc:GetNormal()
            vcnormal:SetX(globalCollisionPoints:GetNormal():GetX())
            vcnormal:SetY(globalCollisionPoints:GetNormal():GetY())

            integer pointCount = vc:GetPointCount()
            integer j = 0
            repeat while j < pointCount
                VelocityConstraintPoint vcp = vc:GetPoints():Get(j)
                Vector2 wmPj = globalCollisionPoints:GetPoints():Get(j)
                Vector2 vcprA = vcp:GetRadiusA()
                Vector2 vcprB = vcp:GetRadiusB()
                vcprA:SetX(wmPj:GetX() - cA:GetX())
                vcprA:SetY(wmPj:GetY() - cA:GetY())
                vcprB:SetX(wmPj:GetX() - cB:GetX())
                vcprB:SetY(wmPj:GetY() - cB:GetY())

                number rnA = vcprA:GetX() * vcnormal:GetY() - vcprA:GetY() * vcnormal:GetX()
                number rnB = vcprB:GetX() * vcnormal:GetY() - vcprB:GetY() * vcnormal:GetX()

                number kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB

                if kNormal > 0
                    vcp:normalMass = 1 / kNormal
                else
                    vcp:normalMass = 0
                end

                number tangentx = 1 * vcnormal:GetY()
                number tangenty = -1 * vcnormal:GetX()

                number rtA = vcprA:GetX() * tangenty - vcprA:GetY() * tangentx
                number rtB = vcprB:GetX() * tangenty - vcprB:GetY() * tangentx

                number kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB

                if kTangent > 0
                    vcp:tangentMass = 1 / kTangent
                else
                    vcp:tangentMass = 0
                end

                vcp:velocityBias = 0
                number tempx = vB:GetX() + -wB * vcprB:GetY() - vA:GetX() - (-wA * vcprA:GetY())
                number tempy = vB:GetY() + wB * vcprB:GetX() - vA:GetY() - (wA * vcprA:GetX())
                number vRel = vcnormal:GetX() * tempx + vcnormal:GetY() * tempy
                if vRel < -1.0
                    vcp:velocityBias = -vc:GetRestitution() * vRel
                end
                
                j = j + 1
            end
            
            if vc:GetPointCount() = 2
                VelocityConstraintPoint vcp1 = vc:GetPoints():Get(0)
                VelocityConstraintPoint vcp2 = vc:GetPoints():Get(1)
                number rn1A = vcp1:GetRadiusA():GetX() * vcnormal:GetY() - vcp1:GetRadiusA():GetY() * vcnormal:GetX()
                number rn1B = vcp1:GetRadiusB():GetX() * vcnormal:GetY() - vcp1:GetRadiusB():GetY() * vcnormal:GetX()
                number rn2A = vcp2:GetRadiusA():GetX() * vcnormal:GetY() - vcp2:GetRadiusA():GetY() * vcnormal:GetX()
                number rn2B = vcp2:GetRadiusB():GetX() * vcnormal:GetY() - vcp2:GetRadiusB():GetY() * vcnormal:GetX()

                number k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B
                number k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B
                number k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B
                if k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)
                    vc:GetInverseNormalMass():Set(0, 0, k11)
                    vc:GetInverseNormalMass():Set(1, 0, k12)
                    vc:GetInverseNormalMass():Set(0, 1, k12)
                    vc:GetInverseNormalMass():Set(1, 1, k22)
                    
                    number a = vc:GetInverseNormalMass():Get(0, 0)
                    number b = vc:GetInverseNormalMass():Get(0, 1)
                    number c = vc:GetInverseNormalMass():Get(1, 0)
                    number d = vc:GetInverseNormalMass():Get(1, 1)
                    number det = a * d - b * c
                    det = 1 / det
                    vc:GetNormalMass():Set(0, 0, det * d)
                    vc:GetNormalMass():Set(0, 1, -det * b)
                    vc:GetNormalMass():Set(1, 0, -det * c)
                    vc:GetNormalMass():Set(1, 1, det * a)
                else
                    vc:pointCount = 1
                end
            end
            
             i = i + 1
        end
    end

    action SolveVelocityConstraints
        integer i = 0
        repeat while i < count
            CollisionVelocityConstraint vc = velocityConstraints:Get(i)

            integer indexA = vc:GetIndexA()
            integer indexB = vc:GetIndexB()

            number mA = vc:GetInverseMassA()
            number mB = vc:GetInverseMassB()
            number iA = vc:GetInverseInertiaA()
            number iB = vc:GetInverseInertiaB()
            integer pointCount = vc:GetPointCount()

            Vector2 vA = velocities:Get(indexA)
            number wA = ws:Get(indexA)
            Vector2 vB = velocities:Get(indexB)
            number wB = ws:Get(indexB)

            Vector2 normal = vc:GetNormal()
            number normalx = normal:GetX()
            number normaly = normal:GetY()
            number tangentx = 1.0 * vc:GetNormal():GetY()
            number tangenty = -1.0 * vc:GetNormal():GetX()
            number friction = vc:GetFriction()

            integer j = 0
            repeat while j < pointCount
                VelocityConstraintPoint vcp = vc:GetPoints():Get(j)
                Vector2 a = vcp:GetRadiusA()
                number dvx = -wB * vcp:GetRadiusB():GetY() + vB:GetX() - vA:GetX() + wA * a:GetY()
                number dvy = wB * vcp:GetRadiusB():GetX() + vB:GetY() - vA:GetY() - wA * a:GetX()

                number vt = dvx * tangentx + dvy * tangenty - vc:GetTangentSpeed()
                number lambda = vcp:GetTangentMass() * (-vt)

                number maxFriction = friction * vcp:GetNormalImpulse()
                number newImpulse = vcp:GetTangentImpulse() + lambda
                if newImpulse < -maxFriction
                    newmpulse = -maxFriction
                elseif newImpulse > maxFriction
                    newImpulse = maxFriction
                end
                lambda = newImpulse - vcp:GetTangentImpulse()
                vcp:tangentImpulse = newImpulse

                number Px = tangentx * lambda
                number Py = tangenty * lambda

                vA:SetX(vA:GetX() - (Px * mA))
                vA:SetY(vA:GetY() - (Py * mA))
                wA = wA - (iA * (vcp:GetRadiusA():GetX() * Py - vcp:GetRadiusA():GetY() * Px))

                vB:SetX(vB:GetX() + (Px * mB))
                vB:SetY(vB:GetY() + (Py * mB))
                wB = wB + (iB * (vcp:GetRadiusB():GetX() * Py - vcp:GetRadiusB():GetY() * Px))

                j = j + 1
            end

            if vc:GetPointCount() = 1
                VelocityConstraintPoint vcp = vc:GetPoints():Get(0)

                number dvx = -wB * vcp:GetRadiusB():GetY() + vB:GetX() - vA:GetX() + wA * vcp:GetRadiusA():GetY()
                number dvy = wB * vcp:GetRadiusB():GetX() + vB:GetY() - vA:GetY() - wA * vcp:GetRadiusA():GetX()

                number vn = dvx * normalx + dvy * normaly
                number lambda = -vcp:GetNormalMass() * (vn * vcp:GetVelocityBias())

                number a = vcp:GetNormalImpulse() + lambda
                number newImpulse = 0
                if a > 0
                    newImpulse = a
                end
                lambda = newImpulse - vcp:GetNormalImpulse()
                vcp:normalImpulse = newImpulse

                number Px = normalx * lambda
                number Py = normaly * lambda

                vA:SetX(vA:GetX() - (Px * mA))
                vA:SetY(vA:GetY() - (Py * mA))
                wA = wA - (iA * (vcp:GetRadiusA():GetX() * Py - vcp:GetRadiusA():GetY() * Px))

                vB:SetX(vB:GetX() + (Px * mB))
                vB:SetY(vB:GetY() + (Py * mB))
                wB = wB + (iB * (vcp:GetRadiusB():GetX() * Py - vcp:GetRadiusB():GetY() * Px))                                      
            else
                VelocityConstraintPoint cp1 = vc:GetPoints():Get(0)
                VelocityConstraintPoint cp2 = vc:GetPoints():Get(1)
                Vector2 cp1rA = cp1:GetRadiusA()
                Vector2 cp1rB = cp1:GetRadiusB()
                Vector2 cp2rA = cp2:GetRadiusA()
                Vector2 cp2rB = cp2:GetRadiusB()
                number ax = cp1:GetNormalImpulse()
                number ay = cp2:GetNormalImpulse()

                number dv1x = -wB * cp1rB:GetY() + vB:GetX() - vA:GetX() + wA * cp1rA:GetY()
                number dv1y = wB * cp1rB:GetX() + vB:GetY() - vA:GetY() - wA * cp1rA:GetX()

                number dv2x = -wB * cp2rB:GetY() + vB:GetX() - vA:GetX() + wA * cp2rA:GetY()
                number dv2y = wB * cp2rB:GetX() + vB:GetY() - vA:GetY() - wA * cp2rA:GetX()

                number vn1 = dv1x * normalx + dv1y * normaly
                number vn2 = dv2x * normalx + dv2y * normaly

                number bx = vn1 - cp1:GetVelocityBias()
                number by = vn2 - cp2:GetVelocityBias()

                Table<number> R = vc:GetInverseNormalMass()
                bx = bx - (R:Get(0, 0) * ax + R:Get(0, 1) * ay)
                by = by - (R:Get(1, 0) * ax + R:Get(1, 1) * ay)

                boolean continue = true
                repeat while continue
                    Table<number> R1 = vc:GetNormalMass()
                    number xx = R1:Get(0, 0) * bx + R1:Get(0, 1) * by
                    number xy = R1:Get(1, 0) * bx + R1:Get(1, 1) * by
                    xx = xx * -1
                    xy = xy * -1

                    if xx >= 0 and xy >= 0
                        number dx = xx - ax
                        number dy = xy - ay

                        number P1x = dx * normalx
                        number P1y = dx * normaly
                        number P2x = dy * normalx
                        number P2y = dy * normaly

                        vA:SetX(vA:GetX() - (mA * (P1x + P2x)))
                        vA:SetY(vA:GetY() - (mA * (P1y + P2y)))
                        vB:SetX(vB:GetX() + (mB * (P1x + P2x)))
                        vB:SetY(vB:GetY() + (mB * (P1y + P2y)))

                        wA = wA - (iA * (cp1rA:GetX() * P1y - cp1rA:GetY() * P1x + (cp2rA:GetX() * P2y - cp2rA:GetY() * P2x)))
                        wB = wB + (iB * (cp1rB:GetX() * P1y - cp1rB:GetY() * P1x + (cp2rB:GetX() * P2y - cp2rB:GetY() * P2x)))

                        cp1:normalImpulse = xx
                        cp2:normalImpulse = xy

                        continue = false
                    end

                    if continue
                        xx = -cp1:GetNormalMass() * bx
                        xy = 0
                        vn1 = 0
                        vn2 = vc:GetInverseNormalMass():Get(1, 0) * xx + by

                        if xx >= 0 and vn2 >= 0
                            number dx = xx - ax
                            number dy = xy - ay

                            number P1x = normalx * dx
                            number P1y = normaly * dx
                            number P2x = normalx * dy
                            number P2y = normaly * dy

                            vA:SetX(vA:GetX() - (mA * (P1x + P2x)))
                            vA:SetY(vA:GetY() - (mA * (P1y + P2y)))
                            vB:SetX(vB:GetX() + (mB * (P1x + P2x)))
                            vB:SetY(vB:GetY() + (mB * (P1y + P2y)))

                            wA = wA - (iA * (cp1rA:GetX() * P1y - cp1rA:GetY() * P1x + (cp2rA:GetX() * P2y - cp2rA:GetY() * P2x)))
                            wB = wB + (iB * (cp1rB:GetX() * P1y - cp1rB:GetY() * P1x + (cp2rB:GetX() * P2y - cp2rB:GetY() * P2x)))

                            cp1:normalImpulse = xx
                            cp2:normalImpulse = xy

                            continue = false
                        end
                    end

                    if continue
                        xx = 0
                        xy = -cp2:GetNormalMass() * by
                        vn1 = vc:GetInverseNormalMass():Get(0, 1) * xy + bx
                        vn2 = 0

                        if xy >= 0 and vn1 >= 0
                            number dx = xx - ax
                            number dy = xy - ay

                            number P1x = normalx * dx
                            number P1y = normaly * dx
                            number P2x = normalx * dy
                            number P2y = normaly * dy

                            vA:SetX(vA:GetX() - (mA * (P1x + P2x)))
                            vA:SetY(vA:GetY() - (mA * (P1y + P2y)))
                            vB:SetX(vB:GetX() + (mB * (P1x + P2x)))
                            vB:SetY(vB:GetY() + (mB * (P1y + P2y)))

                            wA = wA - (iA * (cp1rA:GetX() * P1y - cp1rA:GetY() * P1x + (cp2rA:GetX() * P2y - cp2rA:GetY() * P2x)))
                            wB = wB + (iB * (cp1rB:GetX() * P1y - cp1rB:GetY() * P1x + (cp2rB:GetX() * P2y - cp2rB:GetY() * P2x)))

                            cp1:normalImpulse = xx
                            cp2:normalImpulse = xy

                            continue = false                                    
                        end
                    end

                    if continue
                        xx = 0
                        xy = 0
                        vn1 = bx
                        vn2 = by

                        if vn1 >= 0 and vn2 >= 0
                            number dx = xx - ax
                            number dy = xy - ay

                            number P1x = normalx * dx
                            number P1y = normaly * dx
                            number P2x = normalx * dy
                            number P2y = normaly * dy

                            vA:SetX(vA:GetX() - (mA * (P1x + P2x)))
                            vA:SetY(vA:GetY() - (mA * (P1y + P2y)))
                            vB:SetX(vB:GetX() + (mB * (P1x + P2x)))
                            vB:SetY(vB:GetY() + (mB * (P1y + P2y)))

                            wA = wA - (iA * (cp1rA:GetX() * P1y - cp1rA:GetY() * P1x + (cp2rA:GetX() * P2y - cp2rA:GetY() * P2x)))
                            wB = wB + (iB * (cp1rB:GetX() * P1y - cp1rB:GetY() * P1x + (cp2rB:GetX() * P2y - cp2rB:GetY() * P2x)))

                            cp1:normalImpulse = xx
                            cp2:normalImpulse = xy
                            continue = false
                        end
                    end
                    continue = false
                end
            end
            ws:Set(indexA, wA)
            ws:Set(indexB, wB)

            i = i + 1
        end
    end

    action StoreImpulses
        integer i = 0
        repeat while i < count
            CollisionVelocityConstraint vc = velocityConstraints:Get(i)
            LocalCollisionPoints2D collisionPoints = collisions:Get(vc:GetCollisionIndex()):GetCollisionPoints()
            
            integer j = 0
            repeat while j < vc:GetPointCount()
                collisionPoints:GetPoints():Get(j):SetNormalImpulse(vc:GetPoints():Get(j):GetNormalImpulse())
                collisionPoints:GetPoints():Get(j):SetTangentImpulse(vc:GetPoints():Get(j):GetTangentImpulse())
                
                j = j + 1
            end
            i = i + 1
        end
    end

   action SolvePositionConstraints returns boolean
        number minSeparation = 0
        
        integer i = 0
        repeat while i < count
            CollisionPositionConstraint pc = positionConstraints:Get(i)
            
            integer indexA = pc:GetIndexA()
            integer indexB = pc:GetIndexB()

            number mA = pc:GetInverseMassA()
            number iA = pc:GetInverseInertiaA()
            Vector2 localCenterA = pc:GetLocalCenterA()
            number localCenterAx = localCenterA:GetX()
            number localCenterAy = localCenterA:GetY()
            number mB = pc:GetInverseMassB()
            number iB = pc:GetInverseInertiaB()
            Vector2 localCenterB = pc:GetLocalCenterB()
            number localCenterBx = localCenterB:GetX()
            number localCenterBy = localCenterB:GetY()
            number pointCount = pc:GetPointCount()

            Vector2 cA = positions:Get(indexA)
            number aA = angles:Get(indexA)
            Vector2 cB = positions:Get(indexB)
            number aB = angles:Get(indexB)

            integer j = 0
            repeat while j < pointCount
                xfA:Set(xfA:GetPosition(), aA)
                xfB:Set(xfB:GetPosition(), aB)
                xfA:GetPosition():SetX(cA:GetX() - xfA:GetCosine() * localCenterAx + xfA:GetSine() * localCenterAy)
                xfA:GetPosition():SetY(cA:GetY() - xfA:GetSine() * localCenterAx - xfA:GetCosine() * localCenterAy)
                xfB:GetPosition():SetX(cB:GetX() - xfB:GetCosine() * localCenterBx + xfB:GetSine() * localCenterBy)
                xfB:GetPosition():SetY(cB:GetY() - xfB:GetSine() * localCenterBx - xfB:GetCosine() * localCenterBy)

                PositionSolver psm
                psm:Initialize(pc, xfA, xfB, j)
                Vector2 normal = psm:GetNormal()
                Vector2 point = psm:GetPoint()
                number separation = psm:GetSeparation()

                number rAx = point:GetX() - cA:GetX()
                number rAy = point:GetY() - cA:GetY()
                number rBx = point:GetX() - cB:GetX()
                number rBy = point:GetY() - cB:GetY()

                if separation < minSeparation
                    minSeparation = separation
                end

                number C = 0.2 * (separation + 0.005)
                if C < -0.2
                    C = -0.2
                elseif C > 0
                    C = 0
                end

                number rnA = rAx * normal:GetY() - rAy * normal:GetX()
                number rnB = rBx * normal:GetY() - rBy * normal:GetX()
                number K = mA + mB + iA * rnA * rnA + iB * rnB * rnB

                number impulse = 0
                if K > 0
                    impulse = -C / K
                end

                number Px = normal:GetX() * impulse
                number Py = normal:GetY() * impulse

                cA:SetX(cA:GetX() - (Px * mA))
                cA:SetY(cA:GetY() - (Py * mA))
                aA = aA - (iA * (rAx * Py - rAy * Px))

                cB:SetX(cB:GetX() + (Px * mB))
                cB:SetY(cB:GetY() + (Py * mB))
                aB = aB + (iB * (rBx * Py - rBy * Px))

                j = j + 1
            end
            angles:Set(indexA, aA)
            angles:Set(indexB, aB)

            i = i + 1
        end

        return minSeparation >= -3.0 * 0.005
    end

    action SolveTimeOfImpactPositionConstraints(integer timeOfImpactIndexA, integer timeOfImpactIndexB) returns boolean
        number minSeparation = 0
        
        integer i = 0
        repeat while i < count
            CollisionPositionConstraint pc = positionConstraints:Get(i)

            integer indexA = pc:GetIndexA()
            integer indexB = pc:GetIndexB()
            Vector2 localCenterA = pc:GetLocalCenterA()
            Vector2 localCenterB = pc:GetLocalCenterB()
            number localCenterAx = localCenterA:GetX()
            number localCenterAy = localCenterA:GetY()
            number localCenterBx = localCenterB:GetX()
            number localCenterBy = localCenterB:GetY()
            integer pointCount = pc:GetPointCount()

            number mA = 0
            number iA = 0
            if indexA = timeOfImpactIndexA or indexA = timeOfImpactIndexB
                mA = pc:GetInverseMassA()
                iA = pc:GetInverseInertiaA()
            end

            number mB = 0
            number iB = 0
            if indexB = timeOfImpactIndexA or indexB = timeOfImpactIndexB
                mB = pc:GetInverseMassB()
                iB = pc:GetInverseInertiaB()
            end

            Vector2 cA = positions:Get(indexA)
            number aA = angles:Get(indexA)

            Vector2 cB = positions:Get(indexB)
            number aB = angles:Get(indexB)

            integer j = 0
            repeat while j < pointCount
                xfA:Set(xfA:GetPosition(), aA)
                xfB:Set(xfB:GetPosition(), aB)
                xfA:GetPosition():SetX(cA:GetX() - xfA:GetCosine() * localCenterAx + xfA:GetSine() * localCenterAy)
                xfA:GetPosition():SetY(cA:GetY() - xfA:GetSine() * localCenterAx - xfA:GetCosine() * localCenterAy)
                xfB:GetPosition():SetX(cB:GetX() - xfB:GetCosine() * localCenterBx + xfB:GetSine() * localCenterBy)
                xfB:GetPosition():SetY(cB:GetY() - xfB:GetSine() * localCenterBx - xfB:GetCosine() * localCenterBy)

                PositionSolver psm
                psm:Initialize(pc, xfA, xfB, j)
                Vector2 normal = psm:GetNormal()

                Vector2 point = psm:GetPoint()
                number separation = psm:GetSeparation()

                number rAx = point:GetX() - cA:GetX()
                number rAy = point:GetY() - cA:GetY()
                number rBx = point:GetX() - cB:GetX()
                number rBy = point:GetY() - cB:GetY()

                if separation < minSeparation
                    minSeparation = separation
                end

                number C = 0.75 * (separation + 0.005)
                if C < -0.2
                    C = -0.2
                elseif C > 0
                    C = 0
                end

                number rnA = rAx * normal:GetY() - rAy * normal:GetX()
                number rnB = rBx * normal:GetY() - rBy * normal:GetX()
                number K = mA + mB + iA * rnA * rnA + iB * rnB * rnB

                number impulse = 0
                if K > 0
                    impulse = -C / K
                end

                number Px = normal:GetX() * impulse
                number Py = normal:GetY() * impulse

                cA:SetX(cA:GetX() - (Px * mA))
                cA:SetY(cA:GetY() - (Py * mA))
                aA = aA - (iA * (rAx * Py - rAy * Px))

                cB:SetX(cB:GetX() + (Px * mB))
                cB:SetY(cB:GetY() + (Py * mB))
                aB = aB + (iB * (rBx * Py - rBy * Px))

                j = j + 1
            end

            angles:Set(indexA, aA)
            angles:Set(indexB, aB)

            i = i + 1
        end

        return minSeparation >= -1.5 * 0.005
    end
end