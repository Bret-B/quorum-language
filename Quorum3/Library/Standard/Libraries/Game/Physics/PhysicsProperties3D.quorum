package Libraries.Game.Physics

use Libraries.Compute.Vector3
use Libraries.Game.Collision.CollisionEdge3D
use Libraries.Game.Collision.BroadphaseCollision3D
use Libraries.Interface.Item3D
use Libraries.Game.Collision.PhysicsPosition3D
use Libraries.Compute.Matrix3
use Libraries.Compute.Math
use Libraries.Compute.Quaternion

/*
This class is a property holder for a 3D mass. This class is used internally 
by Item3D class.
*/
class PhysicsProperties3D 
    Math math

    public constant integer UNMOVABLE = 0       //static object
    public constant integer NON_RESPONSIVE = 1  //object governed by kinematics (meaning, the object is affected by linear velocity and angular velocity settings)
    public constant integer RESPONSIVE = 2      //object governed by dynamics (meaning, the object is affect by force and torque applied to it)

    Vector3 linearVelocity
    Vector3 angularVelocity
    Vector3 force
    Vector3 torque
    number mass = 0
    number inverseMass = 0
    Matrix3 inverseInertiaWorld
    Vector3 inverseInertiaLocal
    number linearDamping = 0
    number angularDamping = 0
    number friction = 0
    number restitution = 0

    Vector3 interpolatedLinearVelocity
    Vector3 interpolatedAngularVelocity

    number sleepTime = 0

    integer type = UNMOVABLE

    boolean collisionGroupFlag = false
    integer collisionGroupIndex = -1

    boolean simulated = true
    boolean simulationRequired = false
    boolean fastMoving = false
    boolean canRotate = true
    boolean timeOfImpactFlag = false

    boolean massSet = false

    Item3D item = undefined

    boolean additionalDamping = true
    number additionalDampingFactor = 0.005
    number additionalLinearDampingThresholdSquared = 0.01
    number additionalAngularDampingThresholdSquared = 0.01
    number additionalAngularDampingFactor = 0.01

    constant number MAX_ANGULAR_VELOCITY = 0.5 * math:pi
    constant number ANGULAR_MOTION_THRESHOLD = 0.5 * math:pi / 2

    Vector3 pushVelocity
    Vector3 turnVelocity

    number angularFactor = 1

    action SetItem(Item3D item)
        me:item = item

        if me:type = UNMOVABLE
            linearVelocity:SetZero()
            angularVelocity:SetZero()

            if item:GetLayer() not= undefined
                item:SynchronizeNodes()
            end
        end

        if item:GetLayer() not= undefined
            CollisionEdge3D edge = item:GetCollisionList()
            repeat while edge not= undefined
                CollisionEdge3D edge0 = edge
                edge = edge:GetNext()
                item:GetLayer():GetCollisionManager():Destroy(edge0:GetCollision())
            end
            item:SetCollisionList(undefined)

            BroadphaseCollision3D broadphase = item:GetLayer():GetCollisionManager():GetBroadphase()
            integer i = 0
            repeat while i < item:GetNodeCount()
                broadphase:TouchNode(item:GetNode(i):GetNodeID())     
                i = i + 1
            end
        end

        Vector3 inertia
        item:GetShape():CalculateLocalInertia(mass, inertia)
        SetMassProperties(mass, inertia)
    end

    action GetItem returns Item3D
        return item
    end

    action Copy returns PhysicsProperties3D
        PhysicsProperties3D new
        new:linearVelocity = linearVelocity:Copy()
        new:angularVelocity = angularVelocity:Copy()
        new:force = force:Copy()
        new:torque = torque:Copy()
        new:mass = mass
        new:inverseMass = inverseMass
        new:inverseInertiaWorld:Set(inverseInertiaWorld)
        new:inverseInertiaLocal:Set(inverseInertiaLocal)
        new:linearDamping = linearDamping
        new:angularDamping = angularDamping
        new:friction = friction
        new:restitution = restitution
        new:sleepTime = sleepTime
        new:type = type
        new:collisionGroupFlag = collisionGroupFlag
        new:collisionGroupIndex = collisionGroupIndex
        new:simulated = simulated
        new:simulationRequired = simulationRequired
        new:fastMoving = fastMoving
        new:canRotate = canRotate
        new:timeOfImpactFlag = timeOfImpactFlag
        new:massSet = massSet
        new:interpolatedLinearVelocity:Set(interpolatedLinearVelocity)
        new:interpolatedAngularVelocity:Set(interpolatedAngularVelocity)
        new:pushVelocity:Set(pushVelocity)
        new:turnVelocity:Set(turnVelocity)
        new:angularFactor = angularFactor
        
        return new
    end

    action SetLinearVelocity(Vector3 linearVelocity)
        if type = UNMOVABLE
            // static bodies don't move - hence don't have velocity
            return now
        end
        me:linearVelocity:Set(linearVelocity)
        if not simulated and not me:linearVelocity:IsZero(0.000000119209290)
            Simulate(true)
        end
    end

    action SetLinearVelocityX(number linearVelocityX)
        if type = UNMOVABLE
            return now
        end

        me:linearVelocity:Set(linearVelocityX, me:linearVelocity:GetY(), me:linearVelocity:GetZ())
        if not simulated and linearVelocityX not= 0
            Simulate(true)
        end
    end

    action SetLinearVelocityY(number linearVelocityY)
        if type = UNMOVABLE
            return now
        end

        me:linearVelocity:Set(me:linearVelocity:GetX(), linearVelocityY, me:linearVelocity:GetZ())
        if not simulated and linearVelocityY not= 0
            Simulate(true)
        end
    end

    action SetLinearVelocityZ(number linearVelocityZ)
        if type = UNMOVABLE
            return now
        end

        me:linearVelocity:Set(me:linearVelocity:GetX(), me:linearVelocity:GetY(), linearVelocityZ)
        if not simulated and linearVelocityZ not= 0
            Simulate(true)
        end
    end

    action GetLinearVelocity returns Vector3
        return linearVelocity
    end

    action SetAngularVelocity(Vector3 angularVelocity)
        if type = UNMOVABLE
            return now
        end
        me:angularVelocity:Set(angularVelocity)
        if not simulated and not me:angularVelocity:IsZero(0.000000119209290)
            Simulate(true)
        end
    end

    action GetAngularVelocity returns Vector3
        return angularVelocity
    end

    action SetForce(Vector3 force)
        me:force = force
    end

    action GetForce returns Vector3
        return force
    end

    action SetTorque(Vector3 torque)
        me:torque = torque
    end

    action GetTorque returns Vector3
        return torque
    end

    action ApplyForce(Vector3 force, Vector3 point)
        if type not= RESPONSIVE
            return now
        end

        if not simulated and not force:IsZero(0.000000119209290)
            Simulate(true)
        end
        
        me:force:Add(force)

        Vector3 temp
        temp:Set(point):CrossProduct(force)
        temp:Scale(angularFactor)
        ApplyTorque(temp)
    end

    action ApplyForceToCenter(Vector3 force)
        if type not= RESPONSIVE
            return now
        end

        if not simulated and not force:IsZero(0.000000119209290)
            Simulate(true)
        end

        me:force:Add(force)
    end

    action ApplyTorque(Vector3 torque)
        if type not= RESPONSIVE
            return now
        end

        if not simulated and not torque:IsZero(0.000000119209290)
            Simulate(true)
        end

        me:torque:Add(torque)
    end

    action ApplyLinearImpulse(Vector3 impulse, Vector3 point)
        if type not= RESPONSIVE
            return now
        end

        if not simulated and not impulse:IsZero(0.000000119209290)
            Simulate(true)
        end
        
        ApplyLinearImpulseToCenter(impulse)
        if canRotate
            Vector3 temp
            temp:Set(point):CrossProduct(impulse)
            temp:Scale(angularFactor)
            ApplyAngularImpulse(temp)
        end
    end

    action ApplyLinearImpulseToCenter(Vector3 impulse)
        Vector3 temp
        temp:Set(impulse):Scale(inverseMass):Add(linearVelocity)
        me:linearVelocity:Set(temp)
    end

    action ApplyAngularImpulse(Vector3 impulse)
        if type not= RESPONSIVE
            return now
        end

        if not simulated and not impulse:IsZero(0.000000119209290)
            Simulate(true)
        end

        Vector3 tmp
        inverseInertiaWorld:Transform(tmp)
        angularVelocity:Add(tmp)
    end

    action GetMass returns number
        return mass
    end

    action SetMass(number mass)
        me:mass = mass
        massSet = true
        if mass not= 0
            me:inverseMass = 1.0 / mass
        end
        if item not= undefined
            Vector3 inertia
            item:GetShape():CalculateLocalInertia(mass, inertia)
            SetMassProperties(mass, inertia)
        end
    end

    action GetInverseMass returns number
        return inverseMass
    end

    action SetInverseMass(number inverseMass)
        me:inverseMass = inverseMass
    end

    action GetInverseInertiaLocal returns Vector3
        return inverseInertiaLocal
    end

    action SetInverseInertiaLocal(Vector3 inverseInertia)
        me:inverseInertiaLocal:Set(inverseInertia)
    end

    action GetInverseInertiaWorld returns Matrix3
        return inverseInertiaWorld
    end

    action GetLinearDamping returns number
        return linearDamping
    end

    action SetLinearDamping(number linearDamping)
        me:linearDamping = linearDamping
    end

    action GetAngularDamping returns number
        return angularDamping
    end

    action SetAngularDamping(number angularDamping)
        me:angularDamping = angularDamping
    end

    action GetResponsiveness returns integer
        return type
    end

    action SetResponsiveness(integer type)
        if me:type = type
            return now
        end

        me:type = type

        simulated = true

        if me:type = RESPONSIVE
            if not massSet
                mass = 1
                inverseMass = 1
                density = 1
            end
            
            if me:item not= undefined
                Vector3 inertia
                item:GetShape():CalculateLocalInertia(mass, inertia)
                SetMassProperties(mass, inertia)
            end
        else
            mass = 0
            inverseMass = 0
            density = 0
        end

        force:SetZero()
        torque:SetZero()
    end

    action SetFriction(number friction)
        me:friction = friction
    end

    action GetFriction returns number
        return friction
    end

    action SetRestitution(number restitution)
        me:restitution = restitution
    end

    action GetRestitution returns number
        return restitution
    end

    action SetCollisionGroupFlag(boolean flag)
        collisionGroupFlag = flag
    end

    action GetCollisionGroupFlag returns boolean
        return collisionGroupFlag
    end

    action SetCollisionGroupIndex(integer index)
        collisionGroupIndex = index
    end

    action GetCollisionGroupIndex returns integer
        return collisionGroupIndex
    end

    action IsFastMoving returns boolean
        return fastMoving
    end

    action FastMoving(boolean flag)
        fastMoving = flag
    end

    action RequireSimulation(boolean flag)
        simulationRequired = flag
        if simulationRequired
            Simulate(true)
        end
    end

    action IsSimulationRequired returns boolean
        return simulationRequired
    end

    action Simulate(boolean flag)
        if flag
            if not simulated
                simulated = true
                sleepTime = 0
            end
        else
            simulated = false
            sleepTime = 0
            linearVelocity:SetZero()
            angularVelocity:SetZero()
            force:SetZero()
            torque:SetZero()
        end
    end

    action IsSimulated returns boolean
        return simulated
    end

    action CanRotate(boolean flag)
        canRotate = flag
        if not canRotate
            angularFactor = 0
        end
    end

    action IsRotationAllowed returns boolean
        return canRotate
    end

    action SetSleepTime(number time)
        sleepTime = time
    end

    action GetSleepTime returns number
        return sleepTime
    end

    action IntegrateVelocities(number seconds)
        if type not= RESPONSIVE
            return now
        end

        Vector3 temp
        temp:Set(force):Scale(inverseMass * seconds):Add(linearVelocity)
        linearVelocity:Set(temp)
        temp:Set(torque)
        inverseInertiaWorld:Transform(temp)
        temp:Scale(seconds):Add(angularVelocity)
        angularVelocity:Set(temp)

        number angVel = angularVelocity:Length()
        if angVel * seconds > MAX_ANGULAR_VELOCITY
            angularVelocity:Scale((MAX_ANGULAR_VELOCITY / seconds) / angVel)
        end
    end

    action ApplyDamping(number seconds)
        linearVelocity:Scale(math:RaiseToPower(1 - linearDamping, seconds))
        angularVelocity:Scale(math:RaiseToPower(1 - angularDamping, seconds))

        if additionalDamping
            if (angularVelocity:LengthSquared() < additionalAngularDampingThresholdSquared) and
               (linearVelocity:LengthSquared() < additionalLinearDampingThresholdSquared)
                angularVelocity:Scale(additionalDampingFactor)
                linearVelocity:Scale(additionalDampingFactor)
            end

            number speed = linearVelocity:Length()
            if speed < linearDamping
                number dampVelocity = 0.005
                if speed > dampVelocity
                    Vector3 direction
                    direction:Set(linearVelocity)
                    direction:Normalize()
                    direction:Scale(dampVelocity)
                    linearVelocity:Subtract(direction)
                else
                    linearVelocity:Set(0, 0, 0)
                end
            end

            number angularSpeed = angularVelocity:Length()
            if speed < angularDamping
                number angularDampVelocity = 0.005
                if angularSpeed > angularDampVelocity
                    Vector3 direction
                    direction:Set(angularVelocity)
                    direction:Normalize()
                    direction:Scale(angularDampVelocity)
                    angularVelocity:Subtract(direction)
                else
                    angularVelocity:Set(0, 0, 0)
                end
            end
        end
    end

    action IntegrateTransform(PhysicsPosition3D currentTransform, number seconds, PhysicsPosition3D predictedTransform)
        Vector3 temp
        temp:Set(linearVelocity):Scale(seconds)
        predictedTransform:GetOrigin():Set(temp):Add(currentTransform:GetOrigin())

        Vector3 axis
        number fAngle = angularVelocity:Length()

        if fAngle * seconds > ANGULAR_MOTION_THRESHOLD
            fAngle = ANGULAR_MOTION_THRESHOLD / seconds
        end

        if fAngle < 0.001
            axis:Set(angularVelocity):Scale(0.5 * seconds - (seconds * seconds * seconds) * 0.020833333333 * fAngle * fAngle)
        else
            axis:Set(angularVelocity):Scale(math:Sine(0.5 * fAngle * seconds) / fAngle)
        end

        Quaternion dorn
        dorn:Set(axis:GetX(), axis:GetY(), axis:GetZ(), math:Cosine(fAngle * seconds * 0.5))
        Quaternion orn0
        orn0:Set(currentTransform:GetRotation())

        Quaternion predictedOrn
        predictedOrn:Set(dorn):Multiply(orn0)
        predictedOrn:Normalize()

        predictedTransform:SetRotation(predictedOrn)
    end

    action UpdateInertia(Matrix3 basis)
        Matrix3 mat1
        mat1:row0column0 = basis:row0column0 * inverseInertiaLocal:GetX()
        mat1:row0column1 = basis:row0column1 * inverseInertiaLocal:GetY()
        mat1:row0column2 = basis:row0column2 * inverseInertiaLocal:GetZ()
        mat1:row1column0 = basis:row1column0 * inverseInertiaLocal:GetX()
        mat1:row1column1 = basis:row1column1 * inverseInertiaLocal:GetY()
        mat1:row1column2 = basis:row1column2 * inverseInertiaLocal:GetZ()
        mat1:row2column0 = basis:row2column0 * inverseInertiaLocal:GetX()
        mat1:row2column1 = basis:row2column1 * inverseInertiaLocal:GetY()
        mat1:row2column2 = basis:row2column2 * inverseInertiaLocal:GetZ()

        Matrix3 mat2
        mat2:Set(basis)
        mat2:Transpose()

        inverseInertiaWorld:Multiply(mat1, mat2)
    end

    action GetLinearVelocityAtLocalPoint(Vector3 relativePosition) returns Vector3
        Vector3 vec
        vec:Set(angularVelocity):CrossProduct(relativePosition)
        vec:Add(linearVelocity)
        return vec
    end

    action SetInterpolatedLinearVelocity(Vector3 velocity)
        interpolatedLinearVelocity:Set(velocity)
    end

    action GetInterpolatedLinearVelocity returns Vector3
        return interpolatedLinearVelocity
    end

    action SetInterpolatedAngularVelocity(Vector3 velocity)
        interpolatedAngularVelocity:Set(velocity)
    end

    action GetInterpolatedAngularVelocity returns Vector3
        return interpolatedAngularVelocity
    end

    action InternalApplyImpulse(Vector3 linearComponent, Vector3 angularComponent, number impulseMagnitude)
        if inverseMass not= 0
            Vector3 temp
            temp:Set(linearComponent):Scale(impulseMagnitude):Add(linearVelocity)
            linearVelocity:Set(temp)
            if canRotate
                temp:Set(angularComponent):Scale(impulseMagnitude * angularFactor):Add(angularVelocity)
                angularVelocity:Set(temp)
            end
        end
    end

    action GetPushVelocity returns Vector3
        return pushVelocity
    end

    action GetTurnVelocity returns Vector3
        return turnVelocity
    end

    action GetAngularFactor returns number
        return angularFactor
    end

    action SaveKinematicState(number timeStep)
        PhysicsPosition3D transform0 = item:GetInterpolationWorldTransform()
        PhysicsPosition3D transform1 = item:GetCollisionTransform()
        linearVelocity:Set(transform1:GetOrigin()):Subtract(transform0:GetOrigin())
        linearVelocity:Scale(1.0 / timeStep)

        Vector3 axis
        Matrix3 temp
        temp:Set(transform0:GetBasis())
        temp:Inverse()

        Matrix3 dmat
        dmat:Set(transform1:GetBasis())
        dmat:Multiply(temp)

        Quaternion dorn
        PhysicsPosition3D tempTrans
        tempTrans:GetBasis():Set(dmat)
        dorn:Set(tempTrans:GetRotation())
        
        dorn:Normalize()
        
        number angle = 2 * math:InverseCosine(dorn:GetW())
        axis:Set(dorn:GetX(), dorn:GetY(), dorn:GetZ())

        number len = axis:LengthSquared()
        if len < 0.000000119209290 * 0.000000119209290
            axis:Set(1, 0, 0)
        else
            axis:Scale(1.0 / math:SquareRoot(len))
        end

        angularVelocity:Set(axis):Scale(angle / timeStep)
        
        interpolatedLinearVelocity:Set(linearVelocity)
        interpolatedAngularVelocity:Set(angularVelocity)
        item:GetInterpolationTransform():Set(item:GetCollisionTransform())
    end

    action SetMassProperties(number mass, Vector3 inertia)
        if mass = 0
            me:mass = 0
            me:inverseMass = 0
        else
            me:mass = mass
            me:inverseMass = 1 / mass
        end

        number x = 0
        number y = 0
        number z = 0
        
        if inertia:GetX() not= 0
            x = 1 / inertia:GetX()
        end

        if inertia:GetY() not= 0
            y = 1 / inertia:GetY()
        end

        if inertia:GetZ() not= 0
            z = 1 / inertia:GetZ()
        end

        inverseInertiaLocal:Set(x, y, z)
    end
end
