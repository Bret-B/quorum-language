package Libraries.Game.Physics

use Libraries.Containers.Array
use Libraries.Compute.Vector2
use Libraries.Game.Collision.LocalCollisionPoints2D

/*
This class is used internally by CollisionSolver2D.
*/
class CollisionPositionConstraint 
    Array<Vector2> localPoints  //array that contains the vectors that represents the collision points from the perspective of the incident object

    Vector2 localNormal         //the direction to apply forces that will cause the two objects that have collided to separate
    Vector2 localPoint          //the collision point from the perspective of the reference object
    
    integer indexA = 0      //the group index of object A
    integer indexB = 0      //the group index of object B
    number inverseMassA = 0     //(1/massA)
    number inverseMassB = 0     //(1/massB)
    Vector2 localCenterA        //center of object A with respect to object A's local coordinates
    Vector2 localCenterB        //center of object B with respect to object B's local coordinates
    number inverseInertiaA = 0  //(1/mass moment of inertia of A)
    number inverseInertiaB = 0  //(1/mass moment of inertia of B)
    integer type = 0            //the type of "LocalCollisionPoints2D," possible choices are CIRCLES, FACE_A, FACE_B
    number radiusA = 0          //the effective radius of object A
    number radiusB = 0          //the effective radius of object B
    integer pointCount = 0      //the length of the array "localPoints"


    /*
    Since we are restraining how many collision points are possible, which is
    2 based on the LocalCollisionPoints2D class, therefore, we will only be
    creating an array of Vector2's that has 2 elements.
    */
    on create
        LocalCollisionPoints2D collisionPoints //this is here just so we can extract MAX_COLLISION_POINTS from the LocalCollisionPoints2D class
        repeat collisionPoints:MAX_COLLISION_POINTS times
            Vector2 point
            localPoints:Add(point)
        end
    end

    action GetLocalPoints returns Array<Vector2>
        return localPoints
    end

    action GetLocalPoint(integer index) returns Vector2
        return localPoints:Get(index)
    end

    action GetLocalNormal() returns Vector2
        return localNormal
    end

    action SetLocalNormal(Vector2 normal)
        me:localNormal = normal
    end

    action GetLocalPoint returns Vector2
        return localPoint
    end

    action SetLocalPoint(Vector2 point)
        me:localPoint = point
    end

    action GetIndexA returns integer
        return indexA
    end

    action SetIndexA(integer index)
        me:indexA = index
    end

    action GetIndexB returns integer
        return indexB
    end

    action SetIndexB(integer index)
        me:indexB = index
    end

    action GetInverseMassA returns number
        return inverseMassA
    end

    action SetInverseMassA(number inverseMass)
        me:inverseMassA = inverseMass
    end

    action GetInverseMassB returns number
        return inverseMassB
    end

    action SetInverseMassB(number inverseMass)
        me:inverseMassB = inverseMass
    end

    action GetLocalCenterA returns Vector2
        return localCenterA
    end

    action SetLocalCenterA(Vector2 localCenter)
        me:localCenterA = localCenter
    end

    action GetLocalCenterB returns Vector2
        return localCenterB
    end

    action SetLocalCenterB(Vector2 localCenter)
        me:localCenterB = localCenter
    end

    action GetInverseInertiaA returns number
        return inverseInertiaA
    end

    action SetInverseInertiaA(number inverseInertia)
        me:inverseInertiaA = inverseInertia
    end

    action GetInverseInertiaB returns number
        return inverseInertiaB
    end

    action SetInverseInertiaB(number inverseInertia)
        me:inverseInertiaB = inverseInertia
    end

    action GetType returns integer
        return type
    end

    action SetType(integer type)
        me:type = type
    end

    action GetRadiusA returns number
        return radiusA
    end

    action SetRadiusA(number radius)
        me:radiusA = radius
    end

    action GetRadiusB returns number
        return radiusB
    end

    action SetRadiusB(number radius)
        me:radiusB = radius
    end

    action GetPointCount returns integer
        return pointCount
    end

    action SetPointCount(integer pointCount)
        me:pointCount = pointCount
    end
end