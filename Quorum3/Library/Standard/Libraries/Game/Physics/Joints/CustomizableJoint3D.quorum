package Libraries.Game.Physics.Joints

use Libraries.Game.Physics.CollisionSolverInformation3D
use Libraries.Game.Physics.all
use Libraries.Interface.Item3D
use Libraries.Containers.Array
use Libraries.Compute.Math  
use Libraries.Compute.Vector3  
use Libraries.Compute.Matrix3
use Libraries.Game.Physics.Joints.RotationalLimitMotor3D
use Libraries.Game.Physics.Joints.TranslationalLimitMotor3D   
use Libraries.Game.Physics.ConstraintDescription3D
use Libraries.Game.Collision.PhysicsPosition3D

/*
This class is a class that allows a joint to have the ability to rotate around any axis and move anywhere in 3D space.
*/
class CustomizableJoint3D is Joint3D

    Math math
    PhysicsPosition3D frameInA  
    PhysicsPosition3D frameInB  
    //Array<ConstraintDescription3D> jacobianLinear/*[3]*/ 
    //Array<ConstraintDescription3D> jacobianAng/*[3]*/


    ConstraintDescription3D jacobianLinear0
    ConstraintDescription3D jacobianLinear1
    ConstraintDescription3D jacobianLinear2

    ConstraintDescription3D jacobianAng0
    ConstraintDescription3D jacobianAng1
    ConstraintDescription3D jacobianAng2

    TranslationalLimitMotor3D linearLimits
    //Array<RotationalLimitMotor3D> angularLimits/*[3]*/ 


    RotationalLimitMotor3D angularLimits0
    RotationalLimitMotor3D angularLimits1
    RotationalLimitMotor3D angularLimits2

    number timeStep = 0
    PhysicsPosition3D calculatedTransformA 
    PhysicsPosition3D calculatedTransformB 
    Vector3 calculatedAxisAngleDifference
    //Array<Vector3> calculatedAxis/*[3]*/ 


    Vector3 calculatedAxis0
    Vector3 calculatedAxis1
    Vector3 calculatedAxis2

    Vector3 anchorPosition
    Vector3 calculatedLinearDifference
    boolean useLinearReferenceFrameA  = true


/*
    on create
        Vector3 dummy
        ConstraintDescription3D filler
        RotationalLimitMotor3D ghost

        calculatedAxis:Add(dummy)
        calculatedAxis:Add(dummy)
        calculatedAxis:Add(dummy)
        angularLimits:Add(ghost)
        angularLimits:Add(ghost)
        angularLimits:Add(ghost)
        jacobianAng:Add(filler)
        jacobianAng:Add(filler)
        jacobianAng:Add(filler)
        jacobianLinear:Add(filler)
        jacobianLinear:Add(filler)
        jacobianLinear:Add(filler)
        parent:Joint3D:SetType(parent:Joint3D:Customizable)
    end
*/



    /*
    This action initializes the data inside this CustomizableJoint3D class.
    Attribute: Parameter itemA The first item.
    Attribute: Parameter itemB The second item.
    Attribute: Parameter positionA The center of the joint connection in A's point of view.
    Attribute: Parameter positionB The center of the joint connection in B's point of view.
    Attribute: Parameter useLinearReferenceFrameB When you want to define the limits from the point of view of the second object.
    */
    action Initialize(Item3D itemA, Item3D itemB, PhysicsPosition3D positionA, PhysicsPosition3D positionB, boolean useLinearReferenceFrameA)
        parent:Joint3D:SetItemA(itemA)
        parent:Joint3D:SetItemB(itemB)
        frameInA:Set(positionA)
        frameInB:Set(positionB)
        me:useLinearReferenceFrameA = useLinearReferenceFrameA
        parent:Joint3D:SetType(parent:Joint3D:Customizable)
    end

    /*
    This action returns a number inside a matrix.
    Attribute: Parameter mat The matrix that you want to extract from.
    Attribute: Parameter index The number that determines which element of the matrix you are extracting. Matrix3 mat = [index0, index1, index2; index3, index4, index5; index6, index7, index8]
    Attribute: Returns the matrix value at row number "index mod 3" and column number "index/3"
    */
    action getMatrixElement(Matrix3 mat, integer index) returns number
        return mat:GetElement(index mod 3, index/3)
    end

    /*
    This action converts a rotational matrix to a another representation of rotation: Euler angles.
    Attribute: Parameter mat The matrix that you are going to convert from.
    Attribute: Parameter xyz The Euler angles.
    Attribute: Returns false if this conversion was unsuccessful, true if this conversion was successful.
    */
    action MatrixToEulerXYZ(Matrix3 mat, Vector3 xyz) returns boolean
        if getMatrixElement(mat, 2) < 1.0 
            if getMatrixElement(mat, 2) > -1.0
                xyz:SetX(math:InverseTangent2(-getMatrixElement(mat, 5), getMatrixElement(mat, 8))) //xyz:SetX(math:InverseTangent(getMatrixElement(mat, 8), -getMatrixElement(mat, 5)))
                xyz:SetY(math:InverseSine(getMatrixElement(mat, 2)))
                xyz:SetZ(math:InverseTangent2(-getMatrixElement(mat, 1), getMatrixElement(mat, 0)))   //xyz:SetZ(math:InverseTangent(getMatrixElement(mat, 0), -getMatrixElement(mat, 1)))
                return true
            else 
                xyz:SetX(-math:InverseTangent2(getMatrixElement(mat, 3), getMatrixElement(mat, 4))) //xyz:SetX(-math:InverseTangent(getMatrixElement(mat, 4), getMatrixElement(mat, 3)))
                xyz:SetY(- 6.283185307179586232 * 0.25)  //1.5707963705062866
                xyz:SetZ(0.0)
                return false
            end
        else 
            xyz:SetX(math:InverseTangent2(getMatrixElement(mat, 3), getMatrixElement(mat, 4))) //xyz:SetX(math:InverseTangent(getMatrixElement(mat, 4), getMatrixElement(mat, 3)))
            xyz:SetY(6.283185307179586232 * 0.25)
            xyz:SetZ(0.0)
        end
        return false
    end

    /*
    This action calculates whether the objects are within the linear limits.
    */
//not used
    action CalculateLinearInfo()
        Vector3 temp
        
        temp:Set(calculatedTransformB:GetOrigin())
        temp:Subtract(calculatedTransformA:GetOrigin())

        Matrix3 basisInv

        //calculatedTransformA:GetBasis():PrintThis()

        basisInv:Set(calculatedTransformA:GetBasis():Inverse())
        basisInv:Transform(calculatedLinearDifference)

        linearLimits:SetCurrentLinearDiff(calculatedLinearDifference)
        linearLimits:TestLimitValue(0, calculatedLinearDifference:GetX())
        linearLimits:TestLimitValue(1, calculatedLinearDifference:GetY())
        linearLimits:TestLimitValue(2, calculatedLinearDifference:GetZ())
    end

    /*
    This action calculates the angular difference between object A and object B.
    */
    action CalculateAngleInfo() 
	Matrix3 mat
	Matrix3 relativeFrame

	mat:Set(calculatedTransformA:GetBasis())
	mat:Inverse()
	relativeFrame:Multiply(mat, calculatedTransformB:GetBasis())   //relativeFrame = mat * calculatedTransformB:GetBasis()

	MatrixToEulerXYZ(relativeFrame, calculatedAxisAngleDifference)

	Vector3 axis0 
	axis0:Set(calculatedTransformB:GetBasis():GetColumn(0))

	Vector3 axis2
        Vector3 axis22
        axis2:Set(calculatedTransformA:GetBasis():GetColumn(2))
        axis22:Set(axis2)

        Vector3 cAxis1
	calculatedAxis1:Set(axis2:CrossProduct(axis0))
        cAxis1:Set(calculatedAxis1)
	calculatedAxis0:Set(cAxis1:CrossProduct(axis22))
	calculatedAxis2:Set(axis0:CrossProduct(calculatedAxis1))
    end

    /*
    This action calculates the angular difference and position difference of the joint between objects A and B, and calculates whether
    the objects are within the position limits.
    */
    action CalculateTransforms() 
	calculatedTransformA:Set(parent:Joint3D:itemA:GetCenterOfMassTransform())
	calculatedTransformA:Multiply(frameInA)                 //joint for A in global coordinates

	calculatedTransformB:Set(parent:Joint3D:itemB:GetCenterOfMassTransform())
	calculatedTransformB:Multiply(frameInB)                 //joint for B in global coordinates
  
	CalculateAngleInfo()
    end  


    /*
    This action tests if the relative angle between the two objects is within the angular limit that we defined.
    Attribute: Parameter axisIndex The axis that you want to test, 0 for x, 1 for y, 2 for z.
    Attribute: Returns false if outside of limit, true if within limit.
    */
    action TestAngularLimitMotor(integer axisIndex) returns boolean
	number angle = 0
        if axisIndex = 0
            angle = calculatedAxisAngleDifference:GetX()
        elseif axisIndex = 1
            angle = calculatedAxisAngleDifference:GetY()
        elseif axisIndex = 2
            angle = calculatedAxisAngleDifference:GetZ()
        end


        //adjust the angle 
        //angle = AdjustAngleToLimits(angle, angularLimits:Get(axisIndex):GetLoLimit(), angularLimits:Get(axisIndex):GetHiLimit())

        //test limits
        if axisIndex = 0
            //angularLimits0:SetCurrentPosition(angle)
            angularLimits0:TestLimitValue(angle)
            return angularLimits0:NeedApplyTorques()
        elseif axisIndex = 1
            //angularLimits1:SetCurrentPosition(angle)
            angularLimits1:TestLimitValue(angle)
            return angularLimits1:NeedApplyTorques()
        elseif axisIndex = 2
            //angularLimits2:SetCurrentPosition(angle)
            angularLimits2:TestLimitValue(angle)
            return angularLimits2:NeedApplyTorques()
        else
            output "invalid index"
            return false
        end
    end  



    private action AdjustAngleToLimits(number angleInRadians, number angleLowerLimitInRadians, number angleUpperLimitInRadians) returns number
        if (angleLowerLimitInRadians >= angleUpperLimitInRadians)
            return angleInRadians
        elseif (angleInRadians < angleLowerLimitInRadians)
            number diffLo = math:AbsoluteValue(NormalizeAngle(angleLowerLimitInRadians - angleInRadians))
            number diffHi = math:AbsoluteValue(NormalizeAngle(angleUpperLimitInRadians - angleInRadians))

            if (diffLo < diffHi)
                return angleInRadians
            else
                return angleInRadians + 2*math:pi
            end
        elseif (angleInRadians > angleUpperLimitInRadians)
            number diffHi = math:AbsoluteValue(NormalizeAngle(angleInRadians - angleUpperLimitInRadians))
            number diffLo = math:AbsoluteValue(NormalizeAngle(angleInRadians - angleLowerLimitInRadians))

            if (diffLo < diffHi)
                return angleInRadians - 2*math:pi
            else
                return angleInRadians 
            end
        else
            return angleInRadians
        end
    end 


    private action NormalizeAngle(number angleInRadians) returns number
        angleInRadians = math:Remainder(angleInRadians, math:pi*2)
        if (angleInRadians < -math:pi)
            return angleInRadians + math:pi*2
        elseif (angleInRadians > math:pi)
            return angleInRadians - math:pi*2
        else
            return angleInRadians
        end
    end
    /*
    This action finds the values that are useful to calculate if the two objects are within the position limits.
    */
    action BuildLinearJacobian(integer jacobianLinearIndex, Vector3 normalWorld, Vector3 pivotAInW, Vector3 pivotBInW) 
	Matrix3 mat1
        mat1:Set(parent:Joint3D:itemA:GetCenterOfMassTransform():GetBasis())
	mat1:Transpose()

	Matrix3 mat2
        mat2:Set(parent:Joint3D:itemB:GetCenterOfMassTransform():GetBasis())
	mat2:Transpose()
		
	Vector3 tmp1
        tmp1:Set(pivotAInW)
	tmp1:Subtract(parent:Joint3D:itemA:GetCenterOfMassPosition())

	Vector3 tmp2
        tmp2:Set(pivotBInW)
	tmp2:Subtract(parent:Joint3D:itemB:GetCenterOfMassPosition())


        if (jacobianLinearIndex = 0)
            jacobianLinear0:Initialize(mat1,mat2,tmp1,tmp2,normalWorld,
                                parent:Joint3D:itemA:GetInverseInertiaLocal(), 
				parent:Joint3D:itemA:GetInverseMass(),
				parent:Joint3D:itemB:GetInverseInertiaLocal(),
				parent:Joint3D:itemB:GetInverseMass())
        elseif (jacobianLinearIndex = 1)
            jacobianLinear1:Initialize(mat1,mat2,tmp1,tmp2,normalWorld,
                                parent:Joint3D:itemA:GetInverseInertiaLocal(), 
				parent:Joint3D:itemA:GetInverseMass(),
				parent:Joint3D:itemB:GetInverseInertiaLocal(),
				parent:Joint3D:itemB:GetInverseMass())
        elseif (jacobianLinearIndex = 2)
            jacobianLinear2:Initialize(mat1,mat2,tmp1,tmp2,normalWorld,
                                parent:Joint3D:itemA:GetInverseInertiaLocal(), 
				parent:Joint3D:itemA:GetInverseMass(),
				parent:Joint3D:itemB:GetInverseInertiaLocal(),
				parent:Joint3D:itemB:GetInverseMass())
        else
            output "invalid index"
        end
    end

    /*
    This action finds values that are useful for calculating the angular difference between the two objects.
    */
    action BuildAngularJacobian(integer jacobianAngularIndex, Vector3 jointAxisW) 
        Matrix3 mat1 
        mat1:Set(parent:Joint3D:itemA:GetCenterOfMassTransform():GetBasis())
        mat1:Transpose()

	Matrix3 mat2 
        mat2:Set(parent:Joint3D:itemB:GetCenterOfMassTransform():GetBasis())
	mat2:Transpose()

        if (jacobianAngularIndex = 0)
            jacobianAng0:Initialize(jointAxisW,
				mat1,
				mat2,
				parent:Joint3D:GetItemA():GetInverseInertiaLocal(),
				parent:Joint3D:GetItemB():GetInverseInertiaLocal())
        elseif (jacobianAngularIndex = 1)
            jacobianAng1:Initialize(jointAxisW,
				mat1,
				mat2,
				parent:Joint3D:GetItemA():GetInverseInertiaLocal(),
				parent:Joint3D:GetItemB():GetInverseInertiaLocal())
        elseif (jacobianAngularIndex = 2)
            jacobianAng2:Initialize(jointAxisW,
				mat1,
				mat2,
				parent:Joint3D:GetItemA():GetInverseInertiaLocal(),
				parent:Joint3D:GetItemB():GetInverseInertiaLocal())
        else
            output "invalid index"
        end
    end



    /*
    This action tests if the position of the two objects is within the position limits that we have set.
    Attribute: Parameter axisIndex The axis that you want to test, 0 for x, 1 for y, 2 for z.
    Attribute: Returns false if outside of limit, true if within limit.
    */
    action TestLinearLimitMotor(integer axisIndex) returns boolean
	number diff = 0

        if axisIndex = 0
            diff = calculatedLinearDifference:GetX()
        elseif axisIndex = 1
            diff = calculatedLinearDifference:GetY()
        elseif axisIndex = 2
            diff = calculatedLinearDifference:GetZ()
        end

	linearLimits:TestLimitValue(axisIndex, diff) 
	return linearLimits:NeedApplyForces(axisIndex)
    end

    /*
    This action calls the BuildAngularJacobian and BuildLinearJacobian. This action is called by the Collision Solver.
    */
    action BuildJacobian
        output "building jacobian"
	linearLimits:SetAccumulatedImpulse(0, 0, 0)
        angularLimits0:SetAccumulatedImpulse(0)
        angularLimits1:SetAccumulatedImpulse(0)
        angularLimits2:SetAccumulatedImpulse(0)

	CalculateTransforms()
		
	Vector3 tmpVec
	CalculateAnchorPosition()
	Vector3 pivotAInW
	Vector3 pivotBInW
        pivotAInW:Set(anchorPosition)
	pivotBInW:Set(anchorPosition)

	Vector3 normalWorld
        i = 0
	repeat 3 times
            if  linearLimits:IsLimited(i)
                if useLinearReferenceFrameA 
                    normalWorld:Set(calculatedTransformA:GetBasis():GetColumn(i))
                else 
                    normalWorld:Set(calculatedTransformB:GetBasis():GetColumn(i))
                end
                BuildLinearJacobian(i, normalWorld, pivotAInW, pivotBInW)
            end
            i = i + 1 
	end

	i = 0
        repeat 3 times
            if TestAngularLimitMotor(i)    
                normalWorld:Set(me:GetAxis(i))
                BuildAngularJacobian(i, normalWorld)
            end
            i = i + 1
	end
    end

    /*
    This action solves the constraint of this joint and make sure that objects A and B is able to move with the joint constraint applied.
    */
    action SolveJoint(number localtimeStep) 
        output "solving 6dof"
	timeStep = localtimeStep
        Vector3 pointInA
        Vector3 pointInB
        pointInA:Set(calculatedTransformA:GetOrigin())
        pointInB:Set(calculatedTransformB:GetOrigin())

	number jacDiagABInv = 0
	Vector3 linearAxis
        integer i = 0


        repeat 3 times
            if linearLimits:IsLimited(i)
                output "axis " + i + " is limited"
                if (i = 0)
                    jacDiagABInv = 1 / jacobianLinear0:GetDiagonal()
                elseif (i = 1)
                    jacDiagABInv = 1 / jacobianLinear1:GetDiagonal()
                elseif (i = 2)
                    jacDiagABInv = 1 / jacobianLinear2:GetDiagonal()
                end


                if useLinearReferenceFrameA
                    linearAxis:Set(calculatedTransformA:GetBasis():GetColumn(i))
                else
                    linearAxis:Set(calculatedTransformB:GetBasis():GetColumn(i))
                end

                linearLimits:SolveLinearAxis(timeStep, jacDiagABInv, parent:Joint3D:GetItemA(), pointInA, parent:Joint3D:GetItemB(), pointInB, i, linearAxis, anchorPosition)
            end
            i = i + 1
        end

/*
        repeat 3 times
            if linearLimits:NeedApplyForces(i)
		jacDiagABInv = 1 / jacobianLinear:Get(i):GetDiagonal()
		if useLinearReferenceFrameA 
                    linearAxis:Set(calculatedTransformA:GetBasis():GetColumn(i))
		else 
                    linearAxis:Set(calculatedTransformB:GetBasis():GetColumn(i))
		end
		linearLimits:SolveLinearAxis(timeStep, jacDiagABInv, parent:Joint3D:GetItemA(), pointInA, parent:Joint3D:GetItemB(), pointInB, i, linearAxis, anchorPosition)
            end
            i = i + 1
        end*/

	Vector3 angularAxis
	number angularJacDiagABInv = 0
        i = 0

        if angularLimits0:NeedApplyTorques()
            angularAxis:Set(GetAxis(0))
            angularJacDiagABInv = 1 / jacobianAng0:GetDiagonal()
            angularLimits0:SolveAngularLimits(timeStep, angularAxis, angularJacDiagABInv, parent:Joint3D:GetItemA(), parent:Joint3D:GetItemB())
        end  

        if angularLimits1:NeedApplyTorques()
            angularAxis:Set(GetAxis(1))
            angularJacDiagABInv = 1 / jacobianAng0:GetDiagonal()
            angularLimits1:SolveAngularLimits(timeStep, angularAxis, angularJacDiagABInv, parent:Joint3D:GetItemA(), parent:Joint3D:GetItemB())
        end  

        if angularLimits2:NeedApplyTorques()
            angularAxis:Set(GetAxis(2))
            angularJacDiagABInv = 1 / jacobianAng0:GetDiagonal()
            angularLimits2:SolveAngularLimits(timeStep, angularAxis, angularJacDiagABInv, parent:Joint3D:GetItemA(), parent:Joint3D:GetItemB())
        end  
    end

    action updateRHS(number timeStep) 
    end    

    /*
    This action returns the rotational axis in global coordinates.
    Attribute: Parameter axisIndex The axis that you want to test, 0 for x, 1 for y, 2 for z.
    Attribute: Returns the rotational axis in global coordinates.
    */
    action GetAxis(integer axisIndex) returns Vector3
        if (axisIndex = 0)
            return calculatedAxis0
        elseif (axisIndex = 1)
            return calculatedAxis1
        elseif (axisIndex = 2)
            return calculatedAxis2
        else 
            output "invalid index"
            Vector3 out
            return out
        end
    end

    /*
    This action returns the relative angle.
    Attribute: Parameter axisIndex The axis that you want to test, 0 for x, 1 for y, 2 for z.
    Attribute: Returns the relative angle.
    */
    action GetAngle(integer axisIndex) returns number
        if axisIndex = 0
            return calculatedAxisAngleDifference:GetX()
        elseif axisIndex = 1
            return calculatedAxisAngleDifference:GetY()
        elseif axisIndex = 2
            return calculatedAxisAngleDifference:GetZ()
        end
        return 0
    end

    /*
    This action returns the position and tilt of the object A.
    Attribute: Returns the position and tilt of the object A.
    */
    action GetCalculatedTransformA() returns PhysicsPosition3D
        PhysicsPosition3D out
        out:Set(calculatedTransformA)
	return out
    end

    /*
    This action returns the position and tilt of the object B.
    Attribute: Returns the position and tilt of the object B.
    */
    action GetCalculatedTransformB() returns PhysicsPosition3D
        PhysicsPosition3D out
	out:Set(calculatedTransformB)
	return out
    end

    /*
    This action returns the position and tilt of the object A.
    Attribute: Returns the position and tilt of the object A.
    */
    action GetFrameOffsetA() returns PhysicsPosition3D 
        PhysicsPosition3D out
	out:Set(frameInA)
	return out
    end    

    /*
    This action returns the position and tilt of the object B.
    Attribute: Returns the position and tilt of the object B.
    */
    action GetFrameOffsetB() returns PhysicsPosition3D
        PhysicsPosition3D out
	out:Set(frameInB)
	return out
    end
	
    /*
    This action sets the lower position limit.
    Attribute: Parameter linearLower The lower position limit.
    */
    action SetLinearLowerLimit(Vector3 linearLower) 
	linearLimits:SetLowerLimit(linearLower)
    end            

    /*
    This action sets the upper position limit.
    Attribute: Parameter linearUpper The upper position limit.
    */
    action SetLinearUpperLimit(Vector3 linearUpper)
	linearLimits:SetUpperLimit(linearUpper)
    end
    
    /*
    This action sets the lower angular limit.
    Attribute: Parameter angularLower The lower angular limit.
    */
    action SetAngularLowerLimit(Vector3 angularLower) 
	angularLimits0:SetLoLimit(angularLower:GetX())
	angularLimits1:SetLoLimit(angularLower:GetY())
	angularLimits2:SetLoLimit(angularLower:GetZ())
    end            

    /*
    This action sets the upper angular limit.
    Attribute: Parameter angularUpper The upper angular limit.
    */
    action SetAngularUpperLimit(Vector3 angularUpper) 
	angularLimits:Get(0):SetHiLimit(angularUpper:GetX())
	angularLimits:Get(1):SetHiLimit(angularUpper:GetY())
	angularLimits:Get(2):SetHiLimit(angularUpper:GetZ())
    end    

    /*
    This action returns the angular limit.
    Attribute: Parameter index The axis that you want to test, 0 for x, 1 for y, 2 for z.
    Attribute: Returns the angular limit stored inside a RotationalLimitMotor3D object.
    */
    action GetRotationalLimitMotor(integer index) returns RotationalLimitMotor3D
	return angularLimits:Get(index)
    end

    /*
    This action returns the position limit. 
    Attribute: Returns the position limit stored inside a TranslationalLimitMotor3D object.
    */
    action GetTranslationalLimitMotor() returns TranslationalLimitMotor3D
	return linearLimits
    end    

    /*
    This action sets the position limit of the one of the axis.
    Attribute: Parameter axis The axis that you want to set, 0 for x, 1 for y, 2 for z.
    Attribute: Parameter lo The lower position limit.
    Attribute: Parameter hi The higher position limit.
    */
    action SetLimit(integer axis, number lo, number hi) 
	if axis < 3
            if axis = 0
                linearLimits:GetLowerLimit():SetX(lo)
                linearLimits:GetUpperLimit():SetX(hi)
            elseif axis = 1
                linearLimits:GetLowerLimit():SetY(lo)
                linearLimits:GetUpperLimit():SetY(hi)
            elseif axis = 2
                linearLimits:GetLowerLimit():SetZ(lo)
                linearLimits:GetUpperLimit():SetZ(hi)
            end
	else 
            angularLimits:Get(axis - 3):SetLoLimit(lo)
            angularLimits:Get(axis - 3):SetHiLimit(hi)
	end
    end            
	
    /*
    This action returns if one of the axis is limited in position.
    Attribute: Parameter limitIndex The axis that you want to test, 0 for x, 1 for y, 2 for z.
    Attribute: Returns false if the axis is not limited, true if the axis is limited.
    */
    action IsLimited(integer limitIndex) returns boolean
	if limitIndex < 3
            return linearLimits:IsLimited(limitIndex)
	end
	return angularLimits:Get(limitIndex - 3):IsLimited()
    end

    /*
    This action calculates the center of the system that composes of object A and object B.
    */
    action CalculateAnchorPosition() 
	number imA = parent:Joint3D:GetItemA():GetInverseMass()
	number imB = parent:Joint3D:GetItemB():GetInverseMass()
	number weight = 0
	if imB = 0
            weight = 1
	else 
            weight = imA / (imA + imB)
	end
	Vector3 pA
	Vector3 pB
        pA:Set(calculatedTransformA:GetOrigin())
        pB:Set(calculatedTransformB:GetOrigin())
	Vector3 tmp1
	Vector3 tmp2

	tmp1:Set(pA:Scale(weight))
	tmp2:Set(pB:Scale(1 - weight))
        tmp1:Add(tmp2)    //temp1 = temp1 + temp2
	anchorPosition:Set(tmp1)

        output "anchor position for 6dof:"
        anchorPosition:Output()
    end            
end

