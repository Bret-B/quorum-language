package Libraries.Game.Physics.Joints
use Libraries.Compute.Vector2
use Libraries.Interface.Item2D
use Libraries.Game.Collision.PhysicsPosition2D
use Libraries.Compute.Math

class DistanceJoint is Joint2D
    Vector2 localAnchorA
    Vector2 localAnchorB
    number length = 1
    number frequency = 0
    number dampingRatio = 0
    
    on create
        parent:Joint2D:SetType(parent:Joint2D:DISTANCEJOINT)
        localAnchorA:Set(0, 0)
        localAnchorB:Set(0, 0)
    end


    number bias = 0
    
    //Solver shared data
    number gamma = 0
    number impulse = 0
    Math math
    

    //Solver temp data
    integer indexA = 0
    integer indexB = 0
    Vector2 u
    Vector2 rA
    Vector2 rB
    Vector2 localCenterA
    Vector2 localCenterB
    number inverseMassA = 0
    number inverseMassB = 0
    number inverseInertiaA = 0
    number inverseInertiaB = 0
    number mass = 0

    /* 
        This action initializes the items, local anchors, and the length based on the passed
        items, and the world anchor points.

        parameters:
        * first body
        * second body
        * world anchor on first body
        * world anchor on second body
    */
    action InitializeDistanceJoint(Item2D itemA, Item2D itemB, Vector2 anchorA, Vector2 anchorB) 
        parent:Joint2D:itemA = itemA
        parent:Joint2D:itemB = itemB
        localAnchorA:Set(parent:Joint2D:itemA:GetLocalPoint(anchorA))
        localAnchorB:Set(parent:Joint2D:itemB:GetLocalPoint(anchorB))
        Vector2 distance
        distance:Set(anchorB:Subtract(anchorA))
        length = distance:Length()       
    end

    action SetFrequency(number hz)
        frequency = hz
    end

    action GetFrequency() returns number
        return frequency
    end

    action SetLength(number passedLength)
        length = passedLength
    end

    action GetLength() returns number
        return length
    end

    action SetDampingRatio(number ratio)
        dampingRatio = ratio
    end

    action GetDampingRatio() returns number
        return dampingRatio
    end

    action GetAnchorA()returns Vector2
        return parent:Joint2D:itemA:GetWorldPoint(localAnchorA)
    end

    action GetAnchorB() returns Vector2
        return parent:Joint2D:itemB:GetWorldPoint(localAnchorB)
    end
    
    action GetReactionForce(number inverseTimeStep) returns Vector2
        Vector2 reactionForce
        reactionForce:SetX(impulse * u:GetX() * inverseTimeStep)
        reactionForce:SetY(impulse * u:GetY() * inverseTimeStep)
        return reactionForce
    end

    action GetReactionTorque(number inverseTimeStep) returns number
        return 0
    end

    action InitializeVelocityConstraints (JointSolverData data)
        indexA = parent:Joint2D:itemA:GetCollisionGroupIndex()
        indexB = parent:Joint2D:itemB:GetCollisionGroupIndex()
        localCenterA:Set(parent:Joint2D:itemA:GetSweep():GetLocalCenter())
        localCenterB:Set(parent:Joint2D:itemB:GetSweep():GetLocalCenter())
        inverseMassA = parent:Joint2D:itemA:GetInverseMass()
        inverseMassB = parent:Joint2D:itemB:GetInverseMass()
        inverseInertiaA = parent:Joint2D:itemA:GetInverseInertia()
        inverseInertiaB = parent:Joint2D:itemB:GetInverseInertia()
        
        Vector2 positionA = data:GetPositions():Get(indexA)
        number angleA = data:GetAngles():Get(indexA)
        Vector2 linearVelocityA = data:GetLinearVelocities():Get(indexA)
        number angularVelocityA = data:GetAngularVelocities():Get(indexA)

        Vector2 positionB = data:GetPositions():Get(indexB)
        number angleB = data:GetAngles():Get(indexB)
        Vector2 linearVelocityB = data:GetLinearVelocities():Get(indexB)
        number angularVelocityB = data:GetAngularVelocities():Get(indexB)
        
        PhysicsPosition2D transformA
        PhysicsPosition2D transformB

        transformA:Set(positionA, angleA)
        transformB:Set(positionB, angleB)
        
        //u is used as a temporary variable
        u = u:Set(localAnchorA):Subtract(localCenterA)        
        rA:SetX((transformA:GetCosine() * u:GetX() - transformA:GetSine() * u:GetY()) + transformA:GetPosition():GetX())
        rA:SetY((transformA:GetSine() * u:GetX() + transformA:GetCosine() * u:GetY()) + transformA:GetPosition():GetY())

        u = u:Set(localAnchorB):Subtract(localCenterB)        
        rB:SetX((transformB:GetCosine() * u:GetX() - transformB:GetSine() * u:GetY()) + transformB:GetPosition():GetX())
        rB:SetY((transformB:GetSine() * u:GetX() + transformB:GetCosine() * u:GetY()) + transformB:GetPosition():GetY())

        u:Set(positionB):Add(rB):Subtract(positionA):Subtract(rA)
        
        //handle singularities
        number localLength = u:Length()
        if (length > 0.005)
            u:SetX(u:GetX() * 1.0 / localLength)
            u:SetY(u:GetY() * 1.0 / localLength)
        else
            u:SetZero()
        end

        number crossAu = rA:CrossProduct(u)
        number crossBu = rB:CrossProduct(u)
        number inverseMass = inverseMassA + inverseInertiaA * crossAu * crossAu + inverseMassB + inverseInertiaB * crossBu * crossBu

        // Compute the effective mass matrix.
        if inverseMass not= 0
            mass = 1 / inverseMass
        else
            mass = 0
        end

        if frequency > 0
            number lengthDiff = localLength - length
            
            //frequency
            number omega = 2.0 * math:pi * frequency

            number dampingCoefficient = 2.0 * mass * dampingRatio * omega
            
            number springStiffness = mass * omega * omega
            
            //magic formulas
            number magic = data:GetTimeStep2D():GetTimeStep()
            gamma = magic * (dampingCoefficient + magic * springStiffness)
            if inverseMass not= 0
                gamma = 1 / gamma
            else 
                gamma = 0
            end
            bias = lengthDiff * magic * springStiffness * gamma
            
            inverseMass = inverseMass + gamma
            if inverseMass not= 0
                mass = 1 / inverseMass
            else 
                mass = 0
            end
            
        else
            gamma = 0
            bias = 0
        end

        if data:GetTimeStep2D():IsWarmStarting()
            impulse = impulse * data:GetTimeStep2D():GetTimeStepRatio()
            Vector2 p 
            p:Set(u):Scale(impulse)
            
            linearVelocityA:SetX(linearVelocityA:GetX() - inverseMassA * p:GetX())
            linearVelocityA:SetY(linearVelocityA:GetY() - inverseMassA * p:GetY())
            angularVelocityA = angularVelocityA - inverseInertiaA * rA:CrossProduct(p)

            linearVelocityB:SetX(linearVelocityB:GetX() + inverseMassB * p:GetX())
            linearVelocityB:SetY(linearVelocityB:GetY() + inverseMassB * p:GetY())
            angularVelocityB = angularVelocityB + inverseInertiaB * rB:CrossProduct(p)

        else
            impulse = 0            
        end

        data:SetAngularVelocity(angularVelocityA, indexA)
        data:SetAngularVelocity(angularVelocityB, indexB)
    end

    action solveVelocityConstraints(JointSolverData data)
        Vector2 linearVelocityA = data:GetLinearVelocities():Get(indexA)
        number angularVelocityA = data:GetAngularVelocities():Get(indexA)
        Vector2 linearVelocityB = data:GetLinearVelocities():Get(indexB)
        number angularVelocityB = data:GetAngularVelocities():Get(indexB)

        Vector2 vpA 
        Vector2 vpB
        
        //cdot = dot (u, v + cross(w, r))
        vpA:SetX(-angularVelocityA * rA:GetY())
        vpA:SetY(angularVelocityA * rA:GetX())
        vpA:Add(linearVelocityA)
        
        vpB:SetX(-angularVelocityB * rB:GetY())
        vpB:SetY(angularVelocityB * rB:GetX())
        vpB:Add(linearVelocityB)

        number cDot = u:DotProduct(vpB:Subtract(vpA))
        
        number localImpulse = -mass * (cDot + bias + gamma * impulse)
        impulse = impulse + localImpulse

        number px = localImpulse * u:GetX()
        number py = localImpulse * u:GetY()

        linearVelocityA:SetX(linearVelocityA:GetX() - inverseMassA * px)
        linearVelocityA:SetX(linearVelocityA:GetX() - inverseMassB * px)
        angularVelocityA = angularVelocityA - inverseInertiaA * (rA:GetX() * py - rA:GetY() * px)
        linearVelocityB:SetX(linearVelocityB:GetX() + inverseMassB * px)
        linearVelocityB:SetX(linearVelocityB:GetX() + inverseMassB * px)
        angularVelocityB = angularVelocityB + inverseInertiaB * (rB:GetX() * py - rB:GetY() * px)
 
        data:SetAngularVelocity(angularVelocityA, indexA)
        data:SetAngularVelocity(angularVelocityB, indexB)   
    end

    action solvePositionConstraints(JointSolverData data) returns boolean
        if frequency > 0
            return true
        end
        PhysicsPosition2D transformA 
        PhysicsPosition2D transformB
        Vector2 rALocal
        Vector2 rBLocal
        Vector2 uLocal
        
        Vector2 positionA = data:GetPositions():Get(indexA)
        number angleA = data:GetAngles():Get(indexA)
        Vector2 positionB = data:GetPositions():Get(indexB)
        number angleB = data:GetAngles():Get(indexB)
        
        transformA:Set(positionA, angleA)
        transformB:Set(positionB, angleB)
        
        uLocal = uLocal:Set(localAnchorA):Subtract(localCenterA)        
        rALocal:SetX((transformA:GetCosine() * uLocal:GetX() - transformA:GetSine() * uLocal:GetY()) + transformA:GetPosition():GetX())
        rALocal:SetY((transformA:GetSine() * uLocal:GetX() + transformA:GetCosine() * uLocal:GetY()) + transformA:GetPosition():GetY())

        uLocal = uLocal:Set(localAnchorB):Subtract(localCenterB)        
        rBLocal:SetX((transformB:GetCosine() * uLocal:GetX() - transformB:GetSine() * uLocal:GetY()) + transformB:GetPosition():GetX())
        rBLocal:SetY((transformB:GetSine() * uLocal:GetX() + transformB:GetCosine() * uLocal:GetY()) + transformB:GetPosition():GetY())

        uLocal:Set(positionB):Add(rBLocal):Subtract(positionA):Subtract(rALocal)
        
        number lengthLocal = u:Length()
        u:Normalize()
        
        number c = lengthLocal - length
        number clampedValue = c
        if c < -0.2 
            clampedValue = -0.2
        end
        if c > 0.2
            clampedValue = 0.2
        end
        c = clampedValue
        
        number impulseLocal = -mass * c
        number px = impulseLocal * uLocal:GetX()
        number py = impulseLocal * uLocal:GetY()
        
        positionA:SetX(positionA:GetX() - inverseMassA * px)
        positionA:SetY(positionA:GetY() - inverseMassA * py)
        angleA = angleA - (inverseInertiaA * (rALocal:GetX() * py - rALocal:GetY() * px))
        positionB:SetX(positionB:GetX() + inverseMassB * px)
        positionB:SetY(positionB:GetY() + inverseMassB * py)
        angleB = angleB + (inverseInertiaB * (rBLocal:GetX() * py - rBLocal:GetY() * px))

        data:SetAngle(angleA, indexA)
        data:SetAngle(angleB, indexB)
        
        return math:AbsoluteValue(c) < 0.005           
    end
end
