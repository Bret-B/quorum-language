package Libraries.Game.Physics.Joints

use Libraries.Game.Physics.CollisionSolverInformation3D
use Libraries.Game.Physics.all
use Libraries.Interface.Item3D
use Libraries.Containers.Array
use Libraries.Compute.Math  
use Libraries.Compute.Vector3  
use Libraries.Compute.Matrix3
use Libraries.Game.Physics.Joints.RotationalLimitMotor3D
use Libraries.Game.Physics.Joints.TranslationalLimitMotor3D   
use Libraries.Game.Physics.ConstraintDescription3D
use Libraries.Game.Collision.PhysicsPosition3D
use Libraries.Compute.Quaternion

class HingeJoint3D is Joint3D
        Math math
        PhysicsPosition3D frameInA  
        PhysicsPosition3D frameInB  

        Array<ConstraintDescription3D> jac/*[3]*/ 
        Array<ConstraintDescription3D> jacAng/*[3]*/


        ConstraintDescription3D jac0
        ConstraintDescription3D jac1
        ConstraintDescription3D jac2




        ConstraintDescription3D jacAng0
        ConstraintDescription3D jacAng1
        ConstraintDescription3D jacAng2


        number motorTargetVelocity = 0
        number maxMotorImpulse = 0
        number limitSoftness = 0.9

	number biasFactor = 0.3         //The bias should be in the range of 0.2 - 0.5
	number relaxationFactor = 1


        //these initial values make it so that the joint is free upon starting
	number lowerLimit = math:RaiseToPower(10, 30)	
	number upperLimit = math:RaiseToPower(10, -30)	
	
	number kHinge = 0

	number limitSign = 0
	number correction = 0

	number accLimitImpulse = 0

	boolean angularOnly = false
	boolean enableAngularMotor = false
	boolean solveLimit = false

        number epsilon = 1.1920928955078125 * (math:RaiseToPower(10, -07))

    on create
        ConstraintDescription3D filler
        jacAng:Add(filler)
        jacAng:Add(filler)
        jacAng:Add(filler)
        jac:Add(filler)
        jac:Add(filler)
        jac:Add(filler)
        parent:Joint3D:SetType(parent:Joint3D:Hinge)
    end


    /*
    axisInA: unit vector that specifieds which axis that object A is allowed to spin around.
    */
    action Initialize(Item3D itemA, Item3D itemB, Vector3 pivotInA, Vector3 pivotInB, Vector3 axisInA, Vector3 axisInB)
        parent:Joint3D:SetItemA(itemA)
        parent:Joint3D:SetItemB(itemB)
        parent:Joint3D:SetType(parent:Joint3D:Hinge)

        angularOnly = false
        enableAngularMotor = false

        frameInA:GetOrigin():Set(pivotInA)  //pivot in A's perspective

        // since no frame is given, assume this to be zero angle and just pick rb transform axis
        Vector3 rbAxisA1
        Vector3 rbAxisA2

        PhysicsPosition3D centerOfMassA
        centerOfMassA:Set(itemA:GetCenterOfMassTransform())

        //get the 0th column of COM A
        rbAxisA1:Set(centerOfMassA:GetBasis():GetColumn(0))


        number projection = axisInA:DotProduct(rbAxisA1)

        number lowError = 1 - epsilon
        number highError = -1 + epsilon

        if projection >= lowError
            rbAxisA1:Set(centerOfMassA:GetBasis():GetColumn(2))
            rbAxisA1:MakeOpposite()
            rbAxisA2:Set(centerOfMassA:GetBasis():GetColumn(1))    
        elseif (projection <= highError)
            rbAxisA1:Set(centerOfMassA:GetBasis():GetColumn(2))
            rbAxisA2:Set(centerOfMassA:GetBasis():GetColumn(1))
        else 
            //cross product changes the original value
            Vector3 temp
            temp:Set(axisInA)
            rbAxisA2:Set(temp:CrossProduct(rbAxisA1))

            Vector3 temp2
            temp2:Set(rbAxisA2)
            rbAxisA1:Set(temp2:CrossProduct(axisInA))
        end

        frameInA:GetBasis():Set(rbAxisA1:GetX(), rbAxisA2:GetX(), axisInA:GetX(), rbAxisA1:GetY(), rbAxisA2:GetY(), axisInA:GetY(), rbAxisA1:GetZ(), rbAxisA2:GetZ(), axisInA:GetZ())
        

        //setting frameInB
        Quaternion rotationArc
        rotationArc:SetAsShortestArcQuaternion(axisInA, axisInB)
        Vector3 rbAxisB1
        rbAxisB1:Set(rotationArc:QuaternionRotate(rbAxisA1))

        Vector3 rbAxisB2
        rbAxisB2:Set(axisInB)
        rbAxisB2:CrossProduct(rbAxisB1)
        
        frameInB:GetOrigin():Set(pivotInB)

        frameInB:GetBasis():Set(rbAxisB1:GetX(), rbAxisB2:GetX(), -axisInB:GetX(), rbAxisB1:GetY(), rbAxisB2:GetY(), -axisInB:GetY(), rbAxisB1:GetZ(), rbAxisB2:GetZ(), -axisInB:GetZ())

//        output "Initializing"
//        frameInA:Output()
//        frameInB:Output()


        lowerLimit = math:RaiseToPower(10, 30)	
	upperLimit = math:RaiseToPower(10, -30)	
        biasFactor = 0.3
        relaxationFactor = 1.0
        limitSoftness = 0.9
        solveLimit = false
    end


    action BuildJacobian()
        Vector3 temp
        Vector3 temp1
        Vector3 temp2
        Vector3 tempVec

        Matrix3 mat1
        Matrix3 mat2


        PhysicsPosition3D centerOfMassA
        PhysicsPosition3D centerOfMassB
        centerOfMassA:Set(parent:Joint3D:itemA:GetCenterOfMassTransform())
        centerOfMassB:Set(parent:Joint3D:itemB:GetCenterOfMassTransform())
        




        parent:Joint3D:appliedImpulse = 0

        if (not angularOnly)
            Vector3 pivotAInW
            pivotAInW:Set(frameInA:GetOrigin())
            centerOfMassA:Transform(pivotAInW)

            Vector3 pivotBInW
            pivotBInW:Set(frameInB:GetOrigin())
            centerOfMassB:Transform(pivotBInW)


            Vector3 relativePosition
            relativePosition:Set(pivotBInW)
            relativePosition:Subtract(pivotAInW)

            Vector3 normal0
            Vector3 normal1
            Vector3 normal2

            if(relativePosition:LengthSquared() > epsilon)
                normal0:Set(relativePosition)
                normal0:Normalize()
            else
                normal0:Set(1,0,0)
            end

//            output "before plane space"
//            normal:Get(0):Output()
//            normal:Get(1):Output()
//            normal:Get(2):Output()
            PlaneSpace1(normal0, normal1, normal2) 
//            output "after plane space"
//            normal:Get(0):Output()
//            normal:Get(1):Output()
//            normal:Get(2):Output()


            mat1:Set(centerOfMassA:GetBasis())    
            mat1:Transpose()
            mat2:Set(centerOfMassB:GetBasis())
            mat2:Transpose()

            temp1:Set(pivotAInW)
            temp1:Subtract(centerOfMassA:GetOrigin())   //temp1 = temp1 - centerOfMassA:GetOrigin()

            temp2:Set(pivotBInW)
            temp2:Subtract(centerOfMassB:GetOrigin())   //temp2 = temp2 - centerOfMassB:GetOrigin()

            jac0:Initialize(mat1, mat2, temp1, temp2, normal0, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemA:GetInverseMass(), parent:Joint3D:itemB:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseMass())
            jac1:Initialize(mat1, mat2, temp1, temp2, normal1, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemA:GetInverseMass(), parent:Joint3D:itemB:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseMass())
            jac2:Initialize(mat1, mat2, temp1, temp2, normal2, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemA:GetInverseMass(), parent:Joint3D:itemB:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseMass())
        end   //end if



        // calculate two perpendicular jointAxis, orthogonal to hingeAxis
        // these two jointAxis require equal angular velocities for both bodies
        Vector3 jointAxis0local
        Vector3 jointAxis1local

        temp:Set(frameInA:GetBasis():GetColumn(2))
        PlaneSpace1(temp, jointAxis0local, jointAxis1local)     //TODO: make sure jointAxis0local and jointAxis1local changed




        Vector3 jointAxis0
        jointAxis0:Set(jointAxis0local)
        centerOfMassA:GetBasis():Transform(jointAxis0)

        Vector3 jointAxis1  
        jointAxis1:Set(jointAxis1local)
        centerOfMassA:GetBasis():Transform(jointAxis1)

        Vector3 hingeAxisWorld
        hingeAxisWorld:Set(frameInA:GetBasis():GetColumn(2))
        centerOfMassA:GetBasis():Transform(hingeAxisWorld)


        mat1:Set(centerOfMassA:GetBasis())          //this part can be made faster
        mat1:Transpose()

        mat2:Set(centerOfMassB:GetBasis())          //this part can be made faster
        mat2:Transpose()


        jacAng0:Initialize(jointAxis0, mat1, mat2, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseInertiaLocal())
        jacAng1:Initialize(jointAxis1, mat1, mat2, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseInertiaLocal())
        jacAng2:Initialize(hingeAxisWorld, mat1, mat2, parent:Joint3D:itemA:GetInverseInertiaLocal(), parent:Joint3D:itemB:GetInverseInertiaLocal())


        // Compute limit information
        number hingeAngle = GetHingeAngle()

        //set bias, sign, clear accumulator
        correction = 0
        limitSign = 0
        solveLimit = false
        accLimitImpulse = 0

        if (lowerLimit < upperLimit)
            if (hingeAngle <= lowerLimit * limitSoftness)
                correction = (lowerLimit - hingeAngle)
                limitSign = 1
                solveLimit = true
            elseif (hingeAngle >= upperLimit * limitSoftness)
                correction = (upperLimit - hingeAngle)
                limitSign = -1
                solveLimit = true
            end
        end


        // Compute K = J*W*J' for hinge axis
        Vector3 axisA
        axisA:Set(frameInA:GetBasis():GetColumn(2))
        centerOfMassA:GetBasis():Transform(axisA)


        number dem1 = parent:Joint3D:itemA:ComputeAngularImpulseDenominator(axisA)
        number dem2 = parent:Joint3D:itemB:ComputeAngularImpulseDenominator(axisA)
        kHinge = 1/(dem1+dem2)     
    end


    private number SQRT12 = 0.7071067690849304
    private action PlaneSpace1(Vector3 n, Vector3 p, Vector3 q)
        if (math:AbsoluteValue(n:GetZ()) > SQRT12)
            number a = n:GetY() * n:GetY() + n:GetZ() * n:GetZ()
            number k = 1.0/a

            p:Set(0, -n:GetZ() * k, n:GetY() * k)
            q:Set(a*k, -n:GetX() * p:GetZ(), n:GetX()*p:GetY())

        else
            number a = n:GetY() * n:GetY() + n:GetX() * n:GetX()
            number k = 1.0/a

            p:Set(-n:GetY() * k, n:GetX() * k, 0)
            q:Set(-n:GetZ() * p:GetY(), n:GetZ()*p:GetX(), a*k)
        end
    end

    action SolveJoint(number timeStep)
        
        Vector3 temp
        Vector3 temp2
        Vector3 tempVec


        PhysicsPosition3D centerOfMassA
        PhysicsPosition3D centerOfMassB
        //output "------- Setting A ---------"
        centerOfMassA:Set(parent:Joint3D:itemA:GetCenterOfMassTransform())
        //output "------- Setting B ---------"
        centerOfMassB:Set(parent:Joint3D:itemB:GetCenterOfMassTransform())
        


//        output "Center of " + parent:Joint3D:itemA:GetDescription()
//        centerOfMassA:Output()  
//        
//        output "Center of " + parent:Joint3D:itemB:GetDescription()
//        centerOfMassB:Output()




        Vector3 pivotAInW
        pivotAInW:Set(frameInA:GetOrigin()) 
        centerOfMassA:Transform(pivotAInW)


        Vector3 pivotBInW

        pivotBInW:Set(frameInB:GetOrigin()) 
//        output "framInB position"
//        pivotBInW:Output()
        centerOfMassB:Transform(pivotBInW)
//        output "transformed"
//        pivotBInW:Output()


        number tau = 0.3

        if (not angularOnly)
            Vector3 rel_pos1
            rel_pos1:Set(pivotAInW) 
            rel_pos1:Subtract(parent:Joint3D:itemA:GetCenterOfMassTransform():GetOrigin())       //rel_pos1 = rel_pos1 - pivotAInW

            Vector3 rel_pos2
            rel_pos2:Set(pivotBInW) 
            rel_pos2:Subtract(parent:Joint3D:itemB:GetCenterOfMassTransform():GetOrigin())       //rel_pos1 = rel_pos1 - pivotAInW

            Vector3 vel1
            vel1:Set(parent:Joint3D:itemA:GetLinearVelocityAtLocalPoint(rel_pos1))

            Vector3 vel2
            vel2:Set(parent:Joint3D:itemB:GetLinearVelocityAtLocalPoint(rel_pos2))

            Vector3 vel
            vel:Set(vel1)
            vel:Subtract(vel2)      //vel = vel1 - vel2


            integer i = 0
            repeat 3 times
                Vector3 normal
                number jacDiagABInv = 1
                number rel_vel = 0  //relative velocity in the normal direction 
                if (i = 0)
                    normal:Set(jac0:GetLinearJointAxis())   
                    jacDiagABInv = 1/jac0:GetDiagonal()
                elseif (i = 1)
                    normal:Set(jac1:GetLinearJointAxis())
                    jacDiagABInv = 1/jac1:GetDiagonal()
                else
                    normal:Set(jac2:GetLinearJointAxis())
                    jacDiagABInv = 1/jac2:GetDiagonal()
                end

                rel_vel = normal:DotProduct(vel) 

                temp:Set(pivotAInW)  // positional error (zeroth order error)
                temp:Subtract(pivotBInW)        //temp = pivotAInW - pivotBInW

                number depth = 0
                depth = -(temp:DotProduct(normal))  // this is the error projected on the normal

                number impulse = depth * tau / timeStep * jacDiagABInv - rel_vel * jacDiagABInv


                parent:Joint3D:appliedImpulse = parent:Joint3D:appliedImpulse + impulse

                Vector3 impulse_vector 

                impulse_vector:Set(normal)
                //output "Direction to apply for A"
                //normal:Output()

                impulse_vector:Scale(impulse)

                temp:Set(pivotAInW) 
                temp:Subtract(parent:Joint3D:itemA:GetCenterOfMassTransform():GetOrigin())


                parent:Joint3D:itemA:ApplyImpulse(impulse_vector, temp)     //temp is the location position where the impulse will be applied

                temp:Set(impulse_vector)
                temp:MakeOpposite()        //temp = -impulse_vector

                temp2:Set(pivotBInW) 
                temp2:Subtract(parent:Joint3D:itemB:GetCenterOfMassTransform():GetOrigin())      //temp2 = temp2 - pivotBInW

                parent:Joint3D:itemB:ApplyImpulse(temp, temp2)
                i = i + 1
            end  //end for
        end  //end if


        //solving the angular part

        // get axes in world space
        Vector3 axisA
        axisA:Set(frameInA:GetBasis():GetColumn(2))    
        centerOfMassA:GetBasis():Transform(axisA)

        Vector3 axisB
        axisB:Set(frameInB:GetBasis():GetColumn(2))   
        centerOfMassB:GetBasis():Transform(axisB)


        //breaking up angular velocity into parallel and normal components to axis
        Vector3 angVelA
        angVelA:Set(parent:Joint3D:itemA:GetAngularVelocity())
        Vector3 angVelB
        angVelB:Set(parent:Joint3D:itemB:GetAngularVelocity())

        Vector3 angVelAroundHingeAxisA
        number scaleForA = angVelA:DotProduct(axisA)
        angVelAroundHingeAxisA:Set(axisA)
        angVelAroundHingeAxisA:Scale(scaleForA)

        Vector3 angVelAroundHingeAxisB
        number scaleForB = angVelB:DotProduct(axisB)
        angVelAroundHingeAxisB:Set(axisB)
        angVelAroundHingeAxisB:Scale(scaleForB)
        

        Vector3 angAorthog
        angAorthog:Set(angVelA)
        angAorthog:Subtract(angVelAroundHingeAxisA)     //angAorthog = angVelA - angVelAroundHingeAxisA

        Vector3 angBorthog
        angBorthog:Set(angVelB)
        angBorthog:Subtract(angVelAroundHingeAxisB)

        Vector3 velRelOrthog
        velRelOrthog:Set(angAorthog)
        velRelOrthog:Subtract(angBorthog)


        //correct the orthogonal angular velocity
        number relaxation = 1
        number len = velRelOrthog:Length()

        if (len > 0.00001)
            Vector3 normal
            normal:Set(velRelOrthog:Normalize())

            number denom  = parent:Joint3D:itemA:ComputeAngularImpulseDenominator(normal) + parent:Joint3D:itemB:ComputeAngularImpulseDenominator(normal)

            velRelOrthog:Scale(1.0/denom * relaxationFactor)
        end

        // solve angular positional correction
        Vector3 angularError
        angularError:Set(axisA:CrossProduct(axisB))
        angularError:MakeOpposite()  //TODO: check
        angularError:Scale(1.0/timeStep)

        number len2 = angularError:Length()

        if (len2 > 0.00001)
            Vector3 normal2
            normal2:Set(angularError)
            normal2:Normalize()

            number denom2  = parent:Joint3D:itemA:ComputeAngularImpulseDenominator(normal2) + parent:Joint3D:itemB:ComputeAngularImpulseDenominator(normal2)
            angularError:Scale(1.0/denom2 * relaxation)   //relaxation instead of relaxationFactor
        end


        temp:Set(velRelOrthog)
        temp:MakeOpposite()
        temp:Add(angularError)
        parent:Joint3D:itemA:ApplyTorqueImpulse(temp)

        temp:Set(velRelOrthog)
        temp:Subtract(angularError)
        parent:Joint3D:itemB:ApplyTorqueImpulse(temp)




        if (solveLimit)
            temp:Set(angVelB)
            temp:Subtract(angVelA)
            
            number amplitude = (temp:DotProduct(axisA) * relaxationFactor + correction * (1.0/timeStep) * biasFactor) * limitSign
            number impulseMag = amplitude * kHinge

            number tempNum = accLimitImpulse
            accLimitImpulse = math:MaximumOf(accLimitImpulse + impulseMag, 0)

            impulseMag = accLimitImpulse - tempNum

            Vector3 impulse
            impulse:Set(axisA)
            impulse:Scale(impulseMag * limitSign)

            parent:Joint3D:itemA:ApplyTorqueImpulse(impulse)

            impulse:MakeOpposite()
            parent:Joint3D:itemB:ApplyTorqueImpulse(impulse)
        end //end if

        if (enableAngularMotor)
            Vector3 angularLimit
            angularLimit:Set(0,0,0)

            Vector3 velrel
            velrel:Set(angVelAroundHingeAxisA)
            velrel:Subtract(angVelAroundHingeAxisB)
            number projRelVel = velrel:DotProduct(axisA)
            
            number desiredMotorVel = motorTargetVelocity
            number motor_relvel = desiredMotorVel - projRelVel

            number unclippedMotorImpulse = kHinge * motor_relvel

            number clippedMotorImpulse = 0
            if (unclippedMotorImpulse > maxMotorImpulse)
                clippedMotorImpulse = maxMotorImpulse
            else
                clippedMotorImpulse = unclippedMotorImpulse
            end

            if (clippedMotorImpulse < -maxMotorImpulse)
                clippedMotorImpulse = -maxMotorImpulse
            else
                clippedMotorImpulse = clippedMotorImpulse
            end

            Vector3 motorImp
            motorImp:Set(axisA)
            motorImp:Scale(clippedMotorImpulse)

            temp:Set(motorImp)
            temp:Add(angularLimit)
            parent:Joint3D:itemA:ApplyTorqueImpulse(temp)

            temp:MakeOpposite()
            temp:Subtract(angularLimit)
            parent:Joint3D:itemB:ApplyTorqueImpulse(temp)
        end
    end

    action updateRHS(number timeStep) 
    end  
    


    action GetHingeAngle returns number
        PhysicsPosition3D centerOfMassA
        PhysicsPosition3D centerOfMassB
        centerOfMassA:Set(parent:Joint3D:itemA:GetCenterOfMassTransform())
        centerOfMassB:Set(parent:Joint3D:itemB:GetCenterOfMassTransform())

        Vector3 refAxis0
        refAxis0:Set(frameInA:GetBasis():GetColumn(0))
        centerOfMassA:GetBasis():Transform(refAxis0)
        

        Vector3 refAxis1
        refAxis1:Set(frameInA:GetBasis():GetColumn(1))
        centerOfMassA:GetBasis():Transform(refAxis1)

        Vector3 swingAxis
        swingAxis:Set(frameInB:GetBasis():GetColumn(1))
        centerOfMassB:GetBasis():Transform(swingAxis)

        return atan2Fast(swingAxis:DotProduct(refAxis0), swingAxis:DotProduct(refAxis1))
    end

    private action atan2Fast(number y, number x) returns number
        number coeff_1 = math:pi/4.0
        number coeff_2 = 3.0*coeff_1

        number abs_y = math:AbsoluteValue(y)

        number angle = 0

        if (x >= 0.0)
            number r = (x - abs_y )/(x+abs_y)
            angle = coeff_1 - coeff_1 * r
        else
            number r = (x + abs_y) / (abs_y - x)
            angle = coeff_2 - coeff_1 * r
        end

        if (y < 0.0)
            return -angle
        else 
            return angle
        end
    end


    action SetAngularOnly(boolean angularOnly)
        me:angularOnly = angularOnly
    end


    action EnableAngularMotor(boolean enableMotor, number targetVelocity, number maxMotorImpulse)
        me:enableAngularMotor = enableMotor
        me:motorTargetVelocity = targetVelocity
        me:maxMotorImpulse = maxMotorImpulse
    end

    

    action SetLimit(number low, number high)
        SetLimit(low, high, 0.9, 0.3, 1.0)
    end


    action SetLimit(number low, number high, number softness, number bias, number relaxation)
        lowerLimit = low
        upperLimit = high   
        limitSoftness = softness
        biasFactor = bias
        relaxationFactor = relaxation   
    end

    action GetLowerLimit returns number
        return lowerLimit
    end


    action GetUpperLimit returns number 
        return upperLimit
    end


    action GetAFrame(PhysicsPosition3D outputFrame) returns PhysicsPosition3D
        outputFrame:Set(frameInA)
        return outputFrame
    end


    action GetBFrame(PhysicsPosition3D outputFrame) returns PhysicsPosition3D
        outputFrame:Set(frameInB)
        return outputFrame
    end


    action GetSolveLimit returns boolean
        return solveLimit
    end


    action GetLimitSign returns number
        return limitSign
    end


    action GetAngularOnly returns boolean
        return angularOnly
    end


    action GetEnableAngularMotor returns boolean
        return enableAngularMotor
    end


    action GetMotorTargetVelocity returns number 
        return motorTargetVelocity
    end


    action GetMaxMotorImpulse returns number
        return maxMotorImpulse
    end
end