package Libraries.Game.Physics

use Libraries.Compute.Vector3
use Libraries.Compute.Matrix3
use Libraries.Game.Physics.all

class ConstraintDescription3D 
    Vector3 linearJointAxis
    Vector3 aJ
    Vector3 bJ
    Vector3 minvJt0
    Vector3 minvJt1
    number diag = 0
    
    action Initialize(Matrix3 world2A, Matrix3 world2B, Vector3 relativePosition1, 
                      Vector3 relativePosition2, Vector3 jointAxis, Vector3 inertiaInverseA,
                      number massInverseA, Vector3 inertiaInverseB, number massInverseB)
        linearJointAxis:Set(jointAxis)
        
        aJ:Set(relativePosition1):CrossProduct(linearJointAxis)
        world2A:Transform(aJ)
         
        bJ:Set(linearJointAxis)
        bJ:Scale(-1)
        Vector3 temp
        temp:Set(relativePosition2):CrossProduct(bJ)
        bJ:Set(temp)
        world2B:Transform(bJ)

        minvJt0:Set(inertiaInverseA)
        minvJt0:SetX(minvJt0:GetX() * aJ:GetX())
        minvJt0:SetY(minvJt0:GetY() * aJ:GetY())
        minvJt0:SetZ(minvJt0:GetZ() * aJ:GetZ())
        minvJt1:Set(inertiaInverseB)
        minvJt1:SetX(minvJt1:GetX() * bJ:GetX())
        minvJt1:SetY(minvJt1:GetY() * bJ:GetY())
        minvJt1:SetZ(minvJt1:GetZ() * bJ:GetZ())
        diag = massInverseA + minvJt0:DotProduct(aJ) + massInverseB + minvJt1:DotProduct(bJ)
    end

    action Initialize(Vector3 jointAxis, Matrix3 world2A, Matrix3 world2B, Vector3 inertiaInverseA, Vector3 inertiaInverseB)
        linearJointAxis:Set(0, 0, 0)
        
        aJ:Set(jointAxis)
        world2A:Transform(aJ)

        bJ:Set(jointAxis)
        bJ:Scale(-1)
        world2B:Transform(bJ)

        minvJt0:Set(inertiaInverseA)
        minvJt0:SetX(minvJt0:GetX() * aJ:GetX())
        minvJt0:SetY(minvJt0:GetY() * aJ:GetY())
        minvJt0:SetZ(minvJt0:GetZ() * aJ:GetZ())
        minvJt1:Set(inertiaInverseB)
        minvJt1:SetX(minvJt1:GetX() * bJ:GetX())
        minvJt1:SetY(minvJt1:GetY() * bJ:GetY())
        minvJt1:SetZ(minvJt1:GetZ() * bJ:GetZ())
        diag = minvJt0:DotProduct(aJ) + minvJt1:DotProduct(bJ)
    end

    action Initialize(Vector3 axisInA, Vector3 axisInB, Vector3 inertiaInverseA, Vector3 inertiaInverseB)
        linearJointAxis:Set(0, 0, 0)
        aJ:Set(axisInA)

        bJ:Set(axisInB)
        bJ:Scale(-1)

        minvJt0:Set(inertiaInverseA)
        minvJt0:SetX(minvJt0:GetX() * aJ:GetX())
        minvJt0:SetY(minvJt0:GetY() * aJ:GetY())
        minvJt0:SetZ(minvJt0:GetZ() * aJ:GetZ())
        minvJt1:Set(inertiaInverseB)
        minvJt1:SetX(minvJt1:GetX() * bJ:GetX())
        minvJt1:SetY(minvJt1:GetY() * bJ:GetY())
        minvJt1:SetZ(minvJt1:GetZ() * bJ:GetZ())
        diag = minvJt0:DotProduct(aJ) + minvJt1:DotProduct(bJ)
    end

    action Initialize(Matrix3 world2A, Vector3 relativePosition1, Vector3 relativePosition2,
                      Vector3 jointAxis, Vector3 inertiaInverseA, number massInverseA)
        linearJointAxis:Set(jointAxis)

        aJ:Set(relativePosition1):CrossProduct(jointAxis)
        world2A:Transform(aJ)

        bJ:Set(jointAxis)
        bJ:Scale(-1)
        Vector3 temp
        temp:Set(relativePosition2):CrossProduct(bJ)
        bJ:Set(temp)
        world2A:Transform(bJ)

        minvJt0:Set(inertiaInverseA)
        minvJt0:SetX(minvJt0:GetX() * aJ:GetX())
        minvJt0:SetY(minvJt0:GetY() * aJ:GetY())
        minvJt0:SetZ(minvJt0:GetZ() * aJ:GetZ())     
        minvJt1:Set(0, 0, 0)
        diag = massInverseA + minvJt0:DotProduct(aJ)
    end

    action GetDiagonal returns number
        return diag
    end

    action GetNonDiagonal(ConstraintDescription3D descriptionB, number massInverseA) returns number
        ConstraintDescription3D jacA = me
        number lin = massInverseA * jacA:linearJointAxis:DotProduct(descriptionB:linearJointAxis)
        number ang = jacA:minvJt0:DotProduct(descriptionB:aJ)
        return lin + ang
    end

    action GetNonDiagonal(ConstraintDescription3D descriptionB, number massInverseA, number massInverseB) returns number
        ConstraintDescription3D jacA = me

        Vector3 lin
        lin:Set(jacA:linearJointAxis)
        lin:SetX(lin:GetX() * descriptionB:linearJointAxis:GetX())
        lin:SetY(lin:GetY() * descriptionB:linearJointAxis:GetY())
        lin:SetZ(lin:GetZ() * descriptionB:linearJointAxis:GetZ())

        Vector3 ang0
        ang0:Set(jacA:minvJt0)
        ang0:SetX(ang0:GetX() * descriptionB:aJ:GetX())
        ang0:SetY(ang0:GetY() * descriptionB:aJ:GetY())
        ang0:SetZ(ang0:GetZ() * descriptionB:aJ:GetZ())

        Vector3 ang1
        ang1:Set(jacA:minvJt1)
        ang1:SetX(ang1:GetX() * descriptionB:bJ:GetX())
        ang1:SetY(ang1:GetY() * descriptionB:bJ:GetY())
        ang1:SetZ(ang1:GetZ() * descriptionB:bJ:GetZ())

        Vector3 lin0
        lin0:Set(lin):Scale(massInverseA)

        Vector3 lin1
        lin1:Set(lin):Scale(massInverseB)

        Vector3 sum
        sum:Set(ang0):Add(ang1):Add(lin0):Add(lin1)

        return sum:GetX() + sum:GetY() + sum:GetZ()        
    end

    action GetRelativeVelocity(Vector3 linearVelocityA, Vector3 angularVelocityA, Vector3 linearVelocityB, Vector3 angularVelocityB) returns number
        Vector3 linrel
        linrel:Set(linearVelocityA):Subtract(linearVelocityB)

        Vector3 angvela
        angvela:Set(angularVelocityA)
        angvela:SetX(angvela:GetX() * aJ:GetX())
        angvela:SetY(angvela:GetY() * aJ:GetY())
        angvela:SetZ(angvela:GetZ() * aJ:GetZ())

        Vector3 angvelb
        angvelb:Set(angularVelocityB)
        angvelb:SetX(angvelb:GetX() * bJ:GetX())
        angvelb:SetY(angvelb:GetY() * bJ:GetY())
        angvelb:SetZ(angvelb:GetZ() * bJ:GetZ())

        linrel:SetX(linrel:GetX() * linearJointAxis:GetX())
        linrel:SetY(linrel:GetY() * linearJointAxis:GetY())
        linrel:SetZ(linrel:GetZ() * linearJointAxis:GetZ())

        angvela:Add(angvelb)
        angvela:Add(linrel)

        number rel_vel2 = angvela:GetX() + angvela:GetY() + angvela:GetZ()
        return rel_vel2 + 0.000000119209290
    end
end