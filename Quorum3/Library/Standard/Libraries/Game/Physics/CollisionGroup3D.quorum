package Libraries.Game.Physics

use Libraries.Containers.Array
use Libraries.Compute.Vector3
use Libraries.Interface.Events.CollisionListener3D
use Libraries.Interface.Item3D
use Libraries.Interface.Events.CollisionEvent3D
use Libraries.Game.Physics.CollisionSolver3D
use Libraries.Compute.Math
use Libraries.Game.Physics.Joints.Joint3D
use Libraries.Game.Collision.LocalCollisionPoints3D
use Libraries.Game.Physics.all

class CollisionGroup3D 
    Array<Item3D> items
    Array<CollisionEvent3D> collisions
    Array<Joint3D> joints

    Array<Vector3> positions
    Array<Vector3> angles
    Array<Vector3> linearVelocities
    Array<Vector3> angularVelocities

    integer itemCount = 0
    integer jointCount = 0
    integer collisionCount = 0

    Math math

    CollisionSolver3D collisionSolver
    CollisionSolverInformation3D solverInfo

    number sleepThreshold = 0.001

    action Empty
        itemCount = 0
        items:Empty()
        collisionCount = 0
        collisions:Empty()
        jointCount = 0
        positions:Empty()
        angles:Empty()
        linearVelocities:Empty()
        angularVelocities:Empty()
    end

    action Add(Item3D item)
        items:Add(item)
        item:SetCollisionGroupIndex(itemCount)
        itemCount = itemCount + 1
        end

    action Add(CollisionEvent3D collision)
        collisions:Add(collision)
        collisionCount = collisionCount + 1
    end

    action Add(Joint3D joint)
        joints:Add(joint)
        jointCount = jointCount + 1
    end

    action GetItemCount returns integer
        return itemCount
    end

    action GetCollisionCount returns integer
        return collisionCount
    end

    action GetJointCount returns integer
        return jointCount
    end

    action GetItem(integer index) returns Item3D
        return items:Get(index)
    end

    action GetCollision(integer index) returns CollisionEvent3D
        return collisions:Get(index)
    end

    action GetJoint(integer index) returns Joint3D
        return joints:Get(index)
    end

    action SetSolverInformation(CollisionSolverInformation3D solverInformation)
        me:solverInfo = solverInformation
    end

    action Solve(number seconds, boolean requireSimulation)
        Array<LocalCollisionPoints3D> manifolds
        integer manifoldCount = 0
        integer i = 0
        repeat while i < collisions:GetSize()
            LocalCollisionPoints3D manifold = collisions:Get(i):GetCollisionPoints()
            manifolds:Add(manifold)
            i = i + 1
        end
        collisionSolver:SolveGroup(items, itemCount, manifolds, 0, manifoldCount, joints, 0, jointCount, solverInfo)

        if not requireSimulation
//            number h = solverInfo:GetTimeStep()
//            number timeToSleep = 0.5
//            number minSleepTime = timeToSleep:GetMaximumValue()
//
//            number linearToleranceSquared = sleepThreshold * sleepThreshold
//            number angularToleranceSquared = (2 / 180.0 * math:pi) * (2 / 180.0 * math:pi)
//
//            i = 0
//            repeat while i < itemCount
//                Item3D body = items:Get(i)
//                if body:GetResponsiveness() not= body:GetPhysicsProperties():UNMOVABLE
//                    if body:IsSimulationRequired()
//                        or body:GetLinearVelocity():GetX() * body:GetLinearVelocity():GetX() + body:GetLinearVelocity():GetY() * body:GetLinearVelocity():GetY() + body:GetLinearVelocity():GetZ() * body:GetLinearVelocity():GetZ() > linearToleranceSquared
//                            body:SetSleepTime(0)
//                            minSleepTime = 0
//                    else
//                        body:SetSleepTime(body:GetSleepTime() + h)
//                        if minSleepTime > body:GetSleepTime()
//                            minSleepTime = body:GetSleepTime()
//                        end
//                    end
//                end
//
//                i = i + 1
//            end
//
//            if minSleepTime >= timeToSleep
//                i = 0
//                repeat while i < itemCount
//                    Item3D body = items:Get(i)
//                    body:Simulate(false)
//
//                    i = i + 1
//                end
//            end
        end
    end
end