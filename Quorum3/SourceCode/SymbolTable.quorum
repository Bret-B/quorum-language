package Libraries.Language.Compile.Symbol

use Libraries.Language.Compile.CompilerError
use Libraries.Containers.HashTable
use Libraries.Language.Compile.Location
use Libraries.System.File
use Libraries.Containers.Array
use Libraries.Containers.Blueprints.Iterator

class SymbolTable 
    HashTable<text, Source> files
    HashTable<text, Class> classes
    HashTable<text, HashTable<text, Class>> packages

    action Add(Class clazz) returns CompilerError
        if classes:HasKey(clazz:GetStaticKey())
            CompilerError error
            error:SetLineNumber(clazz:GetLineNumber())
            error:SetFile(clazz:GetFile())
            error:SetErrorMessage("Class " + clazz:GetStaticKey() + " is already defined.")
            return error
        end //otherwise just add it
        classes:Add(clazz:GetStaticKey(), clazz)

        File file = clazz:GetFile()
        text path = file:GetAbsolutePath()
        if files:HasKey(path)
            Source source = files:GetValue(path)
            source:Add(clazz)
        else 
            Source source
            source:Add(clazz)
            source:SetFile(file)
            files:Add(source:GetStaticKey(), source)
        end

        text pack = clazz:GetPackageKey()
        if not packages:HasKey(pack) //create one
            HashTable<text, Class> p
            packages:Add(pack, p)
        end
        
        HashTable<text, Class> thePackage = packages:GetValue(pack)
        thePackage:Add(clazz:GetName(), clazz)
        return undefined
    end

    action GetClasses returns Iterator<Class>
        return classes:GetValueIterator()
    end

    action GetClassInPackage(text packageKey, text name) returns Class
        HashTable<text, Class> pack = packages:GetValue(packageKey)
        if pack = undefined
            return undefined
        end

        Class clazz = pack:GetValue(name)
        return clazz
    end

    action GetSubpackageNames(text parentPackage) returns Iterator<text>
        Iterator<text> it = packages:GetKeyIterator()
        Array<text> subpacks
        repeat while it:HasNext()
            text pack = it:Next()
            if pack:StartsWith(parentPackage + ".")
                //now split the pack
                Array<text> splitChild = pack:Split("\.")
                Array<text> splitParent = parentPackage:Split("\.")
                if splitChild:GetSize() = splitParent:GetSize() + 1
                    subpacks:Add(pack)
                end
            end
        end

        return subpacks:GetIterator()
    end

    /*
        Returns all classes in a particular package.
    */
    action GetClassesInPackage(text packageKey) returns Iterator<Class>
        HashTable<text, Class> pack = packages:GetValue(packageKey)
        if pack = undefined
            return undefined
        end

        return pack:GetValueIterator()
    end

    /*
        This action returns an array of classes in a particular subpackage
        sorted by their static keys.
    */
    action GetClassesSortedInPackage(text packageKey) returns Array<Class>
        HashTable<text, Class> pack = packages:GetValue(packageKey)
        if pack = undefined
            return undefined
        end
        Array<Class> sorted
        Iterator<Class> cl = pack:GetValueIterator()
        repeat while cl:HasNext()
            Class next = cl:Next()
            sorted:Add(next)
        end
        sorted:Sort()
        return sorted
    end

    /*
        Returns an iterator of all loaded packages.
    */
    action GetPackages returns Iterator<text>
        return packages:GetKeyIterator()
    end

    action GetPackagesSorted returns Array<text>
        Iterator<text> keys = packages:GetKeyIterator()
        Array<text> result
        repeat while keys:HasNext()
            text key = keys:Next()
            result:Add(key)
        end
        result:Sort()
        
        return result
    end 

    action GetPackagesSortedIterator returns Iterator<text>
        Iterator<text> keys = packages:GetKeyIterator()
        Array<text> result
        repeat while keys:HasNext()
            text key = keys:Next()
            result:Add(key)
        end
        result:Sort()
        
        return result:GetIterator()
    end 

    /*
        Returns a class with the corresponding unique static key.
    */
    action GetClass(text key) returns Class
        return classes:GetValue(key)
    end

    /*
        Returns whether or not a class exists in the symbol table. The key
        passed must be the full static key (i.e., Libraries.Language.Object, not Object).
    */
    action HasClass(text key) returns boolean
        return classes:HasKey(key)
    end

    /*
        Returns whether or not the symbol table has a file
    */
    action HasFile(text absolutePath) returns boolean
        return files:HasKey(absolutePath)
    end

    /*
        Removes a file, and any associated classes, from the system.
    */
    action RemoveFile(text absolutePath)
        Class inFile = GetClassInFile(absolutePath)
        if inFile not= undefined
            RemoveClass(inFile:GetStaticKey())
        end
    end

    /*
        Removes a class with a static key from the symbol table.
    */
    action RemoveClass(text key)
        if classes:HasKey(key)
            Class current = classes:GetValue(key)
            classes:RemoveKey(key)

            File f = current:GetFile()
            if f not= undefined
                text path = f:GetAbsolutePath()
                files:RemoveKey(path)
            end
            
            text packageName = current:GetPackageKey()
            HashTable<text, Class> classesInPackage = packages:GetValue(packageName)
            if classesInPackage not= undefined
                if classesInPackage:HasKey(current:GetName())
                    classesInPackage:RemoveKey(current:GetName())
                end
            end

        end
    end

    /*
        This action returns the first class in the file
        with the designated key.
    */
    action GetClassInFile(text fileKey) returns Class
        Source source = files:GetValue(fileKey)
        if source not= undefined
            return source:GetFirstClass()
        end

        return undefined
    end
end