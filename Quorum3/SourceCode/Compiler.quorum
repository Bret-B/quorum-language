package Libraries.Language.Compile

use Libraries.System.File
use Libraries.Language.Compile.Symbol.all
use Libraries.Containers.HashTable
use Libraries.Containers.Array
use Libraries.Containers.Blueprints.Iterator
use Libraries.Language.Compile.Translate.JarGenerator
use Libraries.Containers.List
use Libraries.Language.Compile.Translate.ClassOpcode
use Libraries.System.DateTime

class Compiler
    public constant number VERSION = 3.0
    File main = undefined
    File outputFolder = undefined
    File pluginFolder = undefined
    File dependencyFolder = undefined
    constant text DEFAULT_BUILD_FOLDER = "Build"
    constant text DEFAULT_RUN_FOLDER = "Run"
    constant text DEFAULT_STANDARD_LIBRARY_FOLDER = "Library/Standard"
    constant text WAR_CLASS_DIRECTORY = "WEB-INF/classes"
    constant text OBJECT = "Libraries.Language.Object"
    constant text JAR_DEPENDENCY_FOLDER = "libraries"
    File buildFolder = undefined
    File runFolder = undefined
    File standardLibraryFolder = undefined
    HashTable<text, Dependency> dependencies
    boolean isWebApplication = false
    text name = "Default"
    text convertedJavaScript = ""
    //Support classes
    SymbolTable symbolTable
    CompilerErrorManager compilerErrorManager
    TypeChecker checker


    //Sandbox classes for the parser
    SymbolTable sandboxSymbolTable
    CompilerErrorManager sandboxCompilerErrorManager
    TypeChecker sandboxTypeChecker
    public constant integer JAVA_BYTECODE = 0
    public constant integer JAVASCRIPT = 1
    integer currentOutputType = 0
    boolean outputSpeechCommands = true
    boolean containsSpeechCommandInCompile = false
    CompilerProfiler profiler
    Array<File> additionalPluginFolders
    Array<File> additionalJarFiles
    boolean hasBeenCompiled = false
    constant text USE = "use"
    constant text PACKAGE = "package"

    action HasSpeechCallInCompile returns boolean
        return containsSpeechCommandInCompile
    end

    /*
        This action clears out any existing information in the compiler. By
        default it removes only parse information, but does not alter
        any parameters (e.g., project directory).
    */
    action Empty
        SymbolTable symbolTable2
        CompilerErrorManager compilerErrorManager2
        TypeChecker checker2
        CompilerProfiler profiler2

        symbolTable = symbolTable2
        compilerErrorManager = compilerErrorManager2
        checker = checker2
        checker:SetSymbolTable(symbolTable)
        profiler = profiler2
    end

    action SetOutputSpeech(boolean doSay)
        outputSpeechCommands = doSay
    end

    action GetOutputSpeech returns boolean
        return outputSpeechCommands
    end

    action LoadDependency(text from, text to)
        Dependency dep
        dep:from = from
        dep:to = to
        dependencies:Add(from, dep)
    end

    /* This action sets what kind of output the compiler is going to have. By default
       this returns Java bytecode.
    */
    action GetOutputType returns integer
        return currentOutputType
    end

    /*
        This action tells the compiler what kind of output to emit.
    */
    action SetOutputType(integer type)
        if type >= JAVA_BYTECODE and type <= JAVASCRIPT
            currentOutputType = type
        else
            currentOutputType = 0
        end
    end

    action GetDependencies returns Iterator<Dependency>
        return dependencies:GetValueIterator()
    end

    /*
        This action calls the parsing commands regularly, for example from
        within in an IDE, in a specialized way. Specifically, it first tries
        to parse the text passed in. The single file passed in is the file
        to be parsed, usually stored in memory (not disk). The file location
        of this text is the location on disk, but its current contents may
        not be written, so this should be used as a key, not a store.
    */
    action ParseRepeat(ProjectInformation information) returns CompilerResult
        CompilerProfiler sandboxedProfiler
        CompilerResult result
        result:compilerErrorManager = sandboxCompilerErrorManager
        sandboxCompilerErrorManager:Empty()
        result:symbolTable = sandboxSymbolTable
        sandboxTypeChecker:SetSymbolTable(sandboxSymbolTable)
        DateTime time
        start = time:GetEpochTime()
        sandboxedProfiler:Add(time:GetEpochTime())

        text source = information:source
        File loc = information:sourceLocation
        text locPath = loc:GetAbsolutePath()

        //Check if this class is already in there. If so, remove it
        Class inFile = sandboxSymbolTable:GetClassInFile(locPath)
        if inFile not= undefined
            sandboxSymbolTable:RemoveClass(inFile:GetStaticKey())
        end
        
        Array<File> files = information:projectFiles

        boolean isInvalidCompile = false
        if files = undefined
            isInvalidCompile = true
        elseif files:IsEmpty()
            isInvalidCompile = true
        end

        if isInvalidCompile
            CompilerError error
            text message = ""
            if files = undefined
                message = "I cannot compile an array of files that is passed to me undefined"
            elseif files:IsEmpty()
                message = "I cannot compile an arry of files that is empty. Please specify which files you would like compiled."
            end
            error:SetErrorMessage(message)
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_FILE)
            error:SetCompilerErrorType(t)
            error:SetLineNumber(1)
            error:SetLineNumberEnd(1)
            error:SetColumnNumber(1)
            error:SetColumnNumberEnd(1)
            compilerErrorManager:Add(error)
            return result
        end

        text null = undefined

        if inFile = undefined
            i = 0
            repeat while i < files:GetSize()
                File file = files:Get(i)
                Parser listener
                if file:GetAbsolutePath() = locPath
                    ParseSandbox(source, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
                else 
                    ParseSandbox(null, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
                end
                i = i + 1
            end
        else
            Parser listener
            ParseSandbox(source, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, loc)
        end
        sandboxedProfiler:Add(time:GetEpochTime())

        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = undefined
        if compilerErrorManager:IsCompilationErrorFree()
            allFiles = GetAllRequiredFiles(sandboxSymbolTable, sandboxTypeChecker, sandboxCompilerErrorManager)
        else 
            return result
        end
        sandboxedProfiler:Add(time:GetEpochTime())

        if compilerErrorManager:IsCompilationErrorFree()
            if inFile = undefined
                TypeResolution(sandboxSymbolTable, sandboxTypeChecker, sandboxCompilerErrorManager)
            else
                Class newParse = sandboxSymbolTable:GetClassInFile(locPath)
                if newParse not= undefined
                    newParse:ResolveUseStatements(sandboxSymbolTable, sandboxCompilerErrorManager)
                    newParse:ResolveAllTypes(sandboxSymbolTable, sandboxCompilerErrorManager)
                    newParse:ComputeVirtualActionTable(sandboxCompilerErrorManager)
                    newParse:ComputeGenericsTables(sandboxCompilerErrorManager)
                    sandboxTypeChecker:Add(newParse)
                end
            end
        else 
            return result
        end
        sandboxedProfiler:Add(time:GetEpochTime())

        Array<ClassOpcode> classOpcodes
        if compilerErrorManager:IsCompilationErrorFree()
            if inFile = undefined
                i = 0
                repeat while i < allFiles:GetSize()
                    File file = allFiles:Get(i)
                    QuorumBytecodeListener listener

                    if file:GetAbsolutePath() = locPath
                        ParseSandbox(source, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
                    else 
                        ParseSandbox(null, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
                    end
                    i = i + 1
                end
            else
                QuorumBytecodeListener listener
                ParseSandbox(source, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, loc)
            end
        else 
            return result
        end
        sandboxedProfiler:Add(time:GetEpochTime()) 
        
        DateTime time2
        finish = time2:GetEpochTime()
        total = (finish - start) / 1000.0
        result:time = total
        return result
    end

    private action ParseSandbox(text source, QuorumSourceListener listener, SymbolTable table, CompilerErrorManager errors,
        TypeChecker types, File loc)
        listener:SetSymbolTable(table)
        listener:SetCompilerErrorManager(errors)
        listener:SetTypeChecker(types)
        listener:SetFile(loc)

        if not (source = undefined)
            ParseNative(source, listener)
        else 
            ParseNative(loc, listener)
        end
        
    end
    
    action Request(CodeCompletionRequest request) returns CodeCompletionResult
        CodeCompletionResult result

        text source = request:source
        integer index = request:caretLocation
        text line = GetLineBeforeCursor(index, source)
        result:prefix = line
        text trimmed = line:Trim()
        request:line = trimmed
//
//        text sub = line:GetSubtext(0, request:startOffset - 1)
//        boolean isDot = false
//
//        if sub:GetSize() > 0
//            text index = sub:GetCharacter(sub:GetSize() - 1)
//            if index = "."
//                isDot = true
//            end
//        end
//        
        boolean isUse = trimmed:StartsWith("use")
        boolean isPackage = trimmed:StartsWith("package")

        if isUse
            AddUseResults(request, result, true)
        elseif not isUse and isPackage
            AddUseResults(request, result, false)
        end

        return result
    end

    private action GetLineBeforeCursor(integer loc, text source) returns text
        if loc - 1 <= source:GetSize()
            integer i = loc - 1
            text CR = source:GetLineFeed()

            integer start = 0
            repeat while i >=0 
                text ch = source:GetCharacter(i)
                if ch = CR //this is the end of the line
                    start = i
                    i = -1
                end
                i = i - 1
            end

            text sub = source:GetSubtext(start, loc)
            return sub
        end

        return undefined
    end

    private action AddCustomClasses(CodeCompletionRequest request, CodeCompletionResult result, text pack)
        Iterator<Class> classes = sandboxSymbolTable:GetClassesInPackage(pack)

        if classes not= undefined
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                CodeCompletionItem item = GetClassCompletionItem(clazz)
                result:Add(item)
            end
        end
    end

    private action GetClassCompletionItem(Class clazz) returns CodeCompletionItem
        CodeCompletionItem item
        item:SetType(item:CLASS)

        text signature = clazz:GetStaticKey()
        text name = clazz:GetName()

        text description = ""
        description = description + "<h1>" + signature + "</h1>"
//        String[] paragraphs = Documentation.breakStringIntoParagraphArray(clazz.getDocumentation().getDescription());
//        for (int i = 0; i < paragraphs.length; i++) {
//            description += "<p>" + paragraphs[i] + "</p>";
//        }
//
//        description += "<h2>" + "Code Example:" + "</h2>";
//        description += "<PRE><CODE>" + clazz.getDocumentation().getExample()
//                + "</PRE></CODE>";

        item:displayText = name
        item:completionText = name
        item:documentationText = "Test"
        return item
    end
    
    private action GetPackageCompletionItem(text pack) returns CodeCompletionItem
        CodeCompletionItem item
        item:SetType(item:PACKAGE)

        text signature = pack
        text name = pack

        text description = "<h1>" + signature + "</h1>"

        item:displayText = name
        item:completionText = name
        item:documentationText = ""
        return item
    end

    private action AddSubpackagesAndClasses(CodeCompletionRequest request, CodeCompletionResult result, text name)
        //first find all of the packages/sub-packages 
        Iterator<text> packs = sandboxSymbolTable:GetSubpackageNames(name)
        repeat while packs:HasNext()
            text pack = packs:Next()
            integer size = name:GetSize() + 1
            text subpackName = pack:GetSubtext(0, size)
            text filteredName = subpackName + result:filter
            subpackName = pack:GetSubtext(size, pack:GetSize())

            if pack:StartsWith(filteredName)
                CodeCompletionItem item = GetPackageCompletionItem(subpackName)
                result:Add(item)
            end
        end

        //next find any classes on the system in the package
        Iterator<Class> classesInPackage = sandboxSymbolTable:GetClassesInPackage(name)
        boolean hasAny = false
        if classesInPackage not= undefined
            hasAny = classesInPackage:HasNext()
            repeat while classesInPackage:HasNext()
                Class pack = classesInPackage:Next()
                text key = pack:GetStaticKey()
                CodeCompletionItem item = GetClassCompletionItem(pack)
                result:Add(item)
            end
        end
        
        //finally, remind the user they can use the "all" keyword
        if hasAny
            CodeCompletionItem item
            item:SetType(item:PACKAGE)
            text DQ = ""
            DQ = DQ:GetDoubleQuote()
            text signature = "Use all classes with the " + DQ + "all" + DQ + " keyword."
            text itemName = "all"

            text description = "<h1>" + signature + "</h1>"
                    + "<p align=" + DQ + "justify" + DQ + ">The word "
                    + "all indicates to quorum that we would like to"
                    + " have access to all classes in the package. For "
                    + "example, the phrase Libraries.Containers.all would indicate "
                    + "that we want to use any class in the Libraries.Containers "
                    + "package."
                    + "</p>"
            description = description + "<h2>" + "Code Example:" + "</h2>"
            description = description + "<PRE><CODE>"
                    + "use Libraries.Containers.all\n\n"
                    + "List&lt;integer&gt; list\n"
                    + "Array&lt;integer&gt; array"
                    + "</PRE></CODE>"

            item:displayText = itemName
            item:documentationText = description
            item:completionText = "all"
            result:Add(item)
        end
    end

    private action ReformPackage(Array<text> packs) returns text
        text result = ""
        integer i = 0
        repeat while i < packs:GetSize()
            text value = packs:Get(i)
            if i = 0
                result = result + value
            else
                result = result + value + "."
            end
            i = i + 1
        end
        return result
    end

    private action AddUseResults(CodeCompletionRequest request, CodeCompletionResult result, boolean isUse)
        text trim = request:line
        trim = trim:Trim()
        if isUse
            trim = trim:GetSubtext(USE:GetSize())
        else
            trim = trim:GetSubtext(PACKAGE:GetSize())
        end

        trim = trim:Trim()
        Array<text> values = trim:Split("\.")

        integer filterSize = 0
        if not values:IsEmpty() and not trim:IsEmpty()
            if trim:GetCharacter(trim:GetSize() - 1) = "."
                result:filter = ""
            else
                result:filter = values:Get(values:GetSize() - 1)
            end

            text filter = result:filter
            filterSize = filter:GetSize()
        end

        constant text root = "Libraries"
        if values:GetSize() = 1
            text left = values:Get(0)
            text leftTrimmed = left:Trim()
            if leftTrimmed:IsEmpty()
                CodeCompletionItem item
                item:SetType(item:PACKAGE)
                item:displayText = root
                item:completionText = root
                result:Add(item)
                AddCustomClasses(request, result, root)
            elseif left = root
                AddSubpackagesAndClasses(request, result, root)
                AddCustomClasses(request, result, root)
            elseif root:StartsWith(left)
                CodeCompletionItem item
                item:SetType(item:PACKAGE)
                item:displayText = root
                item:completionText = root
                result:Add(item)
                AddCustomClasses(request, result, root)
            end
        else 
            text valueNoFilter = trim:GetSubtext(0, trim:GetSize() - filterSize - 1)
            AddSubpackagesAndClasses(request, result, valueNoFilter)
            //AddCustomClasses(request, result, valueNoFilter)
        end

//        final String root = this.standardLibrary.getStandardLibraryRootName();
//        if (split.length == 1) {
//            String left = split[0];
//            if (left.matches("\\s*") || result.getFilter().length() != 0) {
//                CodeCompletionItem item = new CodeCompletionItem();
//                item.setCodeCompletionType(CodeCompletionType.PACKAGE);
//                item.setCompletion(root);
//                item.setDisplayName(root);
//                result.add(item);
//                addCustomClasses(result, request, root);
//
//            } else if (left.equals(root)) {
//                addSubpackagesAndClasses(result, standardLibrary.getStandardLibraryRootName());
//                addCustomClasses(result, request, standardLibrary.getStandardLibraryRootName());
//            }
//        } 

//        if (split.length > 0 && line.length() != 0) {
//            if (line.charAt(line.length() - 1) == '.') {
//                result.setFilter("");
//            } else {
//                result.setFilter(split[split.length - 1]);
//            }
//        }

        a = 5
    end


    private action IsWhiteSpace(text value) returns boolean
        i = 0
        repeat while i < value:GetSize()
            text val = value:GetCharacter(i)

            return true
        end

        return true
    end
    /*
        This action compiles the array of files to Java Bytecode, which
        it writes to disk. By default, it generates a .jar file into the 
        folder named Run and the class files into the folder labeled
        Build.
    */
    action Compile(Array<File> files)
        hasBeenCompiled = true
        DateTime time
        profiler:Empty()
        profiler:Add(time:GetEpochTime())
        boolean isInvalidCompile = false
        checker:SetSymbolTable(symbolTable)
        if files = undefined
            isInvalidCompile = true
        elseif files:IsEmpty()
            isInvalidCompile = true
        end

        if isInvalidCompile
            CompilerError error
            text message = ""
            if files = undefined
                message = "I cannot compile an array of files that is passed to me undefined"
            elseif files:IsEmpty()
                message = "I cannot compile an arry of files that is empty. Please specify which files you would like compiled."
            end
            error:SetErrorMessage(message)
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_FILE)
            error:SetCompilerErrorType(t)
            error:SetLineNumber(1)
            error:SetLineNumberEnd(1)
            error:SetColumnNumber(1)
            error:SetColumnNumberEnd(1)
            compilerErrorManager:Add(error)
            return now
        end

        i = 0
        repeat while i < files:GetSize()
            File file = files:Get(i)
            Parser listener
            Parse(file, listener)
            i = i + 1
        end
        profiler:Add(time:GetEpochTime())

        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = undefined
        if compilerErrorManager:IsCompilationErrorFree()
            allFiles = GetAllRequiredFiles(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end
        profiler:Add(time:GetEpochTime())

        if compilerErrorManager:IsCompilationErrorFree()
            TypeResolution(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end
        profiler:Add(time:GetEpochTime())

        Array<ClassOpcode> classOpcodes
        if compilerErrorManager:IsCompilationErrorFree()
            i = 0
            repeat while i < allFiles:GetSize()
                File file = allFiles:Get(i)
                QuorumBytecodeListener listener
                if not outputSpeechCommands
                    listener:SetOutputSpeech(outputSpeechCommands)
                end

                Parse(file, listener)

                if listener:HasSayStatementInClass()
                    containsSpeechCommandInCompile = true
                end
                ClassOpcode op = listener:GetClassOpcode()
                op:SetBuild(buildFolder)
                classOpcodes:Add(op)
                i = i + 1
            end
        else 
            return now
        end
        profiler:Add(time:GetEpochTime())

        File starter = files:Get(0)
        CheckMain(starter)
        
        //at this point, if the build is compilation free, it 
        //is guaranteed to not have compile errors, as no errors
        //can be issues in the bytecode writing stage.
        //if an error is issued, it is a bug in the compiler and not
        //an intentional design decision.
        if compilerErrorManager:IsCompilationErrorFree()
            if currentOutputType = JAVA_BYTECODE
                
                //open up and begin filling the Jar
                JarGenerator generator
                text manifest = GetManifest(generator)
                File jar = GetDistributionFile()
                generator:SetManifest(manifest)
                generator:Open(jar)

                //iterate over all the class opcodes and write them to disk
                Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()
                    code:Write()

                    File build = code:GetBuildFile()
                    File buildInterface = code:GetBuildInterfaceFile()

                    text key = code:GetStaticKey()
                    if build not= undefined
                        generator:Add(build)
                    end

                    if buildInterface not= undefined
                        generator:Add(buildInterface)
                    end
                end
                profiler:Add(time:GetEpochTime())

                //ok all of the classes are written in the jar. Now fill it up
                //with any dependencies that are necessary.
                WriteDependencies(generator)
                generator:Close()
                profiler:Add(time:GetEpochTime())
                
            elseif currentOutputType = JAVASCRIPT
                text result = ""
                Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()
                    Class clazz = code:GetClass()

                    Class mainClazz = me:GetMainClass()
                    text mainClazzName = mainClazz:GetStaticKey()
                    text clazzName = clazz:GetStaticKey()
                    if clazzName = mainClazzName //keep it simple in the first version.
                        result = result + code:WriteJavaScript()
                    end
                    a = 5
                end
                convertedJavaScript = result
            end
        end
    end

    /*
        This action returns a profiler that has tracked information about 
        each phase of a compile as it goes. 
    */
    action GetCompilerProfiler returns CompilerProfiler
        return profiler
    end

    /*
        This action adds a directory of plugins to be written to the output jar
    */ 
    action AddPluginFolder(File file)
        if file:IsDirectory()
            additionalPluginFolders:Add(file)
        end
    end

    action EmptyAdditionalPluginFolders
        additionalPluginFolders:Empty()
    end

    action EmptyAdditionalJars
        additionalJarFiles:Empty()
    end

    /*
        This action checks if this is a jar file and then adds it as a dependency.
    */
    action AddJar(File file)
        text extension = file:GetFileExtension()
        if extension = "jar"
            additionalJarFiles:Add(file)
        end
    end

    // A convenience class used to write jars to disk.
    private action WriteJarToDisk(File file)
        File copyLocation
        File run = GetRunFolder()
        copyLocation:SetWorkingDirectory(run:GetWorkingDirectory())
        copyLocation:SetPath(run:GetPath() + "/" + JAR_DEPENDENCY_FOLDER + "/")


        if not copyLocation:Exists()
            copyLocation:CreateDirectories()
        end

        copyLocation:SetPath(run:GetPath() + "/" + JAR_DEPENDENCY_FOLDER + "/" + file:GetFileName())
        //check if the jar already exists. If the old file is newer
        //copy it. If not, ignore it.
        if not copyLocation:Exists()
            file:Copy(copyLocation)
        else 
            DateTime original = file:GetLastModifiedDate()
            DateTime copy = copyLocation:GetLastModifiedDate()
            if copyLocation:Exists() and (original:GetEpochTime() > copy:GetEpochTime())
                file:Copy(copyLocation)
            end
        end
    end

    private action WriteDependencies(JarGenerator generator)
        WritePlugins(generator, pluginFolder, pluginFolder)

        if not additionalPluginFolders:IsEmpty()
            Iterator<File> it = additionalPluginFolders:GetIterator()
            repeat while it:HasNext()
                File folder = it:Next()
                WritePlugins(generator, folder, folder)
            end
        end

        //copy any jar files that are dependencies to disk
        if not additionalJarFiles:IsEmpty()
            Iterator<File> jars = additionalJarFiles:GetIterator()
            repeat while jars:HasNext()
                File file = jars:Next()
                WriteJarToDisk(file)
            end
        end
        
        // Booleans added for the game/sound plugins.
        boolean hasGame = symbolTable:HasClass("Libraries.Games.Game")
        boolean hasAudio = symbolTable:HasClass("Libraries.Sound.Audio")

        if hasGame or hasAudio
            File lwjgl
            lwjgl:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/AdditionalJars/")
            lwjgl:SetPath("lwjgl.jar")
            WriteJarToDisk(lwjgl)
        end

        //check the symbol table to see if the user generated any code
        //used in the compiler
        boolean hasCompiler = symbolTable:HasClass("Libraries.Language.Compile.Compiler")
        boolean hasTester = symbolTable:HasClass("Libraries.Language.Compile.Test.CompilerTestSuite")
        boolean hasClassWriter = symbolTable:HasClass("Libraries.Language.Compile.Translate.JavaBytecodeClassWriter")
        boolean hasMethodWriter = symbolTable:HasClass("Libraries.Language.Compile.Translate.JavaBytecodeMethodWriter")
        boolean hasfieldWriter = symbolTable:HasClass("Libraries.Language.Compile.Translate.JavaBytecodeFieldWriter")
        boolean hasLabel = symbolTable:HasClass("Libraries.Language.Compile.Translate.JavaBytecodeLabel")
        boolean hasSpeech = symbolTable:HasClass("Libraries.Sound.Speech")

        if hasCompiler or hasTester or hasClassWriter or hasMethodWriter or hasfieldWriter
            or hasLabel
            File to
            to:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            to:SetPath("org")

            File antlr
            antlr:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            antlr:SetPath("org/antlr")
            WriteCompilerDependency(generator, antlr, to)

            File abego
            abego:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            abego:SetPath("org/abego")
            WriteCompilerDependency(generator, abego, to)

            File objectWeb
            objectWeb:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            objectWeb:SetPath("org/objectweb")
            WriteCompilerDependency(generator, objectWeb, to)
        end

        if hasAudio
            File to
            to:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/sound/")
            to:SetPath("")

            File soundPlugins
            soundPlugins:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/sound")
            soundPlugins:SetPath("plugins")
            WriteCompilerDependency(generator, soundPlugins, to)
        end

        // If statement added for the game engine.
        if hasGame
            /*  From what I can tell, WriteCompilerDependency only uses the
                working directory of to, so setting the path is unnecessary. */
            File to
            to:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/games/")
            to:SetPath("")

            File gamePlugins
            gamePlugins:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/games/")
            gamePlugins:SetPath("plugins")
            WriteCompilerDependency(generator, gamePlugins, to)
        end

        if hasAudio or hasGame
            File gameNative
            gameNative:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Native/")
            gameNative:SetPath("Libraries.Games")

            File nativeCopy
            File run = GetRunFolder()
            nativeCopy:SetWorkingDirectory(run:GetAbsolutePath())
            nativeCopy:SetPath("jni")

            if not nativeCopy:Exists()
                nativeCopy:CreateDirectories()
            end
            
            //get all the files in this folder and copy them over
            Array<File> files = gameNative:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()
            repeat while it:HasNext()
                File file = it:Next()
                if not file:IsHidden()

                    File next
                    next:SetWorkingDirectory(nativeCopy:GetAbsolutePath() + "/")
                    next:SetPath(file:GetPath())
                    if file:IsFile()
                        DateTime fileTime = file:GetLastModifiedDate()//1.424560750484E12
                        DateTime nextTime = next:GetLastModifiedDate()//1.424560741363E12

                        //if it doesn't exist, copy the file
                        if not next:Exists()
                            file:Copy(next)
                        else
                            //if it does exist
                            if fileTime:GetEpochTime() > nextTime:GetEpochTime()
                                file:Copy(next)
                            end
                        end
                    end

                    if file:IsDirectory()
                        recursiveCopyDirectory(file, next)
                    end
                end
            end
        end

        if hasSpeech or HasSpeechCallInCompile()
            File to
            to:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            to:SetPath("org")

            File sapi
            sapi:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            sapi:SetPath("org/sapi")
            WriteCompilerDependency(generator, sapi, to)

            File speech
            speech:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            speech:SetPath("org/sodbeans")
            WriteCompilerDependency(generator, speech, to)

            File speechNative
            speechNative:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Native/")
            speechNative:SetPath("Libraries.Sound.Speech")

            //copy this to the distribution directory
            File nativeCopy
            File run = GetRunFolder()
            nativeCopy:SetWorkingDirectory(run:GetAbsolutePath())
            nativeCopy:SetPath("jni")

            if not nativeCopy:Exists()
                nativeCopy:CreateDirectories()
            end
            
            //get all the files in this folder and copy them over
            Array<File> files = speechNative:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()
            repeat while it:HasNext()
                File file = it:Next()
                if not file:IsHidden()

                    File next
                    next:SetWorkingDirectory(nativeCopy:GetAbsolutePath() + "/")
                    next:SetPath(file:GetPath())
                    if file:IsFile()
                        DateTime fileTime = file:GetLastModifiedDate()//1.424560750484E12
                        DateTime nextTime = next:GetLastModifiedDate()//1.424560741363E12

                        //if it doesn't exist, copy the file
                        if not next:Exists()
                            file:Copy(next)
                        else
                            //if it does exist
                            if fileTime:GetEpochTime() > nextTime:GetEpochTime()
                                file:Copy(next)
                            end
                        end
                    end

                    if file:IsDirectory()
                        recursiveCopyDirectory(file, next)
                    end
                end
            end
        end
    end

    private action recursiveCopyDirectory(File from, File to) 
        if not to:Exists()
            to:CreateDirectories()
        end
        Array<File> files = from:GetDirectoryListing()
        Iterator<File> it = files:GetIterator()
        repeat while it:HasNext()
            File next = it:Next()
            if not next:IsHidden()
                if next:IsFile()
                    File copyTo
                    copyTo:SetWorkingDirectory(to:GetAbsolutePath() + "/")
                    copyTo:SetPath(next:GetPath())

                    DateTime fileTime = next:GetLastModifiedDate()
                    DateTime nextTime = copyTo:GetLastModifiedDate()

                    //if it doesn't exist, copy the file
                    if not copyTo:Exists()
                        next:Copy(copyTo)
                    else
                        //if it does exist
                        if fileTime:GetEpochTime() > nextTime:GetEpochTime()
                            next:Copy(copyTo)
                        end
                    end
                elseif next:IsDirectory()
                    File copyTo
                    copyTo:SetWorkingDirectory(to:GetAbsolutePath() + "/")
                    copyTo:SetPath(next:GetPath())
                    if not copyTo:Exists()
                        copyTo:CreateDirectories()
                    end
                    recursiveCopyDirectory(next, copyTo)
                end
            end
        end
    end

    private action WriteCompilerDependency(JarGenerator generator, File file, File originalLocation)
        if file:IsDirectory()
            Array<File> files = file:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()

            repeat while it:HasNext()
                File f = it:Next()
                WritePlugins(generator, f, originalLocation)
            end
        else
            text pluginPath = originalLocation:GetWorkingDirectory()
            text path = file:GetAbsolutePath()
            path = path:GetSubtext(pluginPath:GetSize())
            text wd = file:GetAbsolutePath()
            wd = wd:GetSubtext(0, pluginPath:GetSize() - 1)

            File f
            f:SetWorkingDirectory(wd)
            f:SetPath(path)
            
            //TODO: Optimize this to reduce the amount of copying that goes on
            generator:Add(f)
        end
    end

    private action WritePlugins(JarGenerator generator, File file, File originalLocation)
        if file:IsDirectory()
            Array<File> files = file:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()

            repeat while it:HasNext()
                File f = it:Next()
                if not f:IsHidden() and not (f:GetFileExtension() = "DS_Store")
                    WritePlugins(generator, f, originalLocation)
                end
            end
        else
            text pluginPath = originalLocation:GetWorkingDirectory()
            text path = file:GetAbsolutePath()
            path = path:GetSubtext(pluginPath:GetSize())
            text wd = file:GetAbsolutePath()
            boolean finished = true

            //if there's a slash at the end of the path, ignore it.
            if pluginPath:GetCharacter(pluginPath:GetSize() - 1) = "/"
                wd = wd:GetSubtext(0, pluginPath:GetSize() - 1)
                finished = false
            end

            if finished
                wd = wd:GetSubtext(0, pluginPath:GetSize())
            end

            File f
            f:SetWorkingDirectory(wd)
            f:SetPath(path)
            generator:Add(f)
        end
    end

    /*
        This action generates a default manifest file for the compiler, if 
        we are in bytecode format. This separates the logic from the jar 
        writer.
    */
    private action GetManifest(JarGenerator jar) returns text
        text version = jar:GetManifestVersion() + ": 1.0"
        line = version:GetCarriageReturn() + version:GetLineFeed()
        version = version + line
        
        
        text created = "Created-By: " + me:GetVersion()
        created = created + line

        text main = jar:GetManifestMainClass()

        File mainFile = me:GetMain()
        Class mainClass = me:GetMainClass()
        text classKey = "quorum." + mainClass:GetStaticKey()
        main = main + ": " + classKey
        main = main + line

        boolean usesLWJGL = symbolTable:HasClass("Libraries.Sound.Audio") or symbolTable:HasClass("Libraries.Games.Game")

        //now write any jar dependencies into the manifest
        if not additionalJarFiles:IsEmpty() or usesLWJGL
            Iterator<File> jars = additionalJarFiles:GetIterator()
            text classpath = "Class-Path: "
            text libraries = JAR_DEPENDENCY_FOLDER
            boolean isFirst = true
            repeat while jars:HasNext()
                File file = jars:Next()
                if isFirst
                    classpath = classpath + libraries + "/" + file:GetFileName()
                else
                    classpath = classpath + " " + libraries + "/" + file:GetFileName()
                end
                isFirst = false
            end

            if usesLWJGL
                File lwjgl
                lwjgl:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/AdditionalJars/")
                lwjgl:SetPath("lwjgl.jar")
                if isFirst
                    classpath = classpath + libraries + "/" + lwjgl:GetFileName()
                else
                    classpath = classpath + " " + libraries + "/" + lwjgl:GetFileName()
                end
            end

            main = main + classpath + line
        end

        total = version + created + main + line
        return total
    end

    private action CheckMain(File starter)
        Class m = GetMainClass()
        if m = undefined //no class that had a main method was selected, throw an error
            AddMainError(starter)
        elseif m not= undefined and m:HasMainAction() = false
            AddMainError(starter)
        else
            m:SetIsProgramStartingClass(true)
        end
    end

    private action AddMainError(File starter)
        CompilerError error
        text message = "I noticed that the class " + starter:GetPath() 
            +   " was specified as the starting point for this program, " 
            + "but it does not have an action named Main. " 

        Class clazz = symbolTable:GetClassInFile(starter:GetAbsolutePath())
        if clazz not= undefined
            if clazz:GetAction("main") not= undefined
                message = message + "This class does have an action named "
                    + "main, with a lower case m, did you mean for it to be "
                    + "capitalized?"
            end
        end
        error:SetErrorMessage(message)
        CompilerErrorType t
        t:SetCurrentType(t:MISSING_MAIN)
        error:SetCompilerErrorType(t)
        error:SetFile(starter)
        error:SetLineNumber(1)
        error:SetLineNumberEnd(1)
        error:SetColumnNumber(1)
        error:SetColumnNumberEnd(1)
        compilerErrorManager:Add(error)
    end

    /*
        This action parses a single source file at a particular location
    */ 
    action ParseSingle(text source, File file)
        Parser parser
        parser:SetFile(file)
        compilerErrorManager:RemoveErrorsAtKey(file:GetAbsolutePath())
        Parse(source, parser)
        
        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = undefined
        if compilerErrorManager:IsCompilationErrorFree()
            allFiles = GetAllRequiredFiles(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end

        if compilerErrorManager:IsCompilationErrorFree()
            TypeResolution(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end
    end

    action CompileSingle(text source)
        Parser parser
        File fakeLocation //set a default. It doesn't matter what it is.
        text fakePath = "SingleFileCompile.quorum"
        fakeLocation:SetPath(fakePath)
        me:SetMain(fakeLocation)
        parser:SetFile(fakeLocation)
        Parse(source, parser)
        
        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = undefined
        if compilerErrorManager:IsCompilationErrorFree()
            allFiles = GetAllRequiredFiles(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end

        if compilerErrorManager:IsCompilationErrorFree()
            TypeResolution(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end

        CheckMain(fakeLocation)

        Array<ClassOpcode> classOpcodes
        if compilerErrorManager:IsCompilationErrorFree()
            i = 0
            repeat while i < allFiles:GetSize()
                File file = allFiles:Get(i)
                QuorumBytecodeListener listener

                if listener:HasSayStatementInClass()
                    containsSpeechCommandInCompile = true
                end

                if not outputSpeechCommands
                    listener:SetOutputSpeech(outputSpeechCommands)
                end

                if file:GetPath() = fakePath
                    listener:SetFile(file)
                    Parse(source, listener)
                else
                    Parse(file, listener)
                end
                ClassOpcode op = listener:GetClassOpcode()
                classOpcodes:Add(op)
                i = i + 1
            end
        else 
            return now
        end

        if compilerErrorManager:IsCompilationErrorFree()

            if currentOutputType = JAVA_BYTECODE
                //iterate over all the class opcodes and write them to disk
                Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()
                    code:Write()
                end

                if compilerErrorManager:IsCompilationErrorFree()
                    JarGenerator generator
                    File jar = GetDistributionFile()
                    //generator:SetCompiler(me)
                    //generator:Write()
                end
            elseif currentOutputType = JAVASCRIPT
                text result = ""
                Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()
                    Class clazz = code:GetClass()

                    Class mainClazz = me:GetMainClass()
                    text mainClazzName = mainClazz:GetStaticKey()
                    text clazzName = clazz:GetStaticKey()
                    if clazzName = mainClazzName //keep it simple in the first version.
                        result = result + code:WriteJavaScript()
                    end
                    a = 5
                end
                convertedJavaScript = result
            end
        end
    end

    action GetCompiledJavaScript returns text
        return convertedJavaScript
    end

    action TypeResolution(SymbolTable table, TypeChecker types, CompilerErrorManager errors)
        Iterator<Class> classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ResolveUseStatements(table, errors)
        end

        classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()

            //because of the way the parent flattening algorithm works,
            //classes may already be resolved
            if not next:IsResolved()
                next:ResolveAllTypes(table, errors)
            end
        end

        classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ComputeVirtualActionTable(errors)
            next:ComputeGenericsTables(errors)
            types:Add(next)
        end
    end

    action IsCompilationErrorFree returns boolean
        return compilerErrorManager:IsCompilationErrorFree()
    end

    action GetCompilerErrorManager returns CompilerErrorManager
        return compilerErrorManager
    end

    action GetCompilerErrorsAsText returns text
        text EOL = ""
        EOL = EOL:GetCarriageReturn() + EOL:GetLineFeed()
        text result =  "This program did not compile. I have compiled a list of errors for you below:" + EOL
        Iterator<CompilerError> errors = compilerErrorManager:GetIterator()
        repeat while errors:HasNext()
            CompilerError error = errors:Next()
            text t = error:GetDisplayName()
            result = result + EOL + t
        end
        return result
    end

    action GetCompilerErrorsAsShortText returns text
        text EOL = ""
        EOL = EOL:GetCarriageReturn() + EOL:GetLineFeed()
        text result =  "I found problems:" + EOL
        Iterator<CompilerError> errors = compilerErrorManager:GetIterator()
        repeat while errors:HasNext()
            CompilerError error = errors:Next()
            text t = error:GetShortDisplayName()
            result = result + EOL + t
        end
        return result
    end

    /*
        This action is called after the parsing phase, returning an array
        of all files were required for building the project.
    */
    action GetAllRequiredFiles(SymbolTable table, TypeChecker types, CompilerErrorManager errors) returns Array<File>
        Array<File> files

        HashTable<text, File> parsed
        HashTable<text, File> unparsed

        Iterator<Class> classes = table:GetClasses()
//        repeat while classes:HasNext()
//            Class clazz = classes:Next()
//            File classFile = clazz:GetFile()
//            text path = classFile:GetAbsolutePath()
//            if not parsed:HasKey(path)
//                parsed:Add(path, clazz:GetFile())
//            end
//        end
//
//        classes = table:GetClasses()
        repeat while classes:HasNext()
            //gather up all the classes on the system and check their
            //use statements for classes we don't know about
            //if there are some, mark them as unparsed
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                File classFile = clazz:GetFile()
                text path = classFile:GetAbsolutePath()
                if not parsed:HasKey(path)
                    parsed:Add(path, clazz:GetFile())
                end
                Iterator<QualifiedName> names = clazz:GetUnresolvedUseStatements()
                ResolveQualifiedNames(table, names, parsed, unparsed, clazz)

                Iterator<QualifiedName> parents = clazz:GetUnresolvedParents()
                ResolveParents(table, parents, parsed, unparsed, clazz)

                ResolveBlocks(table, parsed, unparsed, clazz)
            end

            //make list of any new classes that need to be analyzed
            //that have not previously been parsed. If there are some
            //send them back through the loop
            List<Class> newClasses
            Iterator<File> mustParse = unparsed:GetValueIterator()
            repeat while mustParse:HasNext()
                File next = mustParse:Next()
                Parser listener
                text null = undefined
                ParseSandbox(null, listener, table, errors, types, next)
                parsed:Add(next:GetAbsolutePath(), next)

                Iterator<Class> parsedClasses = listener:GetClassesIterator()
                repeat while parsedClasses:HasNext()
                    Class clazz = parsedClasses:Next()
                    newClasses:Add(clazz)
                    if not symbolTable:HasClass(clazz:GetStaticKey())
                        symbolTable:Add(clazz)
                    end
                end
            end
            classes = newClasses:GetIterator()
            unparsed:Empty()
        end
        return parsed:CopyToValueArray()
    end

    private action ResolveBlocks(SymbolTable table, HashTable<text, File> parsed,
        HashTable<text, File> unparsed, Class clazz)
        
        Iterator<Action> actions = clazz:GetActions()
        repeat while actions:HasNext()
            Action act = actions:Next()
            //resolve parameters first
            Iterator<Variable> parameters = act:GetParameterIterator()
            repeat while parameters:HasNext()
                Variable parameter = parameters:Next()
                Type type = parameter:GetType()
                ResolveClass(table, type:GetStaticKey(), clazz, parsed, unparsed)
            end
        end
    end

    /*
        This action handles resolving a class or otherwise scheduling a parse
        from the standard library. If a class is returned, then it has
        already been parsed and is in the symbol table. If the class
        returns is undefined, then either the class does not exist or 
        it is in the standard library and has not yet been parsed. As such,
        returning undefined is not necessarily a compiler error.
    */
    private action ResolveClass(SymbolTable table, text key, Class clazz, HashTable<text, File> parsed,
        HashTable<text, File> unparsed)
        boolean done = false
        Class c = undefined

        Type typeCheck
        typeCheck:SetToObject(key)
        //is this really just a primitive, pretending to be a class?
        if typeCheck:IsPrimitive()
            return now
        end


        //first check if it's already valid by looking at the symbol
        //table
        c = table:GetClass(key)

        //if it isn't there, check our use table
        if c = undefined
            c = clazz:GetValidUseName(key)
        end

        //if it isn't there, check the standard library, to 
        //see if there's a file in the right place
        //if there is, mark it for parsing
        if c = undefined
            File file = GetStandardLibraryFile(key, clazz:GetPackageKey())
            if file not= undefined
                text newPath = file:GetAbsolutePath()
                if parsed:HasKey(newPath) //this class has already been parsed
                elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing
                else
                    unparsed:Add(newPath, file)
                end
            else //ok last chance. Check an unresolved use statement to
                 //see if one of these reference the standard library
                 QualifiedName qn = clazz:GetUnresolvedUseStatement(key)
                 if qn not= undefined
                    file = GetStandardLibraryFile(qn:GetStaticKey(), clazz:GetPackageKey())
                    if file not= undefined
                        text newPath = file:GetAbsolutePath()
                        if parsed:HasKey(newPath) //this class has already been parsed
                        elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing
                        else
                            unparsed:Add(newPath, file)
                        end
                    end
                 end
            end
        end
    end

    private action ResolveParents(SymbolTable table, Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            text key = qn:GetStaticKey()
            ResolveClass(table, key, clazz, parsed, unparsed)
        end
    end

    private action ResolveQualifiedNames(
            SymbolTable table, 
            Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            if qn:IsAll()
                ResolveAllClassesInContainer(table, qn, parsed, unparsed, clazz)
            else
                text key = qn:GetStaticKey()
                ResolveClass(table, key, clazz, parsed, unparsed)
            end
        end
    end

    private action ResolveAllClassesInContainer(SymbolTable table,
            QualifiedName name, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        //Get the container name without the "all" at the end
        File folder = GetStandardLibraryFolderForPackage(name:GetStaticKeyNoAll())

        //check if this is the standard library. If so, load them all into unparsed
        //if they aren't already in there or in parsed
        if folder not= undefined
            Array<File> files = folder:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()
            repeat while it:HasNext()
                File file = it:Next()
                text path = file:GetAbsolutePath()
                if not file:IsDirectory() and not parsed:HasKey(path) and not unparsed:HasKey(path)
                    and file:GetFileExtension() = "quorum" and not table:HasFile(file:GetAbsolutePath())
                    unparsed:Add(path, file)
                end
            end
        end
    end

    private action GetStandardLibraryFolderForPackage(text key) returns File
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            standardLibraryFolder = build
        end
        text loc = standardLibraryFolder:GetWorkingDirectory()
        text loc2 = standardLibraryFolder:GetAbsolutePath()

        File file
        file:SetWorkingDirectory(loc2)

        Array<text> values = key:Split("\.")

        text location = "/"
        Iterator<text> it = values:GetIterator()
        repeat while it:HasNext()
            text next = it:Next()
            location = location + next

            if it:HasNext()
                location = location + "/"
            end
        end

        file:SetPath(location)
        if file:Exists()
            return file
        end
        return undefined
    end

    action GetStandardLibraryFile(text key, text fromPackage) returns File
        Array<text> values = key:Split("\.")
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            standardLibraryFolder = build
        end
        text loc = standardLibraryFolder:GetWorkingDirectory()
        text loc2 = standardLibraryFolder:GetAbsolutePath()

        File file
        file:SetWorkingDirectory(loc2)

        if values:GetSize() = 1
            text mySplit = "/" + fromPackage:Replace(".", "/") + "/" + key + ".quorum"
            file:SetPath(mySplit)
            if file:Exists()
                return file
            end
        else
            text location = "/"
            Iterator<text> it = values:GetIterator()
            repeat while it:HasNext()
                text next = it:Next()
                location = location + next

                if it:HasNext()
                    location = location + "/"
                else
                    location = location + ".quorum"
                end
            end

            file:SetPath(location)
            if file:Exists()
                return file
            end
        end
        
        return undefined
    end

    action Parse(File file, QuorumSourceListener listener)
        listener:SetSymbolTable(symbolTable)
        listener:SetCompilerErrorManager(compilerErrorManager)
        listener:SetFile(file)
        listener:SetTypeChecker(checker)
        ParseNative(file, listener)
    end

    private system action ParseNative(File file, QuorumSourceListener listener)


    action Parse(text source, QuorumSourceListener listener)
        listener:SetSymbolTable(symbolTable)
        listener:SetCompilerErrorManager(compilerErrorManager)
        listener:SetTypeChecker(checker)
        ParseNative(source, listener)
    end

    private system action ParseNative(text source, QuorumSourceListener listener)

    action GetName returns text
        return name
    end

    action GetNameWithExtension returns text
        return name + GetFileExtension()
    end

    action SetName(text name)
        me:name = name
    end

    action GetFileExtension returns text
        if IsWebApplication()
            return ".war"
        else
            return ".jar"
        end
    end

    action GetMain returns File
        return main
    end

    action GetMainClass returns Class
        text path = main:GetAbsolutePath()
        Class c = symbolTable:GetClassInFile(path)
        return c
    end

    action SetMain(File file)
        main = file
    end

    action GetVersion returns text
        return "Quorum " + VERSION
    end

    action GetOutputFolder returns File
        return outputFolder
    end

    action SetOutputFolder(File file)
        if file not= undefined
            outputFolder = file
            text path = file:GetAbsolutePath()

            if not file:Exists()
                file:CreateDirectories()
            end

            File build
            build:SetWorkingDirectory(path)
            build:SetPath(DEFAULT_BUILD_FOLDER)
            buildFolder = build

            File run 
            run:SetWorkingDirectory(path)
            run:SetPath(DEFAULT_RUN_FOLDER)
            me:runFolder = run
        else
            File root
            outputFolder = root
        end
    end

    action GetBuildFolder returns File
        return buildFolder
    end

    action GetStandardLibraryFolder returns File
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            return build
        end
        return standardLibraryFolder
    end

    action SetStandardLibraryFolder(File file)
        standardLibraryFolder = file
        File f
        f:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
        f:SetPath("plugins")
        pluginFolder = f

        File f2
        f2:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
        f2:SetPath("org")
        dependencyFolder = f2
    end

    action GetDistributionFile returns File
        File run = GetRunFolder()
        text path = run:GetPath() + "/"
        File newRun
        newRun:SetWorkingDirectory(run:GetWorkingDirectory())
        newRun:SetPath(path + GetNameWithExtension())
        return newRun
    end

    action GetRunFolder returns File
        return runFolder
    end

    action IsWebApplication returns boolean
        return isWebApplication
    end

    action SetIsWebApplication(boolean web)
        isWebApplication = web
    end
end