package Libraries.Language.Compile

use Libraries.System.File
use Libraries.Language.Compile.Symbol.all
use Libraries.Containers.HashTable
use Libraries.Containers.Array
use Libraries.Containers.Blueprints.Iterator
use Libraries.Language.Compile.Translate.JarGenerator
use Libraries.Containers.List
use Libraries.Language.Compile.Translate.ClassOpcode
use Libraries.System.DateTime

class Compiler
    public constant number VERSION = 3.0
    File main = undefined
    File outputFolder = undefined
    File pluginFolder = undefined
    File dependencyFolder = undefined
    constant text DEFAULT_BUILD_FOLDER = "Build"
    constant text DEFAULT_RUN_FOLDER = "Run"
    constant text DEFAULT_STANDARD_LIBRARY_FOLDER = "Library/Standard"
    constant text WAR_CLASS_DIRECTORY = "WEB-INF/classes"
    constant text DOCUMENTATION_FOLDER = "Documents/"
    constant text OBJECT = "Libraries.Language.Object"
    constant text JAR_DEPENDENCY_FOLDER = "libraries"
    File buildFolder = undefined
    File runFolder = undefined
    File standardLibraryFolder = undefined
    HashTable<text, Dependency> dependencies
    boolean isWebApplication = false
    text name = "Default"
    text convertedJavaScript = ""
    //Support classes
    SymbolTable symbolTable
    CompilerErrorManager compilerErrorManager
    TypeChecker checker


    //Sandbox classes for the parser
    SymbolTable sandboxSymbolTable
    CompilerErrorManager sandboxCompilerErrorManager
    TypeChecker sandboxTypeChecker
    public constant integer JAVA_BYTECODE = 0
    public constant integer JAVASCRIPT = 1
    public constant integer DOCUMENT = 2

    integer currentOutputType = 0
    boolean outputSpeechCommands = true
    boolean containsSpeechCommandInCompile = false
    CompilerProfiler profiler
    Array<File> additionalPluginFolders
    Array<File> additionalJarFiles
    boolean hasBeenCompiled = false
    constant text USE = "use"
    constant text PACKAGE = "package"
    HashTable<text, Class> lastGoodCompileHash

    action HasSpeechCallInCompile returns boolean
        return containsSpeechCommandInCompile
    end

    /*
        This action clears out any existing information in the compiler. By
        default it removes only parse information, but does not alter
        any parameters (e.g., project directory).
    */
    action Empty
        SymbolTable symbolTable2
        CompilerErrorManager compilerErrorManager2
        TypeChecker checker2
        CompilerProfiler profiler2

        symbolTable = symbolTable2
        compilerErrorManager = compilerErrorManager2
        checker = checker2
        checker:SetSymbolTable(symbolTable)
        profiler = profiler2
    end

    action SetOutputSpeech(boolean doSay)
        outputSpeechCommands = doSay
    end

    action GetOutputSpeech returns boolean
        return outputSpeechCommands
    end

    action LoadDependency(text from, text to)
        Dependency dep
        dep:from = from
        dep:to = to
        dependencies:Add(from, dep)
    end

    /* This action sets what kind of output the compiler is going to have. By default
       this returns Java bytecode.
    */
    action GetOutputType returns integer
        return currentOutputType
    end

    /*
        This action tells the compiler what kind of output to emit.
    */
    action SetOutputType(integer type)
        if type >= JAVA_BYTECODE and type <= DOCUMENT
            currentOutputType = type
        else
            currentOutputType = 0
        end
    end

    action GetDependencies returns Iterator<Dependency>
        return dependencies:GetValueIterator()
    end

    /*
        This action scans the system classes available and parses them appropriately.
    */
    action ScanStandardLibrary
        Array<File> lib = CollectStandardLibrary()
        integer i = 0
        repeat lib:GetSize() times
            File file = lib:Get(i)
            Parser listener
            ParseSandbox(undefined, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
            i = i + 1
        end

        TypeResolution(sandboxSymbolTable, sandboxTypeChecker, sandboxCompilerErrorManager)

        Array<ClassOpcode> classOpcodes
        if compilerErrorManager:IsCompilationErrorFree()
            i = 0
            repeat while i < lib:GetSize()
                File file = lib:Get(i)
                QuorumBytecodeListener listener
                ParseSandbox(undefined, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
                ClassOpcode op = listener:GetClassOpcode()
                op:SetBuild(buildFolder)
                classOpcodes:Add(op)
                i = i + 1
            end
        end
    end

    /*
        This action collects all files in the standard library and places them 
        into an array for indexing or other purposes.
    */
    private action CollectStandardLibrary returns Array<File>
        Array<File> files
        File standardLibraryFolder = GetStandardLibraryFolder()
        File f1
        f1:SetWorkingDirectory(standardLibraryFolder:GetWorkingDirectory())
        f1:SetPath(standardLibraryFolder:GetPath() + "/Libraries")
        standardLibraryFolder = f1

        Array<File> folders
        folders:Add(standardLibraryFolder)
        integer folderIndex = 0
        done = false
        repeat while folderIndex < folders:GetSize()
            File folder = folders:Get(folderIndex)
            Array<File> listing = folder:GetDirectoryListing()
            i = 0
            repeat listing:GetSize() times
                File file = listing:Get(i)
                if file:IsDirectory()
                    folders:Add(file)
                else
                    files:Add(file)
                end
                i = i + 1
            end
            folderIndex = folderIndex + 1
        end

        return files
    end

    /*
        This action calls the parsing commands regularly, for example from
        within in an IDE, in a specialized way. Specifically, it first tries
        to parse the text passed in. The single file passed in is the file
        to be parsed, usually stored in memory (not disk). The file location
        of this text is the location on disk, but its current contents may
        not be written, so this should be used as a key, not a store.
    */
    action ParseRepeat(ProjectInformation information) returns CompilerResult
        CompilerProfiler sandboxedProfiler
        CompilerResult result
        result:compilerErrorManager = sandboxCompilerErrorManager
        sandboxCompilerErrorManager:Empty()
        result:symbolTable = sandboxSymbolTable
        sandboxTypeChecker:SetSymbolTable(sandboxSymbolTable)
        DateTime time
        start = time:GetEpochTime()
        sandboxedProfiler:Add(time:GetEpochTime())

        text source = information:source
        File loc = information:sourceLocation
        text locPath = loc:GetAbsolutePath()

        //Check if this class is already in there. If so, remove it
        //if after 
        boolean isSandBoxEmpty = true
        Class inFile = sandboxSymbolTable:GetClassInFile(locPath)
        if inFile not= undefined
            sandboxSymbolTable:RemoveClass(inFile:GetStaticKey())
        else //the file isn't in there. Check if the symbol table has other classes
            isSandBoxEmpty = sandboxSymbolTable:IsEmpty()
        end
        
        Array<File> files = information:projectFiles

        boolean isInvalidCompile = false
        if files = undefined
            isInvalidCompile = true
        elseif files:IsEmpty()
            isInvalidCompile = true
        end

        if isInvalidCompile
            CompilerError error
            text message = ""
            if files = undefined
                message = "I cannot compile an array of files that is passed to me undefined"
            elseif files:IsEmpty()
                message = "I cannot compile an arry of files that is empty. Please specify which files you would like compiled."
            end
            error:SetErrorMessage(message)
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_FILE)
            error:SetCompilerErrorType(t)
            error:SetLineNumber(1)
            error:SetLineNumberEnd(1)
            error:SetColumnNumber(1)
            error:SetColumnNumberEnd(1)
            compilerErrorManager:Add(error)
            return result
        end

        text null = undefined

        if inFile = undefined
            i = 0
            repeat while i < files:GetSize()
                File file = files:Get(i)
                Parser listener
                if file:GetAbsolutePath() = locPath
                    ParseSandbox(source, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
                else 
                    ParseSandbox(null, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
                end
                i = i + 1
            end
        else
            Parser listener
            ParseSandbox(source, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, loc)
        end
        sandboxedProfiler:Add(time:GetEpochTime())

        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = undefined
        allFiles = GetAllRequiredFiles(sandboxSymbolTable, sandboxTypeChecker, sandboxCompilerErrorManager)
        sandboxedProfiler:Add(time:GetEpochTime())
        if inFile = undefined and isSandBoxEmpty
            TypeResolution(sandboxSymbolTable, sandboxTypeChecker, sandboxCompilerErrorManager)
        else
            Class newParse = sandboxSymbolTable:GetClassInFile(locPath)
            if newParse not= undefined
                newParse:ResolveUseStatements(sandboxSymbolTable, sandboxCompilerErrorManager)
                newParse:ResolveAllTypes(sandboxSymbolTable, sandboxCompilerErrorManager)
                newParse:ComputeVirtualActionTable(sandboxCompilerErrorManager)
                newParse:ComputeGenericsTables(sandboxCompilerErrorManager)
                sandboxTypeChecker:Add(newParse)
            end
        end

        sandboxedProfiler:Add(time:GetEpochTime())

        Array<ClassOpcode> classOpcodes
        if sandboxCompilerErrorManager:IsCompilationErrorFree()
            if inFile = undefined
                i = 0
                repeat while i < allFiles:GetSize()
                    File file = allFiles:Get(i)
                    QuorumBytecodeListener listener

                    if file:GetAbsolutePath() = locPath
                        integer errors = sandboxCompilerErrorManager:GetErrorAmount()
                        ParseSandbox(source, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
                        integer errors2 = sandboxCompilerErrorManager:GetErrorAmount()
                        if errors = errors2 //there were no errors during the parse of this file, so cache it
                            lastGoodCompileHash:Add(locPath, sandboxSymbolTable:GetClassInFile(locPath))
                        end
                    else 
                        ParseSandbox(null, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, file)
                    end
                    i = i + 1
                end
            else
                QuorumBytecodeListener listener
                integer errors = sandboxCompilerErrorManager:GetErrorAmount()
                ParseSandbox(source, listener, sandboxSymbolTable, sandboxCompilerErrorManager, sandboxTypeChecker, loc)
                integer errors2 = sandboxCompilerErrorManager:GetErrorAmount()
                if errors = errors2 //there were no errors during the parse of this file, so cache it
                    lastGoodCompileHash:Add(locPath, sandboxSymbolTable:GetClassInFile(locPath))
                end
            end
        else 
            return result
        end
        sandboxedProfiler:Add(time:GetEpochTime()) 
        
        DateTime time2
        //integer finish = cast(integer, time2:GetEpochTime())
        //integer total = cast(integer, (finish - start) / 1000.0)
        result:time = (time2:GetEpochTime() - start) / 1000.0//total
        return result
    end

    private action ParseSandbox(text source, QuorumSourceListener listener, SymbolTable table, CompilerErrorManager errors,
        TypeChecker types, File loc)
        listener:SetSymbolTable(table)
        listener:SetCompilerErrorManager(errors)
        listener:SetTypeChecker(types)
        listener:SetFile(loc)

        if not (source = undefined)
            listener:SetSource(source)
            ParseNative(source, listener)
        else 
            ParseNative(loc, listener)
        end
        
    end
    
    action Request(CodeCompletionRequest request) returns CodeCompletionResult
        CodeCompletionResult result

        text source = request:source
        integer index = request:caretLocation
        text line = GetLineBeforeCursor(index, source)
        result:prefix = line
        text trimmed = line:Trim()
        request:line = trimmed
//
//        text sub = line:GetSubtext(0, request:startOffset - 1)
//        boolean isDot = false
//
//        if sub:GetSize() > 0
//            text index = sub:GetCharacter(sub:GetSize() - 1)
//            if index = "."
//                isDot = true
//            end
//        end
//        
        boolean isUse = trimmed:StartsWith("use")
        boolean isPackage = trimmed:StartsWith("package")

        if isUse
            AddUseResults(request, result, true)
        elseif not isUse and isPackage
            AddUseResults(request, result, false)
        elseif not isUse and not isPackage
            AddExpressionResults(request, result)
        end

        return result
    end

    private action AddExpressionResults(CodeCompletionRequest request, CodeCompletionResult result)
        text line = request:line //this is already trimmed
        Array<text> split = line:Split(":")

        //now set the filer for this particular request
        if split:GetSize() > 0 and not line:IsEmpty()
            text ch = line:GetCharacter(line:GetSize() - 1)
            if ch = ":"
                result:filter = ""
            else
                result:filter = split:Get(split:GetSize() - 1)
            end
        end

        //the most recent compile may contain errors. Get the most recent
        //successful compile. Store the error compile as well, as it may
        //help us determine the right values for code completion.
        text file = request:fileKey
        Class clazz = sandboxSymbolTable:GetClassInFile(file)

        //we have tried to get the class from the sandbox. It this is undefined
        //then check the cache. If there is no cached version of the class,
        //then likely this class hasn't compiled in a while and there may
        //be little we can do to detect what the user is doing.
        Class clazzCached = lastGoodCompileHash:GetValue(file)
        boolean classNotFound = false
        if clazz = undefined and clazzCached not= undefined
            clazz = clazzCached
            classNotFound = true
        end

        boolean lastCompileFailed = false
        if clazz not= undefined and clazzCached not= undefined
            hash1 = clazz:GetHashCode()
            hash2 = clazzCached:GetHashCode()

            //if these don't match, the most recent parse did not compile
            //for this file. Let the code completion library know we
            //are in an intermediate state.
            if hash1 not= hash2
                lastCompileFailed = true
            end
        end
        
        //now we have checked the cache. If this is still undefined, bail
        if clazz not= undefined
            integer start = clazz:GetIndex()
            integer finish = clazz:GetIndexEnd()

            //is it inside of this class? If not, kill the request, because no syntax is legal
            if not(request:caretLocation >= start and request:caretLocation <= finish)
                clazz = undefined
            end

            if split:IsEmpty()
                clazz = undefined
                return now
            end
        end

        
        text left = split:Get(0)
        text trimmedLeft = left:Trim()
        if clazz not= undefined
            text line2 = left
            integer i = line2:GetSize() - 1
            repeat while i >= 0
                text ch = line2:GetCharacter(i)
                if ch = "(" or ch = ","
                   or ch = "*" or ch = "/"
                   or ch = "+" or ch = "-"
                   or ch = " " or IsMod(line2, i) 
                    //make this work for mod --- if it's a d, check backwards and ensure that it's not part of another word

                    //split the line again
                    line2 = line2:GetSubtext(i + 1, line2:GetSize())
                    left = line2
                    line2 = line2:Trim()
                    split = line2:Split(":")
                    if split:IsEmpty()
                        return now
                    end

                    if split:GetSize() > 1 or line2:Contains(":")
                        text ch2 = line2:GetCharacter(line2:GetSize() - 1)
                        if ch2 = ":"
                            result:filter = ""
                        else
                            result:filter = split:Get(split:GetSize() - 1)
                        end
                    end
                    trimmedLeft = line2
                    i = -1
                end
                i = i - 1
            end

            Action method = GetActionAtIndex(clazz, request:caretLocation)
            if left = "me" or left:IsEmpty() or trimmedLeft:IsEmpty()
                AddClassToResult(undefined, request, result, clazz, true, method)
            else
                if method not= undefined
                    Block block = GetBlockAtIndex(method:GetBlock(), request:caretLocation)
                    if block not= undefined
                        Variable variable = block:GetVariable(trimmedLeft)
                        if variable not= undefined
                            AddVariableAsClass(variable, request, result)
                        //if we can't find the variable and the last compile
                        //failed, check the cache. Maybe it has some information
                        elseif variable = undefined and lastCompileFailed and classNotFound not= true
                            Action methodCached = GetActionAtIndex(clazzCached, request:caretLocation)
                            if methodCached = undefined
                                return now
                            end
                            Block blockCached = GetBlockAtIndex(methodCached:GetBlock(), request:caretLocation)
                            if blockCached = undefined
                                return now
                            end
                            Variable variableCached = blockCached:GetVariable(trimmedLeft)
                            if variableCached = undefined
                                return now
                            end
                            AddVariableAsClass(variableCached, request, result)
                        end
                    end
                end
            end
        end
    end

//    private action GetPartialLine(text line) returns text
//        text result = ""
//
//        integer i = line:GetSize() - 1
//        repeat while i >= 0
//            text ch = line:GetCharacter(i)
//            if ch = "(" or ch = ","
//               or ch = "*" or ch = "/"
//               or ch = "+" or ch = "-"
//               or ch = " " or IsMod(line, i) 
//                //make this work for mod --- if it's a d, check backwards and ensure that it's not part of another word
//                
//                //split the line again
//                line = line:GetSubtext(i + 1, line:GetSize() - 1)
//                line = line:Trim()
//                
////                //resplit it
////                partialLine = partialLine.trim();
////                split = partialLine.split(":");
////                if(split.length == 0) {
////                    return; //the string is garbage, so return
////                }
////                left = split[0];
////                if (split.length > 1 || !partialLine.contains(":")) {
////                    result.setFilter(split[split.length - 1]);
////                } else {
////                    result.setFilter("");
////                }
////                i = -1; //finish early.
//                end
//            i = i - 1
//        end
//
//        return result
//    end

    private action IsMod(text partial, integer i) returns boolean
        if i - 3 < 0
            return false
        end

        if partial:GetCharacter(i) = "d"
            and partial:GetCharacter(i - 1) = "o"
            and partial:GetCharacter(i - 2) = "m"
            and partial:GetCharacter(i - 3) = " "
            return true
        end

        return false
    end

    private action AddVariableAsClass(Variable variable, CodeCompletionRequest request, CodeCompletionResult result)

        Type type = variable:GetType()
        if type not= undefined
            text key = type:GetStaticKey()
            Class varClass = sandboxSymbolTable:GetClass(key)
            if varClass not= undefined
                AddClassToResult(variable, request, result, varClass, false, undefined)
            end
        end
    end

    private action GetVariableInBlock() returns Variable
        Variable variable = undefined
        

        return variable
    end

    /*
        Obtains the logical block located at this index. 
    */
    private action GetBlockAtIndex(Block block, integer index) returns Block
        Block bestBlock = undefined

        if block not= undefined
            boolean test = IsIndexInLocation(block, index)
            if test
                bestBlock = block
            end
            //get subblocks and try those
            //this call recursively calls to subblocks, thus no need
            //for going deeper in this loop exists
            Iterator<Block> blocks = block:GetBlocks()
            repeat while blocks:HasNext()
                Block b = blocks:Next()
                Block returnedBlock = GetBlockAtIndex(b, index)
                if returnedBlock not= undefined
                    if IsIndexInLocation(returnedBlock, index)
                        integer start = returnedBlock:GetIndex()
                        integer finish = returnedBlock:GetIndexEnd()
                        integer range = finish - start

                        if bestBlock = undefined
                            bestBlock = returnedBlock
                        else
                            integer bestStart = bestBlock:GetIndex()
                            integer bestFinish = bestBlock:GetIndexEnd()
                            integer bestRange = bestFinish - bestStart
                            //this block is nested 
                            if range < bestRange
                                bestBlock = returnedBlock
                            end
                        end
                    end
                end
            end
        end

        return bestBlock
    end

    private action IsIndexInLocation(Location location, integer index) returns boolean
        integer start = location:GetIndex()
        integer finish = location:GetIndexEnd()
        if index >= start and index <= finish
            return true
        end

        return false
    end

    private action GetActionAtIndex(Class clazz, integer index) returns Action
        Action act = undefined
        File file = clazz:GetFile()
        text classPath = file:GetAbsolutePath()

        Iterator<Action> actions = clazz:GetActions()
        repeat while actions:HasNext()
            Action a = actions:Next()
            integer start = a:GetIndex()
            integer finish = a:GetIndexEnd()
            File f = a:GetFile()
            text actionPath = f:GetAbsolutePath()
            if index >= start and index <= finish and classPath = actionPath
                act = a
                return act
            end
        end
        return act
    end

    private action AddClassToResult(Variable variable, 
            CodeCompletionRequest request, 
            CodeCompletionResult result, Class clazz, 
            boolean isCurrentClass, Action insideMethod)

        if clazz not= undefined

            //add all of the fields from this class
            Iterator<Variable> variables = clazz:GetVariables()
            repeat while variables:HasNext()
                Variable variable2 = variables:Next()
                CodeCompletionItem item = variable2:GetCodeCompletionItem(clazz)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                if isCurrentClass
                    result:Add(item)
                else
                    if not variable2:IsPrivate()
                        result:Add(item)
                    end
                end
            end

            //now add all of the parent fields from this class
            Iterator<Class> parents = clazz:GetParentClasses()
            repeat while parents:HasNext()
                Class par = parents:Next()
                Iterator<Variable> variables2 = par:GetVariables()
                repeat while variables2:HasNext()
                    Variable variable2 = variables2:Next()
                    CodeCompletionItem item = variable2:GetCodeCompletionItem(clazz)
                    text filter = result:filter
                    integer size = filter:GetSize()
                    item:dotOffset = request:caretLocation - size
                    if isCurrentClass
                        result:Add(item)
                    else
                        if not variable2:IsPrivate()
                            result:Add(item)
                        end
                    end
                end
            end

            //if this is the current class, load all methods, public or private
            //if this is a variable, load only its public methods.
            Iterator<Action> actions = clazz:GetVirtualTable()
            repeat while actions:HasNext()
                Action act = actions:Next()
                CodeCompletionItem item = act:GetCodeCompletionItem(variable)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size

                //is this action in the base class or the v-table?
                if clazz:HasAction(act:GetStaticKey())
                    item:isBaseClassAction = true
                end

                if isCurrentClass
                    result:Add(item)
                else
                    if not act:IsPrivate()
                        result:Add(item)
                    end
                end
            end
        end


    end

    private action GetLineBeforeCursor(integer loc, text source) returns text
        if loc - 1 <= source:GetSize()
            integer i = loc - 1
            text CR = source:GetLineFeed()

            integer start = 0
            repeat while i >=0 
                text ch = source:GetCharacter(i)
                if ch = CR //this is the end of the line
                    start = i
                    i = -1
                end
                i = i - 1
            end

            text sub = source:GetSubtext(start, loc)
            return sub
        end

        return undefined
    end

    private action AddCustomClasses(CodeCompletionRequest request, CodeCompletionResult result, text pack)
        Iterator<Class> classes = sandboxSymbolTable:GetClassesInPackage(pack)

        if classes not= undefined
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                CodeCompletionItem item = GetClassCompletionItem(clazz)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
            end
        end
    end

    private action GetClassCompletionItem(Class clazz) returns CodeCompletionItem
        CodeCompletionItem item
        item:SetType(item:CLASS)

        text signature = clazz:GetStaticKey()
        text name = clazz:GetName()

        text description = ""
        description = description + "<h1>" + signature + "</h1>"
//        String[] paragraphs = Documentation.breakStringIntoParagraphArray(clazz.getDocumentation().getDescription());
//        for (int i = 0; i < paragraphs.length; i++) {
//            description += "<p>" + paragraphs[i] + "</p>";
//        }
//
//        description += "<h2>" + "Code Example:" + "</h2>";
//        description += "<PRE><CODE>" + clazz.getDocumentation().getExample()
//                + "</PRE></CODE>";

        item:displayText = name
        item:completionText = name
        item:documentationText = "Test"
        return item
    end

    private action GetPackageCompletionItem(text pack) returns CodeCompletionItem
        CodeCompletionItem item
        item:SetType(item:PACKAGE)

        text signature = pack
        text name = pack

        text description = "<h1>" + signature + "</h1>"

        item:displayText = name
        item:completionText = name
        item:documentationText = ""
        return item
    end

    private action AddSubpackagesAndClasses(CodeCompletionRequest request, CodeCompletionResult result, text name)
        //first find all of the packages/sub-packages 
        Iterator<text> packs = sandboxSymbolTable:GetSubpackageNames(name)
        repeat while packs:HasNext()
            text pack = packs:Next()
            integer size = name:GetSize() + 1
            text subpackName = pack:GetSubtext(0, size)
            text filteredName = subpackName + result:filter
            subpackName = pack:GetSubtext(size, pack:GetSize())

            if pack:StartsWith(filteredName)
                CodeCompletionItem item = GetPackageCompletionItem(subpackName)
                text filter = result:filter
                integer size2 = filter:GetSize()
                item:dotOffset = request:caretLocation - size2
                result:Add(item)
            end
        end

        //next find any classes on the system in the package
        Iterator<Class> classesInPackage = sandboxSymbolTable:GetClassesInPackage(name)
        boolean hasAny = false
        if classesInPackage not= undefined
            hasAny = classesInPackage:HasNext()
            repeat while classesInPackage:HasNext()
                Class pack = classesInPackage:Next()
                text key = pack:GetStaticKey()
                CodeCompletionItem item = GetClassCompletionItem(pack)
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
            end
        end
        
        //finally, remind the user they can use the "all" keyword
        if hasAny
            CodeCompletionItem item
            item:SetType(item:PACKAGE)
            text DQ = ""
            DQ = DQ:GetDoubleQuote()
            text signature = "Use all classes with the " + DQ + "all" + DQ + " keyword."
            text itemName = "all"

            text description = "<h1>" + signature + "</h1>"
                    + "<p align=" + DQ + "justify" + DQ + ">The word "
                    + "all indicates to quorum that we would like to"
                    + " have access to all classes in the package. For "
                    + "example, the phrase Libraries.Containers.all would indicate "
                    + "that we want to use any class in the Libraries.Containers "
                    + "package."
                    + "</p>"
            description = description + "<h2>" + "Code Example:" + "</h2>"
            description = description + "<PRE><CODE>"
                    + "use Libraries.Containers.all\n\n"
                    + "List&lt;integer&gt; list\n"
                    + "Array&lt;integer&gt; array"
                    + "</PRE></CODE>"

            item:displayText = itemName
            item:documentationText = description
            item:completionText = "all"
            text filter = result:filter
            integer size = filter:GetSize()
            item:dotOffset = request:caretLocation - size
            result:Add(item)
        end
    end

    private action ReformPackage(Array<text> packs) returns text
        text result = ""
        integer i = 0
        repeat while i < packs:GetSize()
            text value = packs:Get(i)
            if i = 0
                result = result + value
            else
                result = result + value + "."
            end
            i = i + 1
        end
        return result
    end

    private action AddUseResults(CodeCompletionRequest request, CodeCompletionResult result, boolean isUse)
        text trim = request:line
        trim = trim:Trim()
        if isUse
            trim = trim:GetSubtext(USE:GetSize())
        else
            trim = trim:GetSubtext(PACKAGE:GetSize())
        end

        trim = trim:Trim()
        Array<text> values = trim:Split("\.")

        integer filterSize = 0
        if not values:IsEmpty() and not trim:IsEmpty()
            if trim:GetCharacter(trim:GetSize() - 1) = "."
                result:filter = ""
            else
                result:filter = values:Get(values:GetSize() - 1)
            end

            text filter = result:filter
            filterSize = filter:GetSize()
        end

        constant text root = "Libraries"
        if values:GetSize() = 1
            text left = values:Get(0)
            text leftTrimmed = left:Trim()
            if leftTrimmed:IsEmpty()
                CodeCompletionItem item
                item:SetType(item:PACKAGE)
                item:displayText = root
                item:completionText = root
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
                AddCustomClasses(request, result, root)
            elseif left = root
                AddSubpackagesAndClasses(request, result, root)
                AddCustomClasses(request, result, root)
            elseif root:StartsWith(left)
                CodeCompletionItem item
                item:SetType(item:PACKAGE)
                item:displayText = root
                item:completionText = root
                text filter = result:filter
                integer size = filter:GetSize()
                item:dotOffset = request:caretLocation - size
                result:Add(item)
                AddCustomClasses(request, result, root)
            end
        else 
            text valueNoFilter = trim:GetSubtext(0, trim:GetSize() - filterSize - 1)
            AddSubpackagesAndClasses(request, result, valueNoFilter)
            //AddCustomClasses(request, result, valueNoFilter)
        end

//        final String root = this.standardLibrary.getStandardLibraryRootName();
//        if (split.length == 1) {
//            String left = split[0];
//            if (left.matches("\\s*") || result.getFilter().length() != 0) {
//                CodeCompletionItem item = new CodeCompletionItem();
//                item.setCodeCompletionType(CodeCompletionType.PACKAGE);
//                item.setCompletion(root);
//                item.setDisplayName(root);
//                result.add(item);
//                addCustomClasses(result, request, root);
//
//            } else if (left.equals(root)) {
//                addSubpackagesAndClasses(result, standardLibrary.getStandardLibraryRootName());
//                addCustomClasses(result, request, standardLibrary.getStandardLibraryRootName());
//            }
//        } 

//        if (split.length > 0 && line.length() != 0) {
//            if (line.charAt(line.length() - 1) == '.') {
//                result.setFilter("");
//            } else {
//                result.setFilter(split[split.length - 1]);
//            }
//        }

        a = 5
    end


    private action IsWhiteSpace(text value) returns boolean
        i = 0
        repeat while i < value:GetSize()
            text val = value:GetCharacter(i)

            return true
        end

        return true
    end
    /*
        This action compiles the array of files to Java Bytecode, which
        it writes to disk. By default, it generates a .jar file into the 
        folder named Run and the class files into the folder labeled
        Build.
    */
    action Compile(Array<File> files)
        hasBeenCompiled = true
        DateTime time
        profiler:Empty()
        profiler:Add(time:GetEpochTime())
        boolean isInvalidCompile = false
        checker:SetSymbolTable(symbolTable)
        if files = undefined
            isInvalidCompile = true
        elseif files:IsEmpty()
            isInvalidCompile = true
        end

        if isInvalidCompile
            CompilerError error
            text message = ""
            if files = undefined
                message = "I cannot compile an array of files that is passed to me undefined"
            elseif files:IsEmpty()
                message = "I cannot compile an arry of files that is empty. Please specify which files you would like compiled."
            end
            error:SetErrorMessage(message)
            CompilerErrorType t
            t:SetCurrentType(t:MISSING_FILE)
            error:SetCompilerErrorType(t)
            error:SetLineNumber(1)
            error:SetLineNumberEnd(1)
            error:SetColumnNumber(1)
            error:SetColumnNumberEnd(1)
            compilerErrorManager:Add(error)
            return now
        end

        i = 0
        repeat while i < files:GetSize()
            File file = files:Get(i)
            Parser listener
            Parse(file, listener)
            i = i + 1
        end
        profiler:Add(time:GetEpochTime())

        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = undefined
        if compilerErrorManager:IsCompilationErrorFree()
            allFiles = GetAllRequiredFiles(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end
        profiler:Add(time:GetEpochTime())

        if compilerErrorManager:IsCompilationErrorFree()
            TypeResolution(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end
        profiler:Add(time:GetEpochTime())

        Array<ClassOpcode> classOpcodes
        if compilerErrorManager:IsCompilationErrorFree()
            i = 0
            repeat while i < allFiles:GetSize()
                File file = allFiles:Get(i)
                QuorumBytecodeListener listener
                if not outputSpeechCommands
                    listener:SetOutputSpeech(outputSpeechCommands)
                end

                Parse(file, listener)

                if listener:HasSayStatementInClass()
                    containsSpeechCommandInCompile = true
                end
                ClassOpcode op = listener:GetClassOpcode()
                op:SetBuild(buildFolder)
                classOpcodes:Add(op)
                i = i + 1
            end
        else 
            return now
        end
        profiler:Add(time:GetEpochTime())

        File starter = files:Get(0)
        CheckMain(starter)
        
        //at this point, if the build is compilation free, it 
        //is guaranteed to not have compile errors, as no errors
        //can be issues in the bytecode writing stage.
        //if an error is issued, it is a bug in the compiler and not
        //an intentional design decision.
        if compilerErrorManager:IsCompilationErrorFree()
            if currentOutputType = JAVA_BYTECODE
                //open up and begin filling the Jar
                JarGenerator generator
                text manifest = GetManifest(generator)
                File jar = GetDistributionFile()
                generator:SetManifest(manifest)
                generator:Open(jar)

                //iterate over all the class opcodes and write them to disk
                Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()
                    code:Write()

                    File build = code:GetBuildFile()
                    File buildInterface = code:GetBuildInterfaceFile()

                    text key = code:GetStaticKey()
                    if build not= undefined
                        generator:Add(build)
                    end

                    if buildInterface not= undefined
                        generator:Add(buildInterface)
                    end
                end
                profiler:Add(time:GetEpochTime())

                //ok all of the classes are written in the jar. Now fill it up
                //with any dependencies that are necessary.
                WriteDependencies(generator)
                generator:Close()
                profiler:Add(time:GetEpochTime())
                
            elseif currentOutputType = JAVASCRIPT
                text result = ""
                Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()
                    Class clazz = code:GetClass()

                    Class mainClazz = me:GetMainClass()
                    text mainClazzName = mainClazz:GetStaticKey()
                    text clazzName = clazz:GetStaticKey()
                    if clazzName = mainClazzName //keep it simple in the first version.
                        result = result + code:WriteJavaScript()
                    end
                    a = 5
                end
                convertedJavaScript = result
            elseif currentOutputType = DOCUMENT
                text result = ""
                Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()
                    Class clazz = code:GetClass()

                    text web = code:WriteToWeb()
                    text key = clazz:GetStaticKey()
                    text parentKey = ""
                    Array<text> split = key:Split("\.")
                    i = 0
                    repeat split:GetSize() - 1 times
                        parentKey = parentKey + split:Get(i) + "/"
                        i = i + 1
                    end
                    key = "/" + key:Replace(".", "/") + ".php"

                    
                    buildFolder:CreateDirectories()
                    File mom
                    mom:SetWorkingDirectory(buildFolder:GetAbsolutePath())
                    mom:SetPath(DOCUMENTATION_FOLDER + "/" + parentKey)
                    mom:CreateDirectories()

                    File documentationFile
                    documentationFile:SetWorkingDirectory(buildFolder:GetAbsolutePath())
                    documentationFile:SetPath(DOCUMENTATION_FOLDER + "/" + key)

                    
                    documentationFile:Write(web)
                    a = 5
                end
                
                
                text index = "<?php $classPageTitle = 'The Quorum Standard Library'; include('static/templates/pageheader.template.php'); ?>"
                text dq = index:GetDoubleQuote()
                text NL = index:GetCarriageReturn()

                index = index + NL + " <div class=" + dq + "hero-unit" + dq + ">" + NL
                index = index + "<div class=" + dq + "hero-unit-container" + dq + ">"
		index = index + "<h1>The Quorum Standard Library</h1>"
		index = index + "<p>Quorum includes library classes like: 1) computer games, 2) text-to-speech and audio playback, 3) Lego robots, and 4) support classes (e.g., arrays, lists, hash tables, math, console, system). The standard library is expanded in each release.</p>"
		index = index + "</div></div>"
                index = index + "<div class=" + dq + "content index-content" + dq + ">"

                Iterator<text> packages = symbolTable:GetPackagesSortedIterator()
                repeat while packages:HasNext()
                    text key = packages:Next()
                    if not key:IsEmpty() //ignore the default package
                        index = index + NL + "<table class=" + dq + "table index-package" + dq + ">"
                        index = index + "<tr><th><h3 class=" + dq + "index_package_title" + dq + ">" + key + "</h3></th></tr>" + NL
                        Array<Class> classes = symbolTable:GetClassesSortedInPackage(key)
                        integer i2 = 0
                        repeat classes:GetSize() times
                            Class clazz = classes:Get(i2)
                            index = index + "<tr><td class=" + dq + "primary" + dq + ">" + NL
                            index = index + GetClassLinkFromIndex(clazz)//"<a href=" + dq + "" + dq + ">" + clazz:GetName() + "</a>" 
                            
                            Documentation doc = clazz:GetDocumentation()
                            if doc not= undefined
                                constant integer DOC_SIZE = 120
                                text description = doc:GetDescription()
                                if description = undefined
                                    description = ""
                                end
                                if description:GetSize() > DOC_SIZE
                                    description = description:GetSubtext(0, DOC_SIZE) + " ..."
                                end

                                index = index + ": " + description
                            end

                            index = index + "</td></tr>"
                            i2 = i2 + 1
                        end
                        index = index + "</table>"
                    end
                end
                index = index + NL + "</div" + NL + "<?php include('static/templates/pagefooter.template.php'); ?>"

                File documentationFile
                documentationFile:SetWorkingDirectory(buildFolder:GetAbsolutePath())
                documentationFile:SetPath(DOCUMENTATION_FOLDER + "/" + "libraries.php")
                documentationFile:Write(index)
            end
        end
    end

    private action GetClassLinkFromIndex(Class from) returns text
        text link = ""
        text key = from:GetStaticKey()
        Array<text> fromSplit = key:Split("\.")
        if fromSplit not= undefined
            i = 0
            repeat fromSplit:GetSize() times
                if i < fromSplit:GetSize() - 1
                    link = link + fromSplit:Get(i) + "/"
                else
                    link = link + fromSplit:Get(i) + ".php"
                end
                i = i + 1
            end
        end
        text dq = link:GetDoubleQuote()
        link = "<a href = " + dq + link + dq + ">" + from:GetName() + "</a>"
        return link
    end

    /*
        This action returns a profiler that has tracked information about 
        each phase of a compile as it goes. 
    */
    action GetCompilerProfiler returns CompilerProfiler
        return profiler
    end

    /*
        This action adds a directory of plugins to be written to the output jar
    */ 
    action AddPluginFolder(File file)
        if file:IsDirectory()
            additionalPluginFolders:Add(file)
        end
    end

    action EmptyAdditionalPluginFolders
        additionalPluginFolders:Empty()
    end

    action EmptyAdditionalJars
        additionalJarFiles:Empty()
    end

    /*
        This action checks if this is a jar file and then adds it as a dependency.
    */
    action AddJar(File file)
        text extension = file:GetFileExtension()
        if extension = "jar"
            additionalJarFiles:Add(file)
        end
    end

    // A convenience class used to write jars to disk.
    private action WriteJarToDisk(File file)
        File copyLocation
        File run = GetRunFolder()
        copyLocation:SetWorkingDirectory(run:GetWorkingDirectory())
        copyLocation:SetPath(run:GetPath() + "/" + JAR_DEPENDENCY_FOLDER + "/")


        if not copyLocation:Exists()
            copyLocation:CreateDirectories()
        end

        copyLocation:SetPath(run:GetPath() + "/" + JAR_DEPENDENCY_FOLDER + "/" + file:GetFileName())
        //check if the jar already exists. If the old file is newer
        //copy it. If not, ignore it.
        if not copyLocation:Exists()
            file:Copy(copyLocation)
        else 
            DateTime original = file:GetLastModifiedDate()
            DateTime copy = copyLocation:GetLastModifiedDate()
            if copyLocation:Exists() and (original:GetEpochTime() > copy:GetEpochTime())
                file:Copy(copyLocation)
            end
        end
    end

    private action WriteDependencies(JarGenerator generator)
        WritePlugins(generator, pluginFolder, pluginFolder)

        if not additionalPluginFolders:IsEmpty()
            Iterator<File> it = additionalPluginFolders:GetIterator()
            repeat while it:HasNext()
                File folder = it:Next()
                WritePlugins(generator, folder, folder)
            end
        end

        //copy any jar files that are dependencies to disk
        if not additionalJarFiles:IsEmpty()
            Iterator<File> jars = additionalJarFiles:GetIterator()
            repeat while jars:HasNext()
                File file = jars:Next()
                WriteJarToDisk(file)
            end
        end
        
        // Booleans added for the game/sound plugins.
        boolean hasGame = symbolTable:HasClass("Libraries.Game.Game")
        boolean hasAudio = symbolTable:HasClass("Libraries.Sound.Audio")

        Iterator<Class> tempIterator = symbolTable:GetClassesInPackage("Libraries.Robots.Lego")
        boolean hasRobots = false
        if tempIterator not= undefined
            hasRobots = tempIterator:HasNext()
        end

        if hasGame or hasAudio
            File lwjgl
            lwjgl:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/AdditionalJars/")
            lwjgl:SetPath("lwjgl.jar")
            WriteJarToDisk(lwjgl)
        end

        if hasRobots
            File file1
            File file2
            file1:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/AdditionalJars/")
            file2:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/AdditionalJars/")
            file1:SetPath("dbusjava.jar")
            file2:SetPath("ev3classes.jar")
            WriteJarToDisk(file1)
            WriteJarToDisk(file2)
        end

        //check the symbol table to see if the user generated any code
        //used in the compiler
        boolean hasCompiler = symbolTable:HasClass("Libraries.Language.Compile.Compiler")
        boolean hasTester = symbolTable:HasClass("Libraries.Language.Compile.Test.CompilerTestSuite")
        boolean hasClassWriter = symbolTable:HasClass("Libraries.Language.Compile.Translate.JavaBytecodeClassWriter")
        boolean hasMethodWriter = symbolTable:HasClass("Libraries.Language.Compile.Translate.JavaBytecodeMethodWriter")
        boolean hasfieldWriter = symbolTable:HasClass("Libraries.Language.Compile.Translate.JavaBytecodeFieldWriter")
        boolean hasLabel = symbolTable:HasClass("Libraries.Language.Compile.Translate.JavaBytecodeLabel")
        boolean hasSpeech = symbolTable:HasClass("Libraries.Sound.Speech")

        if hasCompiler or hasTester or hasClassWriter or hasMethodWriter or hasfieldWriter
            or hasLabel
            File to
            to:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            to:SetPath("org")

            File antlr
            antlr:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            antlr:SetPath("org/antlr")
            WriteCompilerDependency(generator, antlr, to)

            File abego
            abego:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            abego:SetPath("org/abego")
            WriteCompilerDependency(generator, abego, to)

            File objectWeb
            objectWeb:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            objectWeb:SetPath("org/objectweb")
            WriteCompilerDependency(generator, objectWeb, to)
        end

        if hasAudio
            File to
            to:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/sound/")
            to:SetPath("")

            File soundPlugins
            soundPlugins:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/sound")
            soundPlugins:SetPath("plugins")
            WriteCompilerDependency(generator, soundPlugins, to)
        end

        // If statement added for the game engine.
        if hasGame
            /*  From what I can tell, WriteCompilerDependency only uses the
                working directory of to, so setting the path is unnecessary. */
            File to
            to:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/game/")
            to:SetPath("")

            File gamePlugins
            gamePlugins:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/game/")
            gamePlugins:SetPath("plugins")
            WriteCompilerDependency(generator, gamePlugins, to)
        end

        if hasRobots
            File to
            to:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/robot/")
            to:SetPath("")

            File robotPlugins
            robotPlugins:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/robot/")
            robotPlugins:SetPath("plugins")
            WriteCompilerDependency(generator, robotPlugins, to)
        end

        if hasAudio or hasGame
            File gameNative
            gameNative:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Native/")
            gameNative:SetPath("Libraries.Game")

            File nativeCopy
            File run = GetRunFolder()
            nativeCopy:SetWorkingDirectory(run:GetAbsolutePath())
            nativeCopy:SetPath("jni")

            if not nativeCopy:Exists()
                nativeCopy:CreateDirectories()
            end
            
            //get all the files in this folder and copy them over
            Array<File> files = gameNative:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()
            repeat while it:HasNext()
                File file = it:Next()
                if not file:IsHidden()

                    File next
                    next:SetWorkingDirectory(nativeCopy:GetAbsolutePath() + "/")
                    next:SetPath(file:GetPath())
                    if file:IsFile()
                        DateTime fileTime = file:GetLastModifiedDate()//1.424560750484E12
                        DateTime nextTime = next:GetLastModifiedDate()//1.424560741363E12

                        //if it doesn't exist, copy the file
                        if not next:Exists()
                            file:Copy(next)
                        else
                            //if it does exist
                            if fileTime:GetEpochTime() > nextTime:GetEpochTime()
                                file:Copy(next)
                            end
                        end
                    end

                    if file:IsDirectory()
                        recursiveCopyDirectory(file, next)
                    end
                end
            end
        end

        if hasSpeech or HasSpeechCallInCompile()
            File to
            to:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            to:SetPath("org")

            File sapi
            sapi:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            sapi:SetPath("org/sapi")
            WriteCompilerDependency(generator, sapi, to)

            File speech
            speech:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
            speech:SetPath("org/sodbeans")
            WriteCompilerDependency(generator, speech, to)

            File speechNative
            speechNative:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Native/")
            speechNative:SetPath("Libraries.Sound.Speech")

            //copy this to the distribution directory
            File nativeCopy
            File run = GetRunFolder()
            nativeCopy:SetWorkingDirectory(run:GetAbsolutePath())
            nativeCopy:SetPath("jni")

            if not nativeCopy:Exists()
                nativeCopy:CreateDirectories()
            end
            
            //get all the files in this folder and copy them over
            Array<File> files = speechNative:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()
            repeat while it:HasNext()
                File file = it:Next()
                if not file:IsHidden()

                    File next
                    next:SetWorkingDirectory(nativeCopy:GetAbsolutePath() + "/")
                    next:SetPath(file:GetPath())
                    if file:IsFile()
                        DateTime fileTime = file:GetLastModifiedDate()//1.424560750484E12
                        DateTime nextTime = next:GetLastModifiedDate()//1.424560741363E12

                        //if it doesn't exist, copy the file
                        if not next:Exists()
                            file:Copy(next)
                        else
                            //if it does exist
                            if fileTime:GetEpochTime() > nextTime:GetEpochTime()
                                file:Copy(next)
                            end
                        end
                    end

                    if file:IsDirectory()
                        recursiveCopyDirectory(file, next)
                    end
                end
            end
        end
    end

    private action recursiveCopyDirectory(File from, File to) 
        if not to:Exists()
            to:CreateDirectories()
        end
        Array<File> files = from:GetDirectoryListing()
        Iterator<File> it = files:GetIterator()
        repeat while it:HasNext()
            File next = it:Next()
            if not next:IsHidden()
                if next:IsFile()
                    File copyTo
                    copyTo:SetWorkingDirectory(to:GetAbsolutePath() + "/")
                    copyTo:SetPath(next:GetPath())

                    DateTime fileTime = next:GetLastModifiedDate()
                    DateTime nextTime = copyTo:GetLastModifiedDate()

                    //if it doesn't exist, copy the file
                    if not copyTo:Exists()
                        next:Copy(copyTo)
                    else
                        //if it does exist
                        if fileTime:GetEpochTime() > nextTime:GetEpochTime()
                            next:Copy(copyTo)
                        end
                    end
                elseif next:IsDirectory()
                    File copyTo
                    copyTo:SetWorkingDirectory(to:GetAbsolutePath() + "/")
                    copyTo:SetPath(next:GetPath())
                    if not copyTo:Exists()
                        copyTo:CreateDirectories()
                    end
                    recursiveCopyDirectory(next, copyTo)
                end
            end
        end
    end

    private action WriteCompilerDependency(JarGenerator generator, File file, File originalLocation)
        if file:IsDirectory()
            Array<File> files = file:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()

            repeat while it:HasNext()
                File f = it:Next()
                WritePlugins(generator, f, originalLocation)
            end
        else
            text pluginPath = originalLocation:GetWorkingDirectory()
            text path = file:GetAbsolutePath()
            path = path:GetSubtext(pluginPath:GetSize())
            text wd = file:GetAbsolutePath()
            wd = wd:GetSubtext(0, pluginPath:GetSize() - 1)

            File f
            f:SetWorkingDirectory(wd)
            f:SetPath(path)
            
            //TODO: Optimize this to reduce the amount of copying that goes on
            generator:Add(f)
        end
    end

    private action WritePlugins(JarGenerator generator, File file, File originalLocation)
        if file:IsDirectory()
            Array<File> files = file:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()

            repeat while it:HasNext()
                File f = it:Next()
                if not f:IsHidden() and not (f:GetFileExtension() = "DS_Store")
                    WritePlugins(generator, f, originalLocation)
                end
            end
        else
            text pluginPath = originalLocation:GetWorkingDirectory()
            text path = file:GetAbsolutePath()
            path = path:GetSubtext(pluginPath:GetSize())
            text wd = file:GetAbsolutePath()
            boolean finished = true

            //if there's a slash at the end of the path, ignore it.
            if pluginPath:GetCharacter(pluginPath:GetSize() - 1) = "/"
                wd = wd:GetSubtext(0, pluginPath:GetSize() - 1)
                finished = false
            end

            if finished
                wd = wd:GetSubtext(0, pluginPath:GetSize())
            end

            File f
            f:SetWorkingDirectory(wd)
            f:SetPath(path)
            generator:Add(f)
        end
    end

    /*
        This action generates a default manifest file for the compiler, if 
        we are in bytecode format. This separates the logic from the jar 
        writer.
    */
    private action GetManifest(JarGenerator jar) returns text
        text version = jar:GetManifestVersion() + ": 1.0"
        line = version:GetCarriageReturn() + version:GetLineFeed()
        version = version + line
        
        
        text created = "Created-By: " + me:GetVersion()
        created = created + line

        text main = jar:GetManifestMainClass()

        File mainFile = me:GetMain()
        Class mainClass = me:GetMainClass()
        text classKey = "quorum." + mainClass:GetStaticKey()
        main = main + ": " + classKey
        main = main + line

        boolean usesLWJGL = symbolTable:HasClass("Libraries.Sound.Audio") or symbolTable:HasClass("Libraries.Game.Game")

        Iterator<Class> tempIterator = symbolTable:GetClassesInPackage("Libraries.Robots.Lego")
        boolean hasRobots = false
        if tempIterator not= undefined
            hasRobots = tempIterator:HasNext()
        end

        //now write any jar dependencies into the manifest
        if not additionalJarFiles:IsEmpty() or usesLWJGL or hasRobots
            Iterator<File> jars = additionalJarFiles:GetIterator()
            text classpath = "Class-Path: "
            text libraries = JAR_DEPENDENCY_FOLDER
            boolean isFirst = true
            repeat while jars:HasNext()
                File file = jars:Next()
                if isFirst
                    classpath = classpath + libraries + "/" + file:GetFileName()
                else
                    classpath = classpath + " " + libraries + "/" + file:GetFileName()
                end
                isFirst = false
            end

            if usesLWJGL
                File lwjgl
                lwjgl:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/AdditionalJars/")
                lwjgl:SetPath("lwjgl.jar")
                if isFirst
                    classpath = classpath + libraries + "/" + lwjgl:GetFileName()
                else
                    classpath = classpath + " " + libraries + "/" + lwjgl:GetFileName()
                end
            end

            if hasRobots
                File dbus
                File ev3
                dbus:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/AdditionalJars/")
                dbus:SetPath("dbusjava.jar")
                if isFirst
                    classpath = classpath + libraries + "/" + dbus:GetFileName()
                else
                    classpath = classpath + " " + libraries + "/" + dbus:GetFileName()
                end

                ev3:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/AdditionalJars/")
                ev3:SetPath("ev3classes.jar")
                classpath = classpath + " " + libraries + "/" + ev3:GetFileName()
            end

            main = main + classpath + line
        end

        total = version + created + main + line
        return total
    end

    private action CheckMain(File starter)
        Class m = GetMainClass()
        if m = undefined //no class that had a main method was selected, throw an error
            AddMainError(starter)
        elseif m not= undefined and m:HasMainAction() = false
            AddMainError(starter)
        else
            m:SetIsProgramStartingClass(true)
        end
    end

    private action AddMainError(File starter)
        CompilerError error
        text message = "I noticed that the class " + starter:GetPath() 
            +   " was specified as the starting point for this program, " 
            + "but it does not have an action named Main. " 

        Class clazz = symbolTable:GetClassInFile(starter:GetAbsolutePath())
        if clazz not= undefined
            if clazz:GetAction("main") not= undefined
                message = message + "This class does have an action named "
                    + "main, with a lower case m, did you mean for it to be "
                    + "capitalized?"
            end
        end
        error:SetErrorMessage(message)
        CompilerErrorType t
        t:SetCurrentType(t:MISSING_MAIN)
        error:SetCompilerErrorType(t)
        error:SetFile(starter)
        error:SetLineNumber(1)
        error:SetLineNumberEnd(1)
        error:SetColumnNumber(1)
        error:SetColumnNumberEnd(1)
        compilerErrorManager:Add(error)
    end

    /*
        This action parses a single source file at a particular location
    */ 
    action ParseSingle(text source, File file)
        Parser parser
        parser:SetFile(file)
        compilerErrorManager:RemoveErrorsAtKey(file:GetAbsolutePath())
        Parse(source, parser)
        
        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = undefined
        if compilerErrorManager:IsCompilationErrorFree()
            allFiles = GetAllRequiredFiles(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end

        if compilerErrorManager:IsCompilationErrorFree()
            TypeResolution(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end
    end

    action CompileSingle(text source)
        Parser parser
        File fakeLocation //set a default. It doesn't matter what it is.
        text fakePath = "SingleFileCompile.quorum"
        fakeLocation:SetPath(fakePath)
        me:SetMain(fakeLocation)
        parser:SetFile(fakeLocation)
        Parse(source, parser)
        
        //This array will contain all files that must be built, 
        //including potentially some from the standard library
        //in order to build the requested files
        Array<File> allFiles = undefined
        if compilerErrorManager:IsCompilationErrorFree()
            allFiles = GetAllRequiredFiles(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end

        if compilerErrorManager:IsCompilationErrorFree()
            TypeResolution(symbolTable, checker, compilerErrorManager)
        else 
            return now
        end

        CheckMain(fakeLocation)

        Array<ClassOpcode> classOpcodes
        if compilerErrorManager:IsCompilationErrorFree()
            i = 0
            repeat while i < allFiles:GetSize()
                File file = allFiles:Get(i)
                QuorumBytecodeListener listener

                if listener:HasSayStatementInClass()
                    containsSpeechCommandInCompile = true
                end

                if not outputSpeechCommands
                    listener:SetOutputSpeech(outputSpeechCommands)
                end

                if file:GetPath() = fakePath
                    listener:SetFile(file)
                    Parse(source, listener)
                else
                    Parse(file, listener)
                end
                ClassOpcode op = listener:GetClassOpcode()
                classOpcodes:Add(op)
                i = i + 1
            end
        else 
            return now
        end

        if compilerErrorManager:IsCompilationErrorFree()

            if currentOutputType = JAVA_BYTECODE
                //iterate over all the class opcodes and write them to disk
                Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()
                    code:Write()
                end

                if compilerErrorManager:IsCompilationErrorFree()
                    JarGenerator generator
                    File jar = GetDistributionFile()
                    //generator:SetCompiler(me)
                    //generator:Write()
                end
            elseif currentOutputType = JAVASCRIPT
                text result = ""
                Iterator<ClassOpcode> codes = classOpcodes:GetIterator()
                repeat while codes:HasNext()
                    ClassOpcode code = codes:Next()
                    Class clazz = code:GetClass()

                    Class mainClazz = me:GetMainClass()
                    text mainClazzName = mainClazz:GetStaticKey()
                    text clazzName = clazz:GetStaticKey()
                    if clazzName = mainClazzName //keep it simple in the first version.
                        result = result + code:WriteJavaScript()
                    end
                    a = 5
                end
                convertedJavaScript = result
            end
        end
    end

    action GetCompiledJavaScript returns text
        return convertedJavaScript
    end

    action TypeResolution(SymbolTable table, TypeChecker types, CompilerErrorManager errors)
        Iterator<Class> classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ResolveUseStatements(table, errors)
        end

        classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()

            //because of the way the parent flattening algorithm works,
            //classes may already be resolved
            if not next:IsResolved()
                next:ResolveAllTypes(table, errors)
            end
        end

        classes = table:GetClasses()
        repeat while classes:HasNext()
            Class next = classes:Next()
            next:ComputeVirtualActionTable(errors)
            next:ComputeGenericsTables(errors)
            types:Add(next)
        end
    end

    action IsCompilationErrorFree returns boolean
        return compilerErrorManager:IsCompilationErrorFree()
    end

    action GetCompilerErrorManager returns CompilerErrorManager
        return compilerErrorManager
    end

    action GetCompilerErrorsAsText returns text
        text EOL = ""
        EOL = EOL:GetCarriageReturn() + EOL:GetLineFeed()
        text result =  "This program did not compile. I have compiled a list of errors for you below:" + EOL
        Iterator<CompilerError> errors = compilerErrorManager:GetIterator()
        repeat while errors:HasNext()
            CompilerError error = errors:Next()
            text t = error:GetDisplayName()
            result = result + EOL + t
        end
        return result
    end

    action GetCompilerErrorsAsShortText returns text
        text EOL = ""
        EOL = EOL:GetCarriageReturn() + EOL:GetLineFeed()
        text result =  "I found problems:" + EOL
        Iterator<CompilerError> errors = compilerErrorManager:GetIterator()
        repeat while errors:HasNext()
            CompilerError error = errors:Next()
            text t = error:GetShortDisplayName()
            result = result + EOL + t
        end
        return result
    end

    /*
        This action is called after the parsing phase, returning an array
        of all files were required for building the project.
    */
    action GetAllRequiredFiles(SymbolTable table, TypeChecker types, CompilerErrorManager errors) returns Array<File>
        Array<File> files

        HashTable<text, File> parsed
        HashTable<text, File> unparsed

        Iterator<Class> classes = table:GetClasses()
//        repeat while classes:HasNext()
//            Class clazz = classes:Next()
//            File classFile = clazz:GetFile()
//            text path = classFile:GetAbsolutePath()
//            if not parsed:HasKey(path)
//                parsed:Add(path, clazz:GetFile())
//            end
//        end
//
//        classes = table:GetClasses()
        repeat while classes:HasNext()
            //gather up all the classes on the system and check their
            //use statements for classes we don't know about
            //if there are some, mark them as unparsed
            repeat while classes:HasNext()
                Class clazz = classes:Next()
                File classFile = clazz:GetFile()
                text path = classFile:GetAbsolutePath()
                if not parsed:HasKey(path)
                    parsed:Add(path, clazz:GetFile())
                end
                Iterator<QualifiedName> names = clazz:GetUnresolvedUseStatements()
                ResolveQualifiedNames(table, names, parsed, unparsed, clazz)

                Iterator<QualifiedName> parents = clazz:GetUnresolvedParents()
                ResolveParents(table, parents, parsed, unparsed, clazz)

                ResolveBlocks(table, parsed, unparsed, clazz)
            end

            //make list of any new classes that need to be analyzed
            //that have not previously been parsed. If there are some
            //send them back through the loop
            List<Class> newClasses
            Iterator<File> mustParse = unparsed:GetValueIterator()
            repeat while mustParse:HasNext()
                File next = mustParse:Next()
                Parser listener
                text null = undefined
                ParseSandbox(null, listener, table, errors, types, next)
                parsed:Add(next:GetAbsolutePath(), next)

                Iterator<Class> parsedClasses = listener:GetClassesIterator()
                repeat while parsedClasses:HasNext()
                    Class clazz = parsedClasses:Next()
                    newClasses:Add(clazz)
                    if not symbolTable:HasClass(clazz:GetStaticKey())
                        symbolTable:Add(clazz)
                    end
                end
            end
            classes = newClasses:GetIterator()
            unparsed:Empty()
        end
        return parsed:CopyToValueArray()
    end

    private action ResolveBlocks(SymbolTable table, HashTable<text, File> parsed,
        HashTable<text, File> unparsed, Class clazz)
        
        Iterator<Action> actions = clazz:GetActions()
        repeat while actions:HasNext()
            Action act = actions:Next()
            //resolve parameters first
            Iterator<Variable> parameters = act:GetParameterIterator()
            repeat while parameters:HasNext()
                Variable parameter = parameters:Next()
                Type type = parameter:GetType()
                ResolveClass(table, type:GetStaticKey(), clazz, parsed, unparsed)
            end
        end
    end

    /*
        This action handles resolving a class or otherwise scheduling a parse
        from the standard library. If a class is returned, then it has
        already been parsed and is in the symbol table. If the class
        returns is undefined, then either the class does not exist or 
        it is in the standard library and has not yet been parsed. As such,
        returning undefined is not necessarily a compiler error.
    */
    private action ResolveClass(SymbolTable table, text key, Class clazz, HashTable<text, File> parsed,
        HashTable<text, File> unparsed)
        boolean done = false
        Class c = undefined

        Type typeCheck
        typeCheck:SetToObject(key)
        //is this really just a primitive, pretending to be a class?
        if typeCheck:IsPrimitive()
            return now
        end


        //first check if it's already valid by looking at the symbol
        //table
        c = table:GetClass(key)

        //if it isn't there, check our use table
        if c = undefined
            c = clazz:GetValidUseName(key)
        end

        //if it isn't there, check the standard library, to 
        //see if there's a file in the right place
        //if there is, mark it for parsing
        if c = undefined
            File file = GetStandardLibraryFile(key, clazz:GetPackageKey())
            if file not= undefined
                text newPath = file:GetAbsolutePath()
                if parsed:HasKey(newPath) //this class has already been parsed
                elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing
                else
                    unparsed:Add(newPath, file)
                end
            else //ok last chance. Check an unresolved use statement to
                 //see if one of these reference the standard library
                 QualifiedName qn = clazz:GetUnresolvedUseStatement(key)
                 if qn not= undefined
                    file = GetStandardLibraryFile(qn:GetStaticKey(), clazz:GetPackageKey())
                    if file not= undefined
                        text newPath = file:GetAbsolutePath()
                        if parsed:HasKey(newPath) //this class has already been parsed
                        elseif unparsed:HasKey(newPath) //this class is already scheduled for parsing
                        else
                            unparsed:Add(newPath, file)
                        end
                    end
                 end
            end
        end
    end

    private action ResolveParents(SymbolTable table, Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            text key = qn:GetStaticKey()
            ResolveClass(table, key, clazz, parsed, unparsed)
        end
    end

    private action ResolveQualifiedNames(
            SymbolTable table, 
            Iterator<QualifiedName> names, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        repeat while names:HasNext()
            QualifiedName qn = names:Next()
            if qn:IsAll()
                ResolveAllClassesInContainer(table, qn, parsed, unparsed, clazz)
            else
                text key = qn:GetStaticKey()
                ResolveClass(table, key, clazz, parsed, unparsed)
            end
        end
    end

    private action ResolveAllClassesInContainer(SymbolTable table,
            QualifiedName name, 
            HashTable<text, File> parsed,
            HashTable<text, File> unparsed, Class clazz)
        //Get the container name without the "all" at the end
        File folder = GetStandardLibraryFolderForPackage(name:GetStaticKeyNoAll())

        //check if this is the standard library. If so, load them all into unparsed
        //if they aren't already in there or in parsed
        if folder not= undefined
            Array<File> files = folder:GetDirectoryListing()
            Iterator<File> it = files:GetIterator()
            repeat while it:HasNext()
                File file = it:Next()
                text path = file:GetAbsolutePath()
                if not file:IsDirectory() and not parsed:HasKey(path) and not unparsed:HasKey(path)
                    and file:GetFileExtension() = "quorum" and not table:HasFile(file:GetAbsolutePath())
                    unparsed:Add(path, file)
                end
            end
        end
    end

    private action GetStandardLibraryFolderForPackage(text key) returns File
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            standardLibraryFolder = build
        end
        text loc = standardLibraryFolder:GetWorkingDirectory()
        text loc2 = standardLibraryFolder:GetAbsolutePath()

        File file
        file:SetWorkingDirectory(loc2)

        Array<text> values = key:Split("\.")

        text location = "/"
        Iterator<text> it = values:GetIterator()
        repeat while it:HasNext()
            text next = it:Next()
            location = location + next

            if it:HasNext()
                location = location + "/"
            end
        end

        file:SetPath(location)
        if file:Exists()
            return file
        end
        return undefined
    end

    action GetStandardLibraryFile(text key, text fromPackage) returns File
        Array<text> values = key:Split("\.")
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            standardLibraryFolder = build
        end
        text loc = standardLibraryFolder:GetWorkingDirectory()
        text loc2 = standardLibraryFolder:GetAbsolutePath()

        File file
        file:SetWorkingDirectory(loc2)

        if values:GetSize() = 1
            text mySplit = "/" + fromPackage:Replace(".", "/") + "/" + key + ".quorum"
            file:SetPath(mySplit)
            if file:Exists()
                return file
            end
        else
            text location = "/"
            Iterator<text> it = values:GetIterator()
            repeat while it:HasNext()
                text next = it:Next()
                location = location + next

                if it:HasNext()
                    location = location + "/"
                else
                    location = location + ".quorum"
                end
            end

            file:SetPath(location)
            if file:Exists()
                return file
            end
        end
        
        return undefined
    end

    action Parse(File file, QuorumSourceListener listener)
        listener:SetSymbolTable(symbolTable)
        listener:SetCompilerErrorManager(compilerErrorManager)
        listener:SetFile(file)
        listener:SetTypeChecker(checker)
        ParseNative(file, listener)
    end

    private system action ParseNative(File file, QuorumSourceListener listener)


    action Parse(text source, QuorumSourceListener listener)
        listener:SetSymbolTable(symbolTable)
        listener:SetCompilerErrorManager(compilerErrorManager)
        listener:SetTypeChecker(checker)
        ParseNative(source, listener)
    end

    private system action ParseNative(text source, QuorumSourceListener listener)

    action GetName returns text
        return name
    end

    action GetNameWithExtension returns text
        return name + GetFileExtension()
    end

    action SetName(text name)
        me:name = name
    end

    action GetFileExtension returns text
        if IsWebApplication()
            return ".war"
        else
            return ".jar"
        end
    end

    action GetMain returns File
        return main
    end

    action GetMainClass returns Class
        text path = main:GetAbsolutePath()
        Class c = symbolTable:GetClassInFile(path)
        return c
    end

    action SetMain(File file)
        main = file
    end

    action GetVersion returns text
        return "Quorum " + VERSION
    end

    action GetOutputFolder returns File
        return outputFolder
    end

    action SetOutputFolder(File file)
        if file not= undefined
            outputFolder = file
            text path = file:GetAbsolutePath()

            if not file:Exists()
                file:CreateDirectories()
            end

            File build
            build:SetWorkingDirectory(path)
            build:SetPath(DEFAULT_BUILD_FOLDER)
            buildFolder = build

            File run 
            run:SetWorkingDirectory(path)
            run:SetPath(DEFAULT_RUN_FOLDER)
            me:runFolder = run
        else
            File root
            outputFolder = root
        end
    end

    action GetBuildFolder returns File
        return buildFolder
    end

    action GetStandardLibraryFolder returns File
        if standardLibraryFolder = undefined
            File build
            build:SetPath(DEFAULT_STANDARD_LIBRARY_FOLDER)
            return build
        end
        return standardLibraryFolder
    end

    action SetStandardLibraryFolder(File file)
        standardLibraryFolder = file
        File f
        f:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
        f:SetPath("plugins")
        pluginFolder = f

        File f2
        f2:SetWorkingDirectory(standardLibraryFolder:GetAbsolutePath() + "/Plugins/")
        f2:SetPath("org")
        dependencyFolder = f2
    end

    action GetDistributionFile returns File
        File run = GetRunFolder()
        text path = run:GetPath() + "/"
        File newRun
        newRun:SetWorkingDirectory(run:GetWorkingDirectory())
        newRun:SetPath(path + GetNameWithExtension())
        return newRun
    end

    action GetRunFolder returns File
        return runFolder
    end

    action IsWebApplication returns boolean
        return isWebApplication
    end

    action SetIsWebApplication(boolean web)
        isWebApplication = web
    end
end
